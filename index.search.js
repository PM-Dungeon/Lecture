var relearn_search_index = [
  {
    "breadcrumb": "",
    "content": "... And, lastly, there's the explosive growth in demand, which has led to many people doing it who aren't any good at it. Code is merely a means to an end. Programming is an art and code is merely its medium. Pointing a camera at a subject does not make one a proper photographer. There are a lot of self-described coders out there who couldn't program their way out of a paper bag.\n-- John Gruber auf daringfireball.net\nKursbeschreibung Sie haben letztes Semester in Prog1 die wichtigsten Elemente und Konzepte der Programmiersprache Java kennen gelernt.\nIn diesem Modul geht es darum, diese Kenntnisse sowohl auf der Java- als auch auf der Methoden-Seite so zu erweitern, dass Sie gemeinsam größere Anwendungen erstellen und pflegen können. Sie werden fortgeschrittene Konzepte in Java kennenlernen und sich mit etablierten Methoden in der Softwareentwicklung wie Versionierung von Code, Einhaltung von Coding Conventions, Grundlagen des Softwaretests, Anwendung von Refactoring, Einsatz von Build-Tools und Logging auseinander setzen. Wenn uns dabei ein Entwurfsmuster \"über den Weg läuft\", werden wir die Gelegenheit nutzen und uns dieses genauer anschauen.\nÜberblick Modulinhalte Fortgeschrittene Konzepte in Java Funktionale Programmierung: Default-Methoden, Funktionsinterfaces, Methodenreferenzen, Lambdas, Stream-API Generische Programmierung: Generics Parallele Programmierung: Threads Reguläre Ausdrücke, Annotationen, Reflection CLI, Konfiguration, fremde APIs nutzen Graphische Oberflächen mit Swing Fortgeschrittenes OO-Design Entwurfsmuster: Strategy, Template-Method, Factory-Method, Singleton, Observer, Visitor, Command, ... Programmiermethoden Versionskontrolle: Git Testen, Coding Conventions, Refactoring Logging, Build-Tools, CI (durchgestrichene Themen nicht im Sommersemester 2024)\nTeam Carsten Gips (Sprechstunde nach Vereinbarung) Tutoren (siehe ILIAS-Mitgliederliste) Kursformat ​ Vorlesung Praktikum Vorlesung (2 SWS)\nMi, 08:00 - 09:30 Uhr (online)\nDurchführung als Flipped Classroom.\nPraktikum (2 SWS)\nPraktikumsgruppe Zeit Raum Gruppe 1 Mi, 11:30 - 13:00 Uhr online Gruppe 2 Mi, 09:45 - 11:15 Uhr D320 Gruppe 3 Mi, 09:45 - 11:15 Uhr online Gruppe 4 Mi, 11:30 - 13:00 Uhr D320 Praktika Gruppen 2 und 4 in Präsenz.\nOnline-Sitzungen per Zoom (Zugangsdaten siehe ILIAS). Sie können hierzu den Raum J104 nutzen.\nFahrplan News Die nächste Klausur für \"Programmieren 2\" (IFM 2.1, PO23) wird am Mittwoch, 02. Oktober 2024 angeboten. Die Klausur wird als digitale Klausur auf dem Prüfungs-ILIAS der HSBI in Präsenz vor Ort in Minden im Raum B40 durchgeführt. Die Prüfung beginnt um 08:00 Uhr und dauert 90 Minuten. Ein DIN-A4-Zettel ist als Hilfsmittel zugelassen. Der geprüfte Stoff bezieht sich auf den zuletzt durchgeführten Kurs (Sommer 2024). Weitere Informationen siehe Prüfungsvorbereitung.\nHier finden Sie einen abonnierbaren Google Kalender mit allen Terminen der Veranstaltung zum Einbinden in Ihre Kalender-App.\nBitte geben Sie uns Feedback: Nehmen Sie bitte an der anonymen Umfrage zu \"Programmieren 2\" teil.\nMonat Tag Vorlesung Praktikum April 17. Orga (Zoom), FAQ 24. Generics: Klassen und Methoden, Bounds und Wildcards, Type Erasure, Polymorphie; Gradle B01 Mai 01. Mai-Feiertag Mai-Feiertag 08. Einführung Versionierung, Git Basics; Lambda-Ausdrücke; Javadoc B02 15. Dienstbesprechung B03 22. Git-Branches, Branching-Strategien; Methodenreferenzen; Logging B04 29. Git-Remotes, Git-Workflows; Stream-API; Record-Klassen; Intro Dungeon B05 Juni 05. Einführung Testen, JUnit-Basics; Optional; Visitor-Pattern B06 12. Testfallermittlung, Mocking; Default-Methoden; Observer-Pattern; Serialisierung B07 19. Code-Smells, Coding-Rules, Refactoring; Continuous Integration (CI) B08 26. RegExp; Template-Method-Pattern, Command-Pattern; Enumerationen B09 Juli 03. Intro Threads, Synchronisierung, Highlevel Threadkonzepte; Konfiguration B10 10. Rückblick (Zoom), Prüfungsvorbereitung tbd Klausur (Campus Minden, B40) Abgabe der Übungsblätter jeweils bis 08:00 Uhr im ILIAS.\nPrüfungsform, Note und Credits Parcoursprüfung, 5 ECTS (PO23)\n​ Prüfung im ersten Zeitraum Prüfung im zweiten Zeitraum Stationen: Praktikum: 10x Übungsblätter mit jeweils 1P (Einzelbearbeitung, mindestens 60% bearbeitet, fristgerechte Abgabe der Lösungen im ILIAS, Vorstellung der Lösungen im Praktikum =\u003e Punkte) Schriftliche Prüfung (digitale Klausur) mit 100P; Prüfungsvorbereitung Gesamtnote: 4.0: ab 50P, alle 5P nächste Teilnote, 1.0: ab 95P Stationen: Schriftliche Prüfung (digitale Klausur) mit 100P; Prüfungsvorbereitung Gesamtnote: 4.0: ab 50P, alle 5P nächste Teilnote, 1.0: ab 95P Materialien Literatur \"Java ist auch eine Insel\". Ullenboom, C., Rheinwerk-Verlag, 2021. ISBN 978-3-8362-8745-6. \"Pro Git (Second Edition)\". Chacon, S. und Straub, B., Apress, 2014. ISBN 978-1-4842-0077-3. \"The Java Tutorials\". Oracle Corporation, 2023. \"Learn Java\". Oracle Corporation, 2023. Tools JDK: Java SE 21 (LTS) (Oracle oder Alternativen, bitte 64-bit Version nutzen) IDE: Eclipse IDE for Java Developers oder IntelliJ IDEA (Community Edition) oder Visual Studio Code oder Vim oder ... Git Förderungen und Kooperationen Förderung durch DH.NRW (Digi Fellowships) Die Überarbeitung dieser Lehrveranstaltung wurde vom Ministerium für Kultur und Wissenschaft (MKW) in NRW im Einvernehmen mit der Digitalen Hochschule NRW (DH.NRW) gefördert: \"Fellowships für Innovationen in der digitalen Hochschulbildung\" (Digi Fellowships).\nKooperation mit dem DigikoS-Projekt Diese Vorlesung wird zudem vom Projekt \"Digitalbaukasten für kompetenzorientiertes Selbststudium\" (DigikoS) unterstützt. Ein vom DigikoS-Projekt ausgebildeter Digital Learning Scout hat insbesondere die Koordination der digitalen Gruppenarbeiten, des Peer-Feedbacks und der Postersessions in ILIAS technisch und inhaltlich begleitet. DigikoS wird als Verbundprojekt von der Stiftung Innovation in der Hochschullehre gefördert.",
    "description": "... And, lastly, there's the explosive growth in demand, which has led to many people doing it who aren't any good at it. Code is merely a means to an end. Programming is an art and code is merely its medium. Pointing a camera at a subject does not make one a proper photographer. There are a lot of self-described coders out there who couldn't program their way out of a paper bag.",
    "tags": [],
    "title": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024)",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/index.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Organisatorisches",
    "content": "Elektronische Klausur: Termin, Materialien Termin Die schriftliche Prüfung erfolgt durch eine Klausur, die als digitale Prüfung auf einem Prüfungs-ILIAS durchgeführt wird.\nEs wird angestrebt, die Klausur in Präsenz in den Rechnerpools am Campus Minden durchzuführen. Falls dies wegen der Corona-Situation oder anderer Umstände nicht möglich sein sollte, wird die Klausur als \"Open-Book-Ausarbeitung\" im Home-Office durchgeführt.\nEs wird in beiden Prüfungszeiträumen ein Termin angeboten. Die Termine werden vom Prüfungsamt bekannt gegeben.\nDauer jeweils 90 Minuten.\nDie konkrete Durchführungsform (in Präsenz am Campus Minden oder im Home-Office) wird Ihnen spätestens zwei Wochen vor der Prüfung über das LSF bekanntgegeben Zugelassene Hilfsmittel ​ Präsenz (in Minden) Open-Book-Ausarbeitung (Homeoffice) Zugelassene Materialien: DIN-A4-Spickzettel (beidseitig)\nSie dürfen einen Spickzettel im DIN-A4-Format benutzen, der beidseitig beschrieben sein kann.\nIch möchte Sie hier noch einmal ermuntern, diesen Zettel tatsächlich manuell zu erstellen (also ganz traditionell zu schreiben), da bereits der Schreibvorgang einen gewissen Lerneffekt bewirkt!\nFalls die Prüfung als Open-Book-Ausarbeitung im Home-Office durchgeführt werden sollte, dürfen Sie alle Unterlagen benutzen.\nAusnahme: Keine Hilfe durch Dritte! (insbesondere keine Zusammenarbeit, keine Kommunikation)\nSie sollen die Prüfung eigenständig bearbeiten. Hilfe von Dritten sowie jegliche Kommunikation mit Dritten ist in keinem Fall zugelassen und wird als Täuschungsversuch gewertet.\nEinsicht Prüfungseinsicht: Zeitnah; Bekanntgabe per Mail Technische Vorbereitungen ​ Präsenz (in Minden) Open-Book-Ausarbeitung (Homeoffice) Diese Bemerkungen betreffen die Durchführung als Präsenzprüfung in den Räumen am Campus Minden.\nHSBI-Zugangsdaten: Username, Passwort\nBei der Durchführung der Prüfung am Campus Minden wird Ihnen ein Rechner zur Verfügung gestellt. Dort läuft voraussichtlich ein Browser im Kiosk-Mode, wo Sie sich am Prüfungs-ILIAS anmelden. Dazu benötigen Sie ihre HSBI-Zugangsdaten, mit denen Sie sich auch im \"normalen\" ILIAS anmelden.\nStudierendenausweis und Personalausweis\nAn der Prüfung dürfen nur Personen teilnehmen, die dafür im LSF angemeldet sind. Es findet eine entsprechende Kontrolle statt. Halten Sie Ihren Studierendenausweis und Personalausweis bereit.\nDiese Bemerkungen betreffen die Durchführung aus dem Home-Office mit Ihrer Hardware. Bei der Durchführung in Präsenz in den Räumen am Campus Minden werden die technischen Details von uns für Sie vorbereitet sein.\nRechner: Nutzen Sie für die Prüfung einen stationären Rechner oder ein Notebook.\nVermeiden Sie die Verwendung von Tablets und Smartphones! Bei der Verwendung von Tablets kann es unter Umständen zu Darstellungsproblemen kommen. Smartphones sind aufgrund des kleinen Bildschirms für die Prüfungsdurchführung schlicht ungeeignet.\nBei fehlendem Zugang zu einem entsprechenden Endgerät kontaktieren Sie bitte frühzeitig die Prüfungsverantwortlichen.\nNetz: Stabil genug? Belastbar genug?\nWenn Sie keinen Zugang zu einer ausreichend stabilen Internetverbindung haben, setzen Sie sich frühzeitig mit Ihren Prüfungsverantwortlichen in Verbindung.\nVPN: Der Prüfungs-ILIAS ist nur im HSBI-VPN erreichbar.\nInstallieren Sie den VPN-Client (Anleitung: hsbi.de/dvz/faq/cat/7) und testen Sie im Vorfeld der Prüfung bei aktivierter VPN-Verbindung den Zugang zur Prüfungsplattform eassessment.hsbi.de. Zugangsdaten wie im normalen ILIAS.\nAchtung: Auch wenn Sie sich in den Räumen der HSBI befinden, müssen Sie oft die VPN-Verbindung aktivieren, um Zugang zur Prüfungsplattform zu erhalten.\nBrowser: Nutzen Sie einen der Standardbrowser (Edge, Firefox, Safari, Chrome/Chromium) in der Standardeinstellung: insbesondere JavaScript und Cookies müssen aktiviert/erlaubt sein.\nDeaktivieren Sie sämtliche Browser-Erweiterungen wie z.B. Ad-Blocker (AdBlockPlus, uBlock, ...) oder JavaScript-Blocker (No-Script, Ghostery, ...) für den Prüfungszeitraum.\nNutzen Sie Ihren Browser nicht im Privacy-Modus!\nHSBI-Zugangsdaten: Username, Passwort\nBei der Durchführung der Prüfung als Open-Book-Ausarbeitung führen Sie die Prüfung auf Ihrer eigenen Hardware im Home-Office durch. Auch hier müssen Sie sich am Prüfungs-ILIAS anmelden. Dazu benötigen Sie ihre HSBI-Zugangsdaten, mit denen Sie sich auch im \"normalen\" ILIAS anmelden.\nBearbeitung des E-Assessment Lesen Sie sich die Hinweise auf der Startseite durch\nBearbeiten Sie die Aufgaben in einem einzigen Browser-Tab\nÖffnen Sie die Aufgaben NICHT in parallelen Tabs! Es kann sonst zu Fehlfunktionen von ILIAS kommen.\nBewegen Sie sich nicht per Browser-Navigation (\"vor\", \"zurück\" im Browser) durch die Aufgaben, sondern nutzen Sie dafür die Buttons \"nächste Frage\", \"Weiter\" oder \"Zurück\" vom ILIAS!\nHinweis zu Anzeige der restlichen Bearbeitungsdauer\nWenn Sie den Browser bzw. das Tab mit der Prüfung im Laufe der Prüfung verlassen, wird Ihnen bei der Rückkehr unter Umständen eine falsche restliche Bearbeitungsdauer angezeigt. Sie können die Anzeige korrigieren/aktualisieren, indem Sie einfach zu einer vorigen oder nächsten Aufgabe navigieren.\nHinweis: Die restliche Bearbeitungsdauer wird im Test nur dann angezeigt, wenn diese Funktion von den Prüfenden aktiviert wurde.\nParallel zum E-Assessment läuft eine Zoom-Session, dort können Sie Fragen stellen\nVerbindungsprobleme (Home-Office):\nBei kurzzeitigen Verbindungsabbrüchen loggen Sie sich einfach wieder ein Wenn die Probleme länger dauern, gilt der Versuch als nicht unternommen (außer Sie haben die Probleme aktiv herbeigeführt, dann kann das als Täuschungsversuch gewertet werden, vgl. RPO §22a (4)) Fragetypen-Demo In Ihrem ILIAS-Kurs finden Sie eine Fragetypen-Demo mit den wichtigsten Fragetypen. Machen Sie sich mit der Mechanik der Fragetypen vertraut und schauen Sie sich die Kommentare bei den einzelnen Aufgaben an. Sie können die Demo bei Bedarf beliebig oft wiederholen.\nHinweise zu den Inhalten Klausurrelevant: Vorlesung und Praktikum\nFür Verständnis u.U. hilfreich: Studium der vertiefenden Literaturangaben\nFragen:\nSchauen Sie sich die Challenges und/oder Quizzes an ... Schauen Sie sich die Praktikumsaufgaben an ... Überlegen Sie sich, was zu einem Themengebiet im Rahmen einer Prüfung möglich ist und (wie) gefragt werden könnte :) Können vor Kennen :-)\nBeispiele für mögliche Fragen Vererbung und Polymorphie Betrachten Sie den folgenden Java-Code:\npublic class Person { public String getInfo(Person p) { return \"Person\"; } } public class Studi extends Person { public String getInfo(Studi s) { return \"Studi\"; } public static void main(String[] args) { Studi s = new Studi(); Person p = s; System.out.println(s.getInfo(p)); System.out.println(s.getInfo(s)); } } Geben Sie alle Ausgaben, die das obige Programm produziert, an.\nBegründen Sie Ihre Antwort kurz und stichhaltig (für jede Ausgabe!). Was geschieht, bzw. wieso kommt es zu der jeweiligen Ausgabe?\nMultithreading und Synchronisierung public class StaffelKaputt extends Thread { private Object stab; StaffelKaputt(Object stab) { this.stab = stab; } public void run() {nimmStab(); laufen(); stabAbgeben();} private void stabAbgeben() { synchronized (stab) { stab.notifyAll(); } } private void nimmStab() { synchronized (stab) { try { stab.wait(); } catch (Exception e) { } }} void laufen() { System.out.println(\"laufe ... \"); } public static void main(String[] args) { Object stab = new Object(); StaffelKaputt l1 = new StaffelKaputt(stab); StaffelKaputt l2 = new StaffelKaputt(stab); l1.start(); l2.start(); }} Das Programm enthält einen Fehler, der sich zur Laufzeit offenbart. Welche Ausgabe erwarten Sie (angenommen, das Programm wäre fehlerfrei; eine mögliche Variante reicht)? Welche Ausgabe erhalten Sie stattdessen? Korrigieren Sie den Fehler.\nReguläre Ausdrücke Auf welche Strings passt (im Sinne von \"match\") der folgende reguläre Ausdruck: \\s*([a-zA-Z0-9_.\\-]+)\\s*=\\s*(-?\\d+\\.?\\d*)\\s;?\\s*\nVersionieren mit Git Erklären Sie, wie man mit Git die Unterschiede zwischen zwei bestimmten Versionsständen einer Datei herausfindet.\nWas ist der Unterschied zwischen einer Workingcopy und einem Repository?\nWorin liegt der Unterschied zwischen folgenden Arbeitsschritten:\na. Editieren von Datei A.txt b. git add A.txt c. Editieren von Datei A.txt d. git commit\nversus\na. Editieren von Datei A.txt b. Editieren von Datei A.txt c. git add A.txt d. git commit\nWas würde git diff jeweils nach Schritt 2 anzeigen?\nKommandozeilenparameter Schreiben Sie ein Programm, welches auf zwei Kommandozeilenparameter reagieren kann. Die erkannten Parameter sollen auf der Konsole ausgegeben werden. Nutzen Sie Apache Commons CLI (API siehe Anhang).\nBeim Aufruf ohne Parameter soll eine Hilfe zum korrekten Aufruf ausgegeben werden und das Programm soll sich anschließend beenden. Das Programm soll den Parameter -debug erkennen. Das Programm soll den Parameter -x=10 erkennen, wobei der Wert beim Aufruf variieren kann (Integer). Die Parameter können in unterschiedlicher Reihenfolge auftreten. Es kann auch nur ein Parameter angegeben werden. Build mit Ant Was ist der Unterschied zwischen Ant-Targets und Ant-Tasks? Wie kann man Ant-Properties von außen (beim Aufruf) setzen? Schreiben Sie ein Ant-Target, welches alle .class-Dateien in einem Ordner umbenennt. Schreiben Sie ein Ant-Target, mit dem Sie die Javadoc-Dokumentation erzeugen, packen und das resultierende .zip-File in den Ordner dist/ verschieben. Schreiben Sie Ant-Targets, mit denen Sie JUnit-Testfälle ausführen und auswerten können. Generics Was kommt hier raus? Und warum?\npublic class X { void methode(int a) { System.out.println(\"non-generic\"); } \u003cT\u003e void methode(T a) { System.out.println(\"generisch\"); } public static void main(String[] args) { X x = new X(); x.methode(3); x.methode(new Integer(4)); x.methode(\"huhu\"); } } Logging Erklären Sie den Code. Was passiert?\nclass MyFormatter extends SimpleFormatter { public String format(LogRecord record) { return super.format(record) + \"---- FAKE ----\\n\"; } } public class MoreLogging { public static void main(String[] argv) { Logger l = Logger.getLogger(\"MoreLogging\"); l.setLevel(Level.FINE); ConsoleHandler myHandler = new ConsoleHandler(); myHandler.setFormatter(new MyFormatter()); myHandler.setLevel(Level.FINER); l.addHandler(myHandler); l.info(\"Hello World :-)\"); l.fine(\"fine\"); l.finer(\"finer\"); l.finest(\"finest\"); } } Methodenreferenzen Was bedeutet der folgende Code?\nList\u003cString\u003e str = Arrays.asList(\"a\", \"b\", \"A\", \"B\"); str.sort(String::compareToIgnoreCase);",
    "description": "Elektronische Klausur: Termin, Materialien Termin Die schriftliche Prüfung erfolgt durch eine Klausur, die als digitale Prüfung auf einem Prüfungs-ILIAS durchgeführt wird.\nEs wird angestrebt, die Klausur in Präsenz in den Rechnerpools am Campus Minden durchzuführen. Falls dies wegen der Corona-Situation oder anderer Umstände nicht möglich sein sollte, wird die Klausur als \"Open-Book-Ausarbeitung\" im Home-Office durchgeführt.\nEs wird in beiden Prüfungszeiträumen ein Termin angeboten. Die Termine werden vom Prüfungsamt bekannt gegeben.",
    "tags": [],
    "title": "Prüfungsvorbereitung",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/admin/exams.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024)",
    "content": "Generische Klassen \u0026 Methoden Bounds \u0026 Wildcards Type Erasure Generics und Polymorphie",
    "description": "Generische Klassen \u0026 Methoden Bounds \u0026 Wildcards Type Erasure Generics und Polymorphie",
    "tags": [],
    "title": "Generics: Umgang mit parametrisierten Typen",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/generics.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Generics",
    "content": "Generische Strukturen Vector speicher = new Vector(); speicher.add(1); speicher.add(2); speicher.add(3); speicher.add(\"huhu\"); int summe = 0; for (Object i : speicher) { summe += (Integer)i; } Problem: Nutzung des \"raw\" Typs Vector ist nicht typsicher!\nMögliche Fehler fallen erst zur Laufzeit und u.U. erst sehr spät auf: Offenbar werden im obigen Beispiel int-Werte erwartet, d.h. das Hinzufügen von \"huhu\" ist vermutlich ein Versehen (wird vom Compiler aber nicht bemerkt) Die Iteration über speicher kann nur allgemein als Object erfolgen, d.h. in der Schleife muss auf den vermuteten/gewünschten Typ gecastet werden: Hier würde dann der String \"huhu\" Probleme zur Laufzeit machen Vector\u003cInteger\u003e speicher = new Vector\u003cInteger\u003e(); speicher.add(1); speicher.add(2); speicher.add(3); speicher.add(\"huhu\"); int summe = 0; for (Integer i : speicher) { summe += i; } Vorteile beim Einsatz von Generics:\nDatenstrukturen/Algorithmen nur einmal implementieren, aber für unterschiedliche Typen nutzen Keine Vererbungshierarchie nötig Nutzung ist typsicher, Casting unnötig Geht nur für Referenztypen Beispiel: Collections-API Generische Klassen/Interfaces definieren Definition: \"\u003cTyp\u003e\" hinter Klassennamen\npublic class Stack\u003cE\u003e { public E push(E item) { addElement(item); return item; } } Stack\u003cE\u003e =\u003e Generische (parametrisierte) Klasse (auch: \"generischer Typ\") E =\u003e Formaler Typ-Parameter (auch: \"Typ-Variable\") Einsatz:\nStack\u003cInteger\u003e stack = new Stack\u003cInteger\u003e(); Integer =\u003e Typ-Parameter Stack\u003cInteger\u003e =\u003e Parametrisierter Typ Generische Klassen instantiieren Typ-Parameter in spitzen Klammern hinter Klasse bzw. Interface\nArrayList\u003cInteger\u003e il = new ArrayList\u003cInteger\u003e(); ArrayList\u003cDouble\u003e dl = new ArrayList\u003cDouble\u003e(); Beispiel I: Einfache generische Klassen class Tutor\u003cT\u003e { // T kann in Tutor *fast* wie Klassenname verwendet werden private T x; public T foo(T t) { ... } } Tutor\u003cString\u003e a = new Tutor\u003cString\u003e(); Tutor\u003cInteger\u003e b = new Tutor\u003c\u003e(); // ab Java7: \"Diamond Operator\" a.foo(\"wuppie\"); b.foo(1); b.foo(\"huhu\"); // Fehlermeldung vom Compiler Beispiel: classes.GenericClasses Typ-Inferenz Typ-Parameter kann bei new() auf der rechten Seite oft weggelassen werden =\u003e Typ-Inferenz\nTutor\u003cString\u003e x = new Tutor\u003c\u003e(); // \u003c\u003e: \"Diamantoperator\" (gilt seit Java 1.7)\nBeispiel II: Vererbung mit Typparametern interface Fach\u003cT1, T2\u003e { public void machWas(T1 a, T2 b); } class SHK\u003cT\u003e extends Tutor\u003cT\u003e { ... } class PM\u003cX, Y, Z\u003e implements Fach\u003cX, Z\u003e { public void machWas(X a, Z b) { ... } public Y getBla() { ... } } class Studi\u003cA,B\u003e extends Person { ... } class Properties extends Hashtable\u003cObject,Object\u003e { ... } Auch Interfaces und abstrakte Klassen können parametrisierbar sein.\nBei der Vererbung sind alle Varianten bzgl. der Typ-Variablen denkbar. Zu beachten ist dabei vor allem, dass die Typ-Variablen der Oberklasse (gilt analog für Interfaces) entweder durch Typ-Variablen der Unterklasse oder durch konkrete Typen spezifiziert sind. Die Typ-Variablen der Oberklasse dürfen nicht \"in der Luft hängen\" (siehe auch nächste Folie)!\nBeispiel III: Überschreiben/Überladen von Methoden class Mensch { ... } class Studi\u003cT extends Mensch\u003e { public void f(T t) { ... } } class Prof\u003cT\u003e extends Mensch { ... } class Tutor extends Studi\u003cMensch\u003e { public void f(Mensch t) { ... } // Ueberschreiben public void f(Tutor t) { ... } // Ueberladen } Vorsicht: So geht es nicht! class Foo\u003cT\u003e extends T { ... } class Fluppie\u003cT\u003e extends Wuppie\u003cS\u003e { ... } Generische Klasse Foo\u003cT\u003e kann nicht selbst vom Typ-Parameter T ableiten (warum?) Bei Ableiten von generischer Klasse Wuppie\u003cS\u003e muss deren Typ-Parameter S bestimmt sein: etwa durch den Typ-Parameter der ableitenden Klasse, beispielsweise Fluppie\u003cS\u003e (statt Fluppie\u003cT\u003e) Generische Methoden definieren \"\u003cTyp\u003e\" vor Rückgabetyp\npublic class Mensch { public \u003cT\u003e T myst(T m, T n) { return Math.random() \u003e 0.5 ? m : n; } } \"Mischen possible\":\npublic class Mensch\u003cE\u003e { public \u003cT\u003e T myst(T m, T n) { ... } public String myst(String m, String n) { ... } } Aufruf generischer Methoden Aufruf Aufruf mit Typ-Parameter vor Methodennamen, oder Inferenz durch Compiler Finden der richtigen Methode durch den Compiler Zuerst Suche nach exakt passender Methode, danach passend mit Konvertierungen =\u003e Compiler sucht gemeinsame Oberklasse in Typhierarchie Beispiel class Mensch { \u003cT\u003e T myst(T m, T n) { ... } } Mensch m = new Mensch(); m.\u003cString\u003emyst(\"Essen\", \"lecker\"); // Angabe Typ-Parameter m.myst(\"Essen\", 1); // String, Integer =\u003e T: Object m.myst(\"Essen\", \"lecker\"); // String, String =\u003e T: String m.myst(1.0, 1); // Double, Integer =\u003e T: Number Beispiel methods.GenericMethods Reihenfolge der Suche nach passender Methode gilt auch für nicht-generisch überladene Methoden\nclass Mensch { public \u003cT\u003e T myst(T m, T n) { System.out.println(\"X#myst: T\"); return m; } // NICHT gleichzeitig erlaubt wg. Typ-Löschung (s.u.): /* public \u003cT1, T2\u003e T1 myst(T1 m, T2 n) { System.out.println(\"X#myst: T\"); return m; } */ public String myst(String m, String n) { System.out.println(\"X#myst: String\"); return m; } public int myst(int m, int n) { System.out.println(\"X#myst: int\"); return m; } } public class GenericMethods { public static void main(String[] args) { Mensch m = new Mensch(); m.myst(\"Hello World\", \"m\"); m.myst(\"Hello World\", 1); m.myst(3, 4); m.myst(m, m); m.\u003cMensch\u003emyst(m, m); m.myst(m, 1); m.myst(3.0, 4); m.\u003cDouble\u003emyst(3, 4); } } Wrap-Up Begriffe:\nGenerischer Typ: Stack\u003cT\u003e Formaler Typ-Parameter: T Parametrisierter Typ:Stack\u003cLong\u003e Typ-Parameter: Long Raw Type: Stack Generische Klassen: public class Stack\u003cE\u003e { }\n\"\u003cTyp\u003e\" hinter Klassennamen Generische Methoden: public \u003cT\u003e T foo(T m) { }\n\"\u003cTyp\u003e\" vor Rückgabewert",
    "description": "Generische Strukturen Vector speicher = new Vector(); speicher.add(1); speicher.add(2); speicher.add(3); speicher.add(\"huhu\"); int summe = 0; for (Object i : speicher) { summe += (Integer)i; } Problem: Nutzung des \"raw\" Typs Vector ist nicht typsicher!\nMögliche Fehler fallen erst zur Laufzeit und u.U. erst sehr spät auf: Offenbar werden im obigen Beispiel int-Werte erwartet, d.h. das Hinzufügen von \"huhu\" ist vermutlich ein Versehen (wird vom Compiler aber nicht bemerkt) Die Iteration über speicher kann nur allgemein als Object erfolgen, d.h. in der Schleife muss auf den vermuteten/gewünschten Typ gecastet werden: Hier würde dann der String \"huhu\" Probleme zur Laufzeit machen Vector\u003cInteger\u003e speicher = new Vector\u003cInteger\u003e(); speicher.add(1); speicher.add(2); speicher.add(3); speicher.add(\"huhu\"); int summe = 0; for (Integer i : speicher) { summe += i; } Vorteile beim Einsatz von Generics:",
    "tags": [],
    "title": "Generische Klassen \u0026 Methoden",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/generics/classes-methods.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Generics",
    "content": "Bounds: Einschränken der generischen Typen public class Cps\u003cE extends Number\u003e { // Obere Schranke: E muss Number oder Subklasse sein // =\u003e Zugriff auf Methoden aus Number moeglich } Cps\u003cDouble\u003e a; Cps\u003cNumber\u003e b; Cps\u003cString\u003e c; // Fehler!!! Schlüsselwort extends gilt hier auch für Interfaces\nMehrere Interfaces: nach extends Klasse oder Interface, danach mit \"\u0026\" getrennt die restlichen Interfaces:\nclass Cps\u003cE extends KlasseOderInterface \u0026 I1 \u0026 I2 \u0026 I3\u003e {} Anmerkung: Der Typ-Parameter ist analog auch mit super (nach unten) einschränkbar\nBeispiel bounds.Cps Wildcards: Dieser Typ ist mir nicht so wichtig Wildcard mit \"?\" =\u003e steht für unbestimmten Typ\npublic class Wuppie { public void m1(List\u003c?\u003e a) { ... } public void m2(List\u003c? extends Number\u003e b) { ... } } m1: List beliebig parametrisierbar =\u003e In m1 für Objekte in Liste a nur Methoden von Object nutzbar!\nm2: List muss mit Number oder Subklasse parametrisiert werden. =\u003e Dadurch für Objekte in Liste b alle Methoden von Number nutzbar ...\nWeitere Eigenschaften:\nDurch Wildcard kein Zugriff auf den Typ Wildcard kann durch upper bound eingeschränkt werden Geht nicht bei Klassen-/Interface-Definitionen [Bloch2018]: Nur für Parameter und nicht für Rückgabewerte nutzen!\nHands-On: Ausgabe für generische Listen Ausgabe für Listen gesucht, die sowohl Elemente der Klasse A als auch Elemente der Klasse B enthalten können\nclass A { void printInfo() { System.out.println(\"A\"); } } class B extends A { void printInfo() { System.out.println(\"B\"); } } public class X { public static void main(String[] args) { List\u003cA\u003e x = new ArrayList\u003cA\u003e(); x.add(new A()); x.add(new B()); printInfo(x); // Klassenmethode in X, gesucht List\u003cB\u003e y = new ArrayList\u003cB\u003e(); y.add(new B()); y.add(new B()); printInfo(y); // Klassenmethode in X, gesucht } } Hinweis: Dieses Beispiel beinhaltet auch Polymorphie bei/mit generischen Datentypen, bitte vorher auch das Video zum vierten Teil \"Generics und Polymorphie\" anschauen\nErster Versuch (A und B und main() wie oben) public class X { public static void printInfo(List\u003cA\u003e list) { for (A a : list) { a.printInfo(); } } } =\u003e So gehts nicht! Eine List\u003cB\u003e ist keine List\u003cA\u003e (auch wenn ein B ein A ist, vgl. spätere Sitzung zu Generics und Vererbung ...)!\nBeispiel wildcards.v1.X Zweiter Versuch mit Wildcards (A und B und main() wie oben) public class X { public static void printInfo(List\u003c?\u003e list) { for (Object a : list) { a.printInfo(); } } } =\u003e So gehts auch nicht! Im Prinzip passt das jetzt für List\u003cA\u003e und List\u003cB\u003e. Dummerweise hat man durch das Wildcard keinen Zugriff mehr auf den Typ-Parameter und muss für den Typ der Laufvariablen in der for-Schleife dann Object nehmen. Aber Object kennt unser printInfo nicht ... Außerdem könnte man die Methode X#printInfo dank des Wildcards auch mit allen anderen Typen aufrufen ...\nBeispiel wildcards.v2.X Dritter Versuch (Lösung) mit Wildcards und Bounds (A und B und main() wie oben) public class X { public static void printInfo(List\u003c? extends A\u003e list) { for (A a : list) { a.printInfo(); } } } Das ist die Lösung. Man erlaubt als Argument nur List-Objekte und fordert, dass sie mit A oder einer Unterklasse von A parametrisiert sind. D.h. in der Schleife kann man sich auf den gemeinsamen Obertyp A abstützen und hat dann auch wieder die printInfo-Methode zur Verfügung ...\nKonsole wildcards.v3.X Wrap-Up Ein Wildcard (?) als Typ-Parameter steht für einen beliebigen Typ\nIst in Klasse oder Methode dann aber nicht mehr zugreifbar Mit Bounds kann man Typ-Parameter nach oben oder nach unten einschränken (im Sinne einer Vererbungshierarchie)\nextends: Der Typ-Parameter muss eine Unterklasse eines bestimmten Typen sein super: Der Typ-Parameter muss eine Oberklasse eines bestimmten Typen sein",
    "description": "Bounds: Einschränken der generischen Typen public class Cps\u003cE extends Number\u003e { // Obere Schranke: E muss Number oder Subklasse sein // =\u003e Zugriff auf Methoden aus Number moeglich } Cps\u003cDouble\u003e a; Cps\u003cNumber\u003e b; Cps\u003cString\u003e c; // Fehler!!! Schlüsselwort extends gilt hier auch für Interfaces\nMehrere Interfaces: nach extends Klasse oder Interface, danach mit \"\u0026\" getrennt die restlichen Interfaces:\nclass Cps\u003cE extends KlasseOderInterface \u0026 I1 \u0026 I2 \u0026 I3\u003e {} Anmerkung: Der Typ-Parameter ist analog auch mit super (nach unten) einschränkbar",
    "tags": [],
    "title": "Bounds \u0026 Wildcards",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/generics/bounds-wildcards.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Generics",
    "content": "Typ-Löschung (Type-Erasure) Der Compiler ersetzt nach Prüfung der Typen und ihrer Verwendung alle Typ-Parameter durch\nderen obere (Typ-)Schranke und passende explizite Cast-Operationen (im Byte-Code). Die obere Typ-Schranke ist in der Regel der Typ der ersten Bounds-Klausel oder Object, wenn keine Einschränkungen formuliert sind.\nBei parametrisierten Typen wie List\u003cT\u003e wird der Typ-Parameter entfernt, es entsteht ein sogenannter Raw-Typ (List, quasi implizit mit Object parametrisiert).\n=\u003e Ergebnis: Nur eine (untypisierte) Klasse! Zur Laufzeit gibt es keine Generics mehr!\nHinweis: In C++ ist man den anderen möglichen Weg gegangen und erzeugt für jede Instantiierung die passende Klasse. Siehe Modul \"Systemprogrammierung\" :)\nBeispiel: Aus dem folgenden harmlosen Code-Fragment:\nclass Studi\u003cT\u003e { T myst(T m, T n) { return n; } public static void main(String[] args) { Studi\u003cInteger\u003e a = new Studi\u003c\u003e(); int i = a.myst(1, 3); } } wird nach der Typ-Löschung durch Compiler (das steht dann quasi im Byte-Code):\nclass Studi { Object myst(Object m, Object n) { return n; } public static void main(String[] args) { Studi a = new Studi(); int i = (Integer) a.myst(1, 3); } } Die obere Schranke meist Object =\u003e new T() verboten/sinnfrei (s.u.)!\nType-Erasure bei Nutzung von Bounds vor der Typ-Löschung durch Compiler:\nclass Cps\u003cT extends Number\u003e { T myst(T m, T n) { return n; } public static void main(String[] args) { Cps\u003cInteger\u003e a = new Cps\u003c\u003e(); int i = a.myst(1, 3); } } nach der Typ-Löschung durch Compiler:\nclass Cps { Number myst(Number m, Number n) { return n; } public static void main(String[] args) { Cps a = new Cps(); int i = (Integer) a.myst(1, 3); } } Raw-Types: Ich mag meine Generics \"well done\" :-) Raw-Types: Instanziierung ohne Typ-Parameter =\u003e Object\nStack s = new Stack(); // Stack von Object-Objekten Wegen Abwärtskompatibilität zu früheren Java-Versionen noch erlaubt. Nutzung wird nicht empfohlen! (Warum?) Anmerkung Raw-Types darf man zwar selbst im Quellcode verwenden (so wie im Beispiel hier), sollte die Verwendung aber vermeiden wegen der Typ-Unsicherheit: Der Compiler sieht im Beispiel nur noch einen Stack für Object, d.h. dort dürfen Objekte aller Typen abgelegt werden - es kann keine Typprüfung durch den Compiler stattfinden. Auf einem Stack\u003cString\u003e kann der Compiler prüfen, ob dort wirklich nur String-Objekte abgelegt werden und ggf. entsprechend Fehler melden.\nEtwas anderes ist es, dass der Compiler im Zuge von Type-Erasure selbst Raw-Types in den Byte-Code schreibt. Da hat er vorher bereits die Typsicherheit geprüft und er baut auch die passenden Casts ein.\nDas Thema ist eigentlich nur noch aus Kompatibilität zu Java5 oder früher da, weil es dort noch keine Generics gab (wurden erst mit Java6 eingeführt).\nFolgen der Typ-Löschung: new new mit parametrisierten Klassen ist nicht erlaubt!\nclass Fach\u003cT\u003e { public T foo() { return new T(); // nicht erlaubt!!! } } Grund: Zur Laufzeit keine Klasseninformationen über T mehr\nIm Code steht return (CAST) new Object();. Das neue Object kann man anlegen, aber ein Cast nach irgendeinem anderen Typ ist sinnfrei: Jede Klasse ist ein Untertyp von Object, aber eben nicht andersherum. Außerdem fehlt dem Objekt vom Typ Object auch sämtliche Information und Verhalten, die der Cast-Typ eigentlich mitbringt ...\nFolgen der Typ-Löschung: static static mit generischen Typen ist nicht erlaubt!\nclass Fach\u003cT\u003e { static T t; // nicht erlaubt!!! static Fach\u003cT\u003e c; // nicht erlaubt!!! static void foo(T t) { ... }; // nicht erlaubt!!! } Fach\u003cString\u003e a; Fach\u003cInteger\u003e b; Grund: Compiler generiert nur eine Klasse! Beide Objekte würden sich die statischen Attribute teilen (Typ zur Laufzeit unklar!).\nHinweis: Generische (statische) Methoden sind erlaubt.\nFolgen der Typ-Löschung: instanceof instanceof mit parametrisierten Klassen ist nicht erlaubt!\nclass Fach\u003cT\u003e { void printType(Fach\u003c?\u003e p) { if (p instanceof Fach\u003cNumber\u003e) ... else if (p instanceof Fach\u003cString\u003e) ... } } Grund: Unsinniger Code nach Typ-Löschung:\nclass Fach { void printType(Fach p) { if (p instanceof Fach) ... else if (p instanceof Fach) ... } } Folgen der Typ-Löschung: .class .class mit parametrisierten Klassen ist nicht erlaubt!\nboolean x; List\u003cString\u003e a = new ArrayList\u003cString\u003e(); List\u003cInteger\u003e b = new ArrayList\u003cInteger\u003e(); x = (List\u003cString\u003e.class == List\u003cInteger\u003e.class); // Compiler-Fehler x = (a.getClass() == b.getClass()); // true Grund: Es gibt nur List.class (und kein List\u003cString\u003e.class bzw. List\u003cInteger\u003e.class)!\nWrap-Up Generics existieren eigentlich nur auf Quellcode-Ebene \"Type-Erasure\": Compiler entfernt nach Typ-Prüfungen etc. generische Typ-Parameter etc. =\u003e im Byte-Code nur noch Raw-Typen bzw. die oberen Typ-Schranken der Typ-Parameter, in der Regel Object Compiler baut passende Casts in Byte-Code ein Transparent für User; Auswirkungen beachten!",
    "description": "Typ-Löschung (Type-Erasure) Der Compiler ersetzt nach Prüfung der Typen und ihrer Verwendung alle Typ-Parameter durch\nderen obere (Typ-)Schranke und passende explizite Cast-Operationen (im Byte-Code). Die obere Typ-Schranke ist in der Regel der Typ der ersten Bounds-Klausel oder Object, wenn keine Einschränkungen formuliert sind.\nBei parametrisierten Typen wie List\u003cT\u003e wird der Typ-Parameter entfernt, es entsteht ein sogenannter Raw-Typ (List, quasi implizit mit Object parametrisiert).\n=\u003e Ergebnis: Nur eine (untypisierte) Klasse! Zur Laufzeit gibt es keine Generics mehr!",
    "tags": [],
    "title": "Type Erasure",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/generics/type-erasure.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Generics",
    "content": "Generische Polymorphie B\u003cE\u003e extends A\u003cE\u003e\nclass A\u003cE\u003e { ... } class B\u003cE\u003e extends A\u003cE\u003e { ... } A\u003cDouble\u003e ad = new B\u003cDouble\u003e(); A\u003cString\u003e as = new B\u003cString\u003e(); class Vector\u003cE\u003e { ... } class Stack\u003cE\u003e extends Vector\u003cE\u003e { ... } Vector\u003cDouble\u003e vd = new Stack\u003cDouble\u003e(); Vector\u003cString\u003e vs = new Stack\u003cString\u003e(); =\u003e Polymorphie bei Generics bezieht sich auf Typ (nicht Typ-Parameter)\nInvarianz: Generics sind invariant, d.h. ein HashSet\u003cString\u003e ist ein Untertyp von Set\u003cString\u003e. Bei der Vererbung muss der Typ-Parameter identisch sein.\nPolymorphie bei Generics bezieht sich nur auf Typ! \"B extends A\" bedeutet nicht \"C\u003cB\u003e extends C\u003cA\u003e\"\nStack\u003cNumber\u003e s = new Stack\u003cInteger\u003e(); // DAS GEHT SO NICHT! // Folgen (wenn obiges gehen wuerde): s.push(new Integer(3)); // das ginge sowieso ... // Folgen (wenn obiges gehen wuerde): // Stack\u003cNumber\u003e waere Oberklasse auch von Stack\u003cDouble\u003e s.push(new Double(2.0)); // waere dann auch erlaubt ... // Das Objekt (Stack\u003cInteger\u003e) kann aber keine Double speichern! // Zur Laufzeit keine Typ-Informationen mehr! Typ-Löschung =\u003e zur Laufzeit keine Typinformationen vorhanden Compiler muss Typen prüfen (können)! Abgrenzung: Polymorphie bei Arrays Wenn \"B extends A\" dann \"B[] extends A[]\"\nObject[] x = new String[] {\"Hello\", \"World\", \":-)\"}; x[0] = \"Hallo\"; x[0] = new Double(2.0); // Laufzeitfehler String[] y = x; // String[] ist KEIN Object[]!!! Arrays besitzen Typinformationen über gespeicherte Elemente Prüfung auf Typ-Kompatibilität zur Laufzeit (nicht Kompilierzeit!) Hinweis auf Java-Geschichte (Java-Insel: \"Type Erasure\") Arrays gab es sehr früh, Generics erst relativ spät (ab Java6) =\u003e bei Arrays fand man das Verhalten natürlich und pragmatisch (trotz der Laufzeit-Überprüfung).\nBei der Einführung von Generics musste man Kompatibilität sicherstellen (alter Code soll auch mit neuen Compilern übersetzt werden können - obwohl im alten Code Raw-Types verwendet werden). Außerdem wollte man von Laufzeit-Prüfung hin zu Compiler-Prüfung. Da würde das von Arrays bekannte Verhalten Probleme machen ...\nKovarianz: Arrays sind kovariant, d.h. ein Array vom Typ String[] ist wegen String extends Object ein Untertyp von Object[].\nBeispiel arrays.X Arrays vs. parametrisierte Klassen =\u003e Keine Arrays mit parametrisierten Klassen!\nFoo\u003cString\u003e[] x = new Foo\u003cString\u003e[2]; // Compilerfehler Foo\u003cString[]\u003e y = new Foo\u003cString[]\u003e(); // OK :) Arrays mit parametrisierten Klassen sind nicht erlaubt! Arrays brauchen zur Laufzeit Typinformationen, die aber durch die Typ-Löschung entfernt werden.\nDiskussion Vererbung vs. Generics Vererbung:\nIS-A-Beziehung Anwendung: Vererbungsbeziehung vorliegend, Eigenschaften verfeinern Beispiel: Ein Student ist eine Person Generics:\nSchablone (Template) für viele Datentypen Anwendung: Identischer Code für unterschiedliche Typen Beispiel: Datenstrukturen, Algorithmen generisch realisieren Wrap-Up Generics: Vererbung und Überladen möglich, aber: Aus \"U extends O\" folgt nicht \"A\u003cU\u003e extends A\u003cO\u003e\"\nAchtung: Bei Arrays gilt aber: Wenn \"U extends O\" dann gilt auch \"U[] extends O[]\" ...",
    "description": "Generische Polymorphie B\u003cE\u003e extends A\u003cE\u003e\nclass A\u003cE\u003e { ... } class B\u003cE\u003e extends A\u003cE\u003e { ... } A\u003cDouble\u003e ad = new B\u003cDouble\u003e(); A\u003cString\u003e as = new B\u003cString\u003e(); class Vector\u003cE\u003e { ... } class Stack\u003cE\u003e extends Vector\u003cE\u003e { ... } Vector\u003cDouble\u003e vd = new Stack\u003cDouble\u003e(); Vector\u003cString\u003e vs = new Stack\u003cString\u003e(); =\u003e Polymorphie bei Generics bezieht sich auf Typ (nicht Typ-Parameter)\nInvarianz: Generics sind invariant, d.h. ein HashSet\u003cString\u003e ist ein Untertyp von Set\u003cString\u003e. Bei der Vererbung muss der Typ-Parameter identisch sein.\nPolymorphie bei Generics bezieht sich nur auf Typ! \"B extends A\" bedeutet nicht \"C\u003cB\u003e extends C\u003cA\u003e\"",
    "tags": [],
    "title": "Generics und Polymorphie",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/generics/generics-polymorphism.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024)",
    "content": "Build-Systeme: Gradle Continuous Integration (CI)",
    "description": "Build-Systeme: Gradle Continuous Integration (CI)",
    "tags": [],
    "title": "Bauen von Programmen, Automatisierung, Continuous Integration",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/building.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Building",
    "content": "Automatisieren von Arbeitsabläufen Works on my machine ...\nEinen häufigen Ausspruch, den man bei der Zusammenarbeit in Teams zu hören bekommt, ist \"Also, bei mir läuft der Code.\" ...\nDas Problem dabei ist, dass jeder Entwickler eine andere Maschine hat, oft ein anderes Betriebssystem oder eine andere OS-Version. Dazu kommen noch eine andere IDE und/oder andere Einstellungen und so weiter.\nWie bekommt man es hin, dass Code zuverlässig auch auf anderen Rechnern baut? Ein wichtiger Baustein dafür sind sogenannte \"Build-Systeme\", also Tools, die unabhängig von der IDE (und den IDE-Einstellungen) für das Übersetzen der Software eingesetzt werden und deren Konfiguration dann mit im Repo eingecheckt wird. Damit kann die Software dann auf allen Rechnern und insbesondere dann auch auf dem Server (Stichwort \"Continuous Integration\") unabhängig von der IDE o.ä. automatisiert gebaut und getestet werden.\nBuild-Tools: Apache Ant Apache Maven Gradle Das sind die drei am häufigsten anzutreffenden Build-Tools in der Java-Welt.\nAnt ist von den drei genannten Tools das älteste und setzt wie Maven auf XML als Beschreibungssprache. In Ant müssen dabei alle Regeln stets explizit formuliert werden, die man benutzen möchte.\nIn Maven wird dagegen von einem bestimmten Entwicklungsmodell ausgegangen, hier müssen nur noch die Abweichungen zu diesem Modell konfiguriert werden.\nIn Gradle wird eine DSL basierend auf der Skriptsprache Groovy (läuft auf der JVM) eingesetzt, und es gibt hier wie in Maven ein bestimmtes eingebautes Entwicklungsmodell. Gradle bringt zusätzlich noch einen Wrapper mit, d.h. es wird eine Art Gradle-Starter im Repo konfiguriert, der sich quasi genauso verhält wie ein fest installiertes Gradle (s.u.).\nAchtung: Während Ant und Maven relativ stabil in der API sind, verändert sich Gradle teilweise deutlich zwischen den Versionen. Zusätzlich sind bestimmte Gradle-Versionen oft noch von bestimmten JDK-Versionen abhängig. In der Praxis bedeutet dies, dass man Gradle-Skripte im Laufe der Zeit relativ oft überarbeiten muss (einfach nur, damit das Skript wieder läuft - ohne dass man dabei irgendwelche neuen Features oder sonstige Vorteile erzielen würde). Ein großer Vorteil ist aber der Gradle-Wrapper (s.u.).\nGradle: Eine DSL in Groovy DSL: Domain Specific Language\n// build.gradle plugins { id 'java' id 'application' } repositories { mavenCentral() } dependencies { testImplementation 'junit:junit:4.13.2' } application { mainClass = 'fluppie.App' } Dies ist mit die einfachste Build-Datei für Gradle.\nÜber Plugins wird die Unterstützung für Java und das Bauen von Applikationen aktiviert, d.h. es stehen darüber entsprechende spezifische Tasks zur Verfügung.\nAbhängigkeiten sollen hier aus dem Maven-Repository MavenCentral geladen werden. Zusätzlich wird hier als Abhängigkeit für den Test (testImplementation) die JUnit-Bibliothek in einer Maven-artigen Notation angegeben (vgl. mvnrepository.com). (Für nur zur Übersetzung der Applikation benötigte Bibliotheken verwendet man stattdessen das Schlüsselwort implementation.)\nBei der Initialisierung wurde als Package fluppie angegeben. Gradle legt darunter per Default die Klasse App mit einer main()-Methode an. Entsprechend kann man über den Eintrag application den Einsprungpunkt in die Applikation konfigurieren.\nGradle-DSL Ein Gradle-Skript ist letztlich ein in Groovy geschriebenes Skript. Groovy ist eine auf Java basierende und auf der JVM ausgeführte Skriptsprache. Seit einigen Versionen kann man die Gradle-Build-Skripte auch in der Sprache Kotlin schreiben.\nDateien Für das Bauen mit Gradle benötigt man drei Dateien im Projektordner:\nbuild.gradle: Die auf der Gradle-DSL beruhende Definition des Builds mit den Tasks (und ggf. Abhängigkeiten) eines Projekts.\nEin Multiprojekt hat pro Projekt eine solche Build-Datei. Dabei können die Unterprojekte Eigenschaften der Eltern-Buildskripte \"erben\" und so relativ kurz ausfallen.\nsettings.gradle: Eine optionale Datei, in der man beispielsweise den Projektnamen oder bei einem Multiprojekt die relevanten Unterprojekte festlegt.\ngradle.properties: Eine weitere optionale Datei, in der projektspezifische Properties für den Gradle-Build spezifizieren kann.\nGradle Init Um eine neue Gradle-Konfiguration anlegen zu lassen, geht man in einen Ordner und führt darin gradle init aus. Gradle fragt der Reihe nach einige Einstellungen ab:\n$ gradle init Select type of project to generate: 1: basic 2: application 3: library 4: Gradle plugin Enter selection (default: basic) [1..4] 2 Select implementation language: 1: C++ 2: Groovy 3: Java 4: Kotlin 5: Scala 6: Swift Enter selection (default: Java) [1..6] 3 Split functionality across multiple subprojects?: 1: no - only one application project 2: yes - application and library projects Enter selection (default: no - only one application project) [1..2] 1 Select build script DSL: 1: Groovy 2: Kotlin Enter selection (default: Groovy) [1..2] 1 Select test framework: 1: JUnit 4 2: TestNG 3: Spock 4: JUnit Jupiter Enter selection (default: JUnit Jupiter) [1..4] 1 Project name (default: tmp): wuppie Source package (default: tmp): fluppie Typischerweise möchte man eine Applikation bauen (Auswahl 2 bei der ersten Frage). Als nächstes wird nach der Sprache des Projekts gefragt sowie nach der Sprache für das Gradle-Build-Skript (Default ist Groovy) sowie nach dem Testframework, welches verwendet werden soll.\nDamit wird die eingangs gezeigte Konfiguration angelegt.\nOrdner Durch gradle init wird ein neuer Ordner wuppie/ mit folgender Ordnerstruktur angelegt:\ndrwxr-xr-x 4 cagix cagix 4096 Apr 8 11:43 ./ drwxrwxrwt 1 cagix cagix 4096 Apr 8 11:43 ../ -rw-r--r-- 1 cagix cagix 154 Apr 8 11:43 .gitattributes -rw-r--r-- 1 cagix cagix 103 Apr 8 11:43 .gitignore drwxr-xr-x 3 cagix cagix 4096 Apr 8 11:43 app/ drwxr-xr-x 3 cagix cagix 4096 Apr 8 11:42 gradle/ -rwxr-xr-x 1 cagix cagix 8070 Apr 8 11:42 gradlew* -rw-r--r-- 1 cagix cagix 2763 Apr 8 11:42 gradlew.bat -rw-r--r-- 1 cagix cagix 370 Apr 8 11:43 settings.gradle Es werden Einstellungen für Git erzeugt (.gitattributes und .gitignore).\nIm Ordner gradle/ wird der Gradle-Wrapper abgelegt (s.u.). Dieser Ordner wird normalerweise mit ins Repo eingecheckt. Die Skripte gradlew und gradlew.bat sind die Startskripte für den Gradle-Wrapper (s.u.) und werden normalerweise ebenfalls ins Repo mit eingecheckt.\nDer Ordner .gradle/ (erscheint ggf. nach dem ersten Lauf von Gradle auf dem neuen Projekt) ist nur ein Hilfsordner (\"Cache\") von Gradle. Hier werden heruntergeladene Dateien etc. abgelegt. Dieser Order sollte nicht ins Repo eingecheckt werden und ist deshalb auch per Default im generierten .gitignore enthalten. (Zusätzlich gibt es im User-Verzeichnis auch noch einen Ordner .gradle/ mit einem globalen Cache.)\nIn settings.gradle finden sich weitere Einstellungen. Die eigentliche Gradle-Konfiguration befindet sich zusammen mit dem eigentlichen Projekt im Unterordner app/:\ndrwxr-xr-x 4 root root 4096 Apr 8 11:50 ./ drwxr-xr-x 5 root root 4096 Apr 8 11:49 ../ drwxr-xr-x 5 root root 4096 Apr 8 11:50 build/ -rw-r--r-- 1 root root 852 Apr 8 11:43 build.gradle drwxr-xr-x 4 root root 4096 Apr 8 11:43 src/ Die Datei build.gradle ist die durch gradle init erzeugte (und eingangs gezeigte) Konfigurationsdatei, vergleichbar mit build.xml für Ant oder pom.xml für Maven. Im Unterordner build/ werden die generierten .class-Dateien etc. beim Build-Prozess abgelegt.\nUnter src/ findet sich dann eine Maven-typische Ordnerstruktur für die Sourcen:\n$ tree src/ src/ |-- main | |-- java | | `-- fluppie | | `-- App.java | `-- resources `-- test |-- java | `-- fluppie | `-- AppTest.java `-- resources Unterhalb von src/ ist ein Ordner main/ für die Quellen der Applikation (Sourcen und Ressourcen). Für jede Sprache gibt es einen eigenen Unterordner, hier entsprechend java/. Unterhalb diesem folgt dann die bei der Initialisierung angelegte Package-Struktur (hier fluppie mit der Default-Main-Klasse App mit einer main()-Methode). Diese Strukturen wiederholen sich für die Tests unterhalb von src/test/.\nWer die herkömmlichen, deutlich flacheren Strukturen bevorzugt, also unterhalb von src/ direkt die Java-Package-Strukturen für die Sourcen der Applikation und unterhalb von test/ entsprechend die Strukturen für die JUnit-Test, der kann dies im Build-Skript einstellen:\nsourceSets { main { java { srcDirs = ['src'] } resources { srcDirs = ['res'] } test { java { srcDirs = ['test'] } } } Ablauf eines Gradle-Builds Ein Gradle-Build hat zwei Hauptphasen: Konfiguration und Ausführung.\nWährend der Konfiguration wird das gesamte Skript durchlaufen (vgl. Ausführung der direkten Anweisungen eines Tasks). Dabei wird ein Graph erzeugt: welche Tasks hängen von welchen anderen ab etc.\nAnschließend wird der gewünschte Task ausgeführt. Dabei werden zuerst alle Tasks ausgeführt, die im Graphen auf dem Weg zu dem gewünschten Task liegen.\nMit gradle tasks kann man sich die zur Verfügung stehenden Tasks ansehen. Diese sind der Übersicht halber noch nach \"Themen\" sortiert.\nFür eine Java-Applikation sind die typischen Tasks gradle build zum Bauen der Applikation (inkl. Ausführen der Tests) sowie gradle run zum Starten der Anwendung. Wer nur die Java-Sourcen compilieren will, würde den Task gradle compileJava nutzen. Mit gradle check würde man compilieren und die Tests ausführen sowie weitere Checks durchführen (gradle test würde nur compilieren und die Tests ausführen), mit gradle jar die Anwendung in ein .jar-File packen und mit gradle javadoc die Javadoc-Dokumentation erzeugen und mit gradle clean die generierten Hilfsdateien aufräumen (löschen).\nPlugin-Architektur Für bestimmte Projekttypen gibt es immer wieder die gleichen Aufgaben. Um hier Schreibaufwand zu sparen, existieren verschiedene Plugins für verschiedene Projekttypen. In diesen Plugins sind die entsprechenden Tasks bereits mit den jeweiligen Abhängigkeiten formuliert. Diese Idee stammt aus Maven, wo dies für Java-basierte Projekte umgesetzt ist.\nBeispielsweise erhält man über das Plugin java den Task clean zum Löschen aller generierten Build-Artefakte, den Task classes, der die Sourcen zu .class-Dateien kompiliert oder den Task test, der die JUnit-Tests ausführt ...\nSie können sich Plugins und weitere Tasks relativ leicht auch selbst definieren.\nAuflösen von Abhängigkeiten Analog zu Maven kann man Abhängigkeiten (etwa in einer bestimmten Version benötigte Bibliotheken) im Gradle-Skript angeben. Diese werden (transparent für den User) von einer ebenfalls angegeben Quelle, etwa einem Maven-Repository, heruntergeladen und für den Build genutzt. Man muss also nicht mehr die benötigten .jar-Dateien der Bibliotheken mit ins Projekt einchecken. Analog zu Maven können erzeugte Artefakte automatisch publiziert werden, etwa in einem Maven-Repository.\nFür das Projekt benötigte Abhängigkeiten kann man über den Eintrag dependencies spezifizieren. Dabei unterscheidet man u.a. zwischen Applikation und Tests: implementation und testImplementation für das Compilieren und Ausführen von Applikation bzw. Tests. Diese Abhängigkeiten werden durch Gradle über die im Abschnitt repositories konfigurierten Repositories aufgelöst und die entsprechenden .jar-Files geladen (in den .gradle/-Ordner).\nTypische Repos sind das Maven-Repo selbst (mavenCentral()) oder das Google-Maven-Repo (google()).\nDie Einträge in dependencies erfolgen dabei in einer Maven-Notation, die Sie auch im Maven-Repo mvnrepository.com finden.\nBeispiel mit weiteren Konfigurationen (u.a. Checkstyle und Javadoc) plugins { id 'java' id 'application' id 'checkstyle' } repositories { mavenCentral() } application { mainClass = 'hangman.Main' } java { sourceCompatibility = JavaVersion.VERSION_11 targetCompatibility = JavaVersion.VERSION_11 } run { standardInput = System.in } sourceSets { main { java { srcDirs = ['src'] } resources { srcDirs = ['res'] } } } checkstyle { configFile = file(“${rootDir}/google_checks.xml”) toolVersion = '10.19.0' } dependencies { implementation group: 'org.apache.poi', name: 'poi', version: '4.1.2' } javadoc { options.showAll() } Hier sehen Sie übrigens noch eine weitere mögliche Schreibweise für das Notieren von Abhängigkeiten: implementation group: 'org.apache.poi', name: 'poi', version: '4.1.2' und implementation 'org.apache.poi:poi:4.1.2' sind gleichwertig, wobei die letztere Schreibweise sowohl in den generierten Builds-Skripten und in der offiziellen Dokumentation bevorzugt wird.\nGradle und Ant (und Maven) Vorhandene Ant-Buildskripte kann man nach Gradle importieren und ausführen lassen. Über die DSL kann man auch direkt Ant-Tasks aufrufen. Siehe auch \"Using Ant from Gradle\".\nGradle-Wrapper project |-- app/ |-- build.gradle |-- gradlew |-- gradlew.bat `-- gradle/ `-- wrapper/ |-- gradle-wrapper.jar `-- gradle-wrapper.properties Zur Ausführung von Gradle-Skripten benötigt man eine lokale Gradle-Installation. Diese sollte für i.d.R. alle User, die das Projekt bauen wollen, identisch sein. Leider ist dies oft nicht gegeben bzw. nicht einfach lösbar.\nZur Vereinfachung gibt es den Gradle-Wrapper gradlew (bzw. gradlew.bat für Windows). Dies ist ein kleines Shellskript, welches zusammen mit einigen kleinen .jar-Dateien im Unterordner gradle/ mit ins Repo eingecheckt wird und welches direkt die Rolle des gradle-Befehls einer Gradle-Installation übernehmen kann. Man kann also in Konfigurationskripten, beispielsweise für Gitlab CI, alle Aufrufe von gradle durch Aufrufe von gradlew ersetzen.\nBeim ersten Aufruf lädt gradlew dann die spezifizierte Gradle-Version herunter und speichert diese in einem lokalen Ordner .gradle/. Ab dann greift gradlew auf diese lokale (nicht \"installierte\") gradle-Version zurück.\ngradle init erzeugt den Wrapper automatisch in der verwendeten Gradle-Version mit. Alternativ kann man den Wrapper nachträglich über gradle wrapper --gradle-version 6.5 in einer bestimmten (gewünschten) Version anlegen lassen.\nDa der Gradle-Wrapper im Repository eingecheckt ist, benutzen alle Entwickler damit automatisch die selbe Version, ohne diese auf ihrem System zuvor installieren zu müssen. Deshalb ist der Einsatz des Wrappers einem fest installierten Gradle vorzuziehen!\nWrap-Up Automatisieren von Arbeitsabläufen mit Build-Tools/-Skripten\nEinstieg in Gradle (DSL zur Konfiguration)\nTypisches Java-Entwicklungsmodell eingebaut Konfiguration der Abweichungen (Abhängigkeiten, Namen, ...) Gradle-Wrapper: Ersetzt eine feste Installation Link-Sammlung Gradle \"Getting Started\" \"Building Java Applications Sample\" \"Building Java Applications with libraries Sample\" \"Building Java Libraries Sample\" \"Building Java \u0026 JVM projects\"",
    "description": "Automatisieren von Arbeitsabläufen Works on my machine ...\nEinen häufigen Ausspruch, den man bei der Zusammenarbeit in Teams zu hören bekommt, ist \"Also, bei mir läuft der Code.\" ...\nDas Problem dabei ist, dass jeder Entwickler eine andere Maschine hat, oft ein anderes Betriebssystem oder eine andere OS-Version. Dazu kommen noch eine andere IDE und/oder andere Einstellungen und so weiter.\nWie bekommt man es hin, dass Code zuverlässig auch auf anderen Rechnern baut? Ein wichtiger Baustein dafür sind sogenannte \"Build-Systeme\", also Tools, die unabhängig von der IDE (und den IDE-Einstellungen) für das Übersetzen der Software eingesetzt werden und deren Konfiguration dann mit im Repo eingecheckt wird. Damit kann die Software dann auf allen Rechnern und insbesondere dann auch auf dem Server (Stichwort \"Continuous Integration\") unabhängig von der IDE o.ä. automatisiert gebaut und getestet werden.",
    "tags": [],
    "title": "Build-Systeme: Gradle",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/building/gradle.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Praktikum",
    "content": "Dieses Blatt ist bewusst einfach gestaltet und dient der Wiederholung Ihrer Kenntnisse aus der LV \"Programmieren 1\".\nImplementieren Sie in Java das Spiel Hangman.\nA01.1: Swing und Java2D (45%) (Verteilung: 20%, 10%, 5%, 5%, 5%)\nDas Spiel soll vollständig über eine in Swing und Java2D realisierte GUI bedient werden:\nVisualisieren Sie den Zustand des Galgenmännchens per Java2D. Visualisieren Sie den Zustand des zu ratenden Wortes geeignet. Es muss ein Eingabefeld geben, um den nächsten Buchstaben eingeben zu können. Die bisher eingegebenen Buchstaben sollen in der Reihenfolge der Eingabe angezeigt werden. Das Spiel soll per Knopfdruck abgebrochen und neu gestartet werden können. A01.2: Einlesen von Textdateien (45%) (Verteilung: 10%, 5%, 10%, 5%, 10%, 5%)\nEs soll die Möglichkeit geben, eine Textdatei mit zu ratenden Wörtern einzulesen:\nAuf Anforderung des Nutzers soll ein Auswahldialog erscheinen. Startverzeichnis ist der Ordner, in dem das Spiel gestartet wurde. Es sollen nur Textdateien mit der Endung .txt ausgewählt werden können. Es soll nur eine Datei ausgewählt werden können (also keine Mehrfachselektion). Die ausgewählte Textdatei soll eingelesen werden (Format: pro Zeile ein Wort). Alle eingelesenen Wörter sollen in eine Menge überführt und für das Spiel nutzbar gemacht werden. Es soll für jedes neue Spiel ein zufälliges Wort aus der Menge der eingelesenen Wörter zum Raten ausgewählt werden. A01.3: Dokumentation (10%) Erstellen Sie ein UML-Klassendiagramm für Ihre Lösung.\nA01.4: Bonus-Aufgaben (+25%) (Verteilung: +10%, +10%, +5%)\nHeben Sie in der Anzeige der eingegebenen Buchstaben die korrekt geratenen Buchstaben in grüner Farbe hervor. Passen Sie die Visualisierung des Galgenmännchens farblich an die Tageszeit an, beispielsweise könnte es in den Nachtstunden eine Art Dark-Mode geben und tagsüber einen Light-Mode. Alternativ könnten Sie auch die Farbe der Zeichnung mit der Uhrzeit variieren. Lassen Sie den Nutzer per Slider die Schwierigkeit variieren: Steuerung der Länge des zu ratenden Wortes und/oder Steuerung der Anzahl der erlaubten Fehlversuche.",
    "description": "Dieses Blatt ist bewusst einfach gestaltet und dient der Wiederholung Ihrer Kenntnisse aus der LV \"Programmieren 1\".\nImplementieren Sie in Java das Spiel Hangman.\nA01.1: Swing und Java2D (45%) (Verteilung: 20%, 10%, 5%, 5%, 5%)\nDas Spiel soll vollständig über eine in Swing und Java2D realisierte GUI bedient werden:\nVisualisieren Sie den Zustand des Galgenmännchens per Java2D. Visualisieren Sie den Zustand des zu ratenden Wortes geeignet. Es muss ein Eingabefeld geben, um den nächsten Buchstaben eingeben zu können. Die bisher eingegebenen Buchstaben sollen in der Reihenfolge der Eingabe angezeigt werden. Das Spiel soll per Knopfdruck abgebrochen und neu gestartet werden können. A01.2: Einlesen von Textdateien (45%) (Verteilung: 10%, 5%, 10%, 5%, 10%, 5%)",
    "tags": [],
    "title": "Blatt 01: Hangman (Wiederholung Swing)",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/homework/b01.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024)",
    "content": "Intro: Versionskontrolle in der Softwareentwicklung Basics der Versionsverwaltung mit Git (lokale Repos) Git Branches: Features unabhängig entwickeln und mit Git verwalten Branching-Strategien mit Git Arbeiten mit Git Remotes (dezentrale Repos) Zusammenarbeit: Git-Workflows und Merge-/Pull-Requests",
    "description": "Intro: Versionskontrolle in der Softwareentwicklung Basics der Versionsverwaltung mit Git (lokale Repos) Git Branches: Features unabhängig entwickeln und mit Git verwalten Branching-Strategien mit Git Arbeiten mit Git Remotes (dezentrale Repos) Zusammenarbeit: Git-Workflows und Merge-/Pull-Requests",
    "tags": [],
    "title": "Versionierung mit Git",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/git.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Git",
    "content": "Typische Probleme bei SW-Entwicklung Was hat wer wann (und wo) geändert? Und warum? Ich brauche den Stand von gestern/letzter Woche/... Ich will schnell mal eine neue Idee ausprobieren ... Ich arbeite an mehreren Rechnern (Synchronisation) Wir müssen gemeinsam an der gleichen Codebasis arbeiten. Wir arbeiten am Release v42, aber Kunde braucht schnell einen Fix für v40 Folgen SW-Entwicklung ohne Versionsverwaltung Filesystem müllt voll mit manuell versionierten Dateien/Sicherungen ala file_20120507_version2_cagi.txt Ordner/Projekte müssen dupliziert werden für neue Ideen Code müllt voll mit auskommentierten Zeilen (\"Könnte ja noch gebraucht werden\") Unklar, wann welche Änderung von wem warum eingeführt wurde Unbeabsichtigtes Überschreiben mit älteren Versionen beim Upload in gemeinsamen Filesharing-Bereich Prinzip Versionsverwaltung Repository: Datenbank mit verschiedenen Versionsständen, Kommentaren, Tags etc.\nWorkingcopy: Arbeitskopie eines bestimmten Versionsstandes\nVarianten: Zentrale Versionsverwaltung (Beispiel SVN) Es gibt ein zentrales Repository (typischerweise auf einem Server), von dem die Developer einen bestimmten Versionsstand \"auschecken\" (sich lokal kopieren) und in welches sie Änderungen wieder zurück \"pushen\".\nZur Abfrage der Historie und zum Veröffentlichen von Änderungen benötigt man entsprechend immer eine Verbindung zum Server.\nVarianten: Verteilte Versionsverwaltung (Beispiel Git) In diesem Szenario hat jeder Developer nicht nur die Workingcopy, sondern auch noch eine Kopie des Repositories. Zusätzlich kann es einen oder mehrere Server geben, auf denen dann nur das Repository vorgehalten wird, d.h. dort gibt es normalerweise keine Workingcopy. Damit kann unabhängig voneinander gearbeitet werden.\nAllerdings besteht nun die Herausforderung, die geänderten Repositories miteinander abzugleichen. Das kann zwischen dem lokalen Rechner und dem Server passieren, aber auch zwischen zwei \"normalen\" Rechnern (also zwischen den Developern).\nHinweis: GitHub ain't no Git! Git ist eine Technologie zur Versionsverwaltung. Es gibt verschiedene Implementierungen und Plugins für IDEs und Editoren. GitHub ist dagegen ein Dienstleister, wo man Git-Repositories ablegen kann und auf diese mit Git (von der Konsole oder aus der IDE) zugreifen kann. Darüber hinaus bietet der Service aber zusätzliche Features an, beispielsweise ein Issue-Management oder sogenannte Pull-Requests. Dies hat aber zunächst mit Git nichts zu tun. Weitere populäre Anbieter sind beispielsweise Bitbucket oder Gitlab oder Gitea, wobei einige auch selbst gehostet werden können.\nVersionsverwaltung mit Git: Typische Arbeitsschritte Repository anlegen (oder clonen)\nDateien neu erstellen (und löschen, umbenennen, verschieben)\nÄnderungen einpflegen (\"committen\")\nÄnderungen und Logs betrachten\nÄnderungen rückgängig machen\nProjektstand markieren (\"taggen\")\nEntwicklungszweige anlegen (\"branchen\")\nEntwicklungszweige zusammenführen (\"mergen\")\nÄnderungen verteilen (verteiltes Arbeiten, Workflows)\n(Globale) Konfiguration Minimum:\ngit config --global user.name \u003cname\u003e git config --global user.email \u003cemail\u003e Diese Konfiguration muss man nur einmal machen.\nWenn man den Schalter --global weglässt, gelten die Einstellungen nur für das aktuelle Projekt/Repo.\nZumindest Namen und EMail-Adresse muss man setzen, da Git diese Information beim Anlegen der Commits speichert (== benötigt!).\nAliase:\ngit config --global alias.ci commit git config --global alias.co checkout git config --global alias.br branch git config --global alias.st status git config --global alias.ll 'log --all --graph --decorate --oneline' Zusätzlich kann man weitere Einstellungen vornehmen, etwa auf bunte Ausgabe umschalten: git config --global color.ui auto oder Abkürzungen (Aliase) für Befehle definieren: git config --global alias.ll 'log --all --oneline --graph --decorate' ...\nGit (und auch GitHub) hat kürzlich den Namen des Default-Branches von master auf main geändert. Dies kann man in Git ebenfalls selbst einstellen: git config --global init.defaultBranch \u003cname\u003e.\nAnschauen kann man sich die Einstellungen in der Textdatei ~/.gitconfig oder per Befehl git config --global -l.\nNeues Repo anlegen git init\n=\u003e Erzeugt neues Repository im akt. Verzeichnis\ngit clone \u003curl\u003e\n=\u003e Erzeugt (verlinkte) Kopie des Repos unter \u003curl\u003e\nWrap-Up Git: Versionsmanagement mit dezentralen Repositories Anlegen eines lokalen Repos mit git init Clonen eines existierenden Repos mit git clone \u003curl\u003e",
    "description": "Typische Probleme bei SW-Entwicklung Was hat wer wann (und wo) geändert? Und warum? Ich brauche den Stand von gestern/letzter Woche/... Ich will schnell mal eine neue Idee ausprobieren ... Ich arbeite an mehreren Rechnern (Synchronisation) Wir müssen gemeinsam an der gleichen Codebasis arbeiten. Wir arbeiten am Release v42, aber Kunde braucht schnell einen Fix für v40 Folgen SW-Entwicklung ohne Versionsverwaltung",
    "tags": [],
    "title": "Intro: Versionskontrolle in der Softwareentwicklung",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/git/git-intro.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Git",
    "content": "Versionsverwaltung mit Git: Typische Arbeitsschritte Repository anlegen (oder clonen)\nDateien neu erstellen (und löschen, umbenennen, verschieben)\nÄnderungen einpflegen (\"committen\")\nÄnderungen und Logs betrachten\nÄnderungen rückgängig machen\nProjektstand markieren (\"taggen\")\nEntwicklungszweige anlegen (\"branchen\")\nEntwicklungszweige zusammenführen (\"mergen\")\nÄnderungen verteilen (verteiltes Arbeiten, Workflows)\nDateien unter Versionskontrolle stellen git add . (oder git add \u003cfile\u003e)\n=\u003e Stellt alle Dateien (bzw. die Datei \u003cfile\u003e) im aktuellen Verzeichnis unter Versionskontrolle\ngit commit\n=\u003e Fügt die Dateien dem Repository hinzu\nAbfrage mit git status\nÄnderungen einpflegen Abfrage mit: git status \"Staging\" von modifizierten Dateien: git add \u003cfile\u003e Committen der Änderungen im Stage: git commit Anmerkung: Alternativ auch mit git commit -m \"Kommentar\", um das Öffnen des Editors zu vermeiden ... geht einfach schneller ;)\nDas \"staging area\" stellt eine Art Zwischenebene zwischen Working Copy und Repository dar: Die Änderungen sind temporär \"gesichert\", aber noch nicht endgültig im Repository eingepflegt (\"committed\").\nMan kann den Stage dazu nutzen, um Änderungen an einzelnen Dateien zu sammeln und diese dann (in einem Commit) gemeinsam einzuchecken.\nMan kann den Stage in der Wirkung umgehen, indem man alle in der Working Copy vorliegenden Änderungen per git commit -a -m \"Kommentar\" eincheckt. Der Schalter \"-a\" nimmt alle vorliegenden Änderungen an bereits versionierten Dateien, fügt diese dem Stage hinzu und führt dann den Commit durch. Das ist das von SVN bekannte Verhalten. Achtung: Nicht versionierte Dateien bleiben dabei außen vor!\nLetzten Commit ergänzen git commit --amend -m \"Eigentlich wollte ich das so sagen\"\nWenn keine Änderungen im Stage sind, wird so die letzte Commit-Message geändert.\ngit add \u003cfile\u003e; git commit --amend\nDamit können vergessene Änderungen an der Datei \u003cfile\u003e zusätzlich im letzten Commit aufgezeichnet werden.\nIn beiden Fällen ändert sich die Commit-ID!\nWeitere Datei-Operationen: hinzufügen, umbenennen, löschen Neue (unversionierte) Dateien und Änderungen an versionierten Dateien zum Staging hinzufügen: git add \u003cfile\u003e Löschen von Dateien (Repo+Workingcopy): git rm \u003cfile\u003e Löschen von Dateien (nur Repo): git rm --cached \u003cfile\u003e Verschieben/Umbenennen: git mv \u003cfileAlt\u003e \u003cfileNeu\u003e Aus Sicht von Git sind zunächst alle Dateien \"untracked\", d.h. stehen nicht unter Versionskontrolle.\nMit git add \u003cfile\u003e (und git commit) werden Dateien in den Index (den Staging-Bereich, d.h. nach dem Commit letztlich in das Repository) aufgenommen. Danach stehen sie unter \"Beobachtung\" (Versionskontrolle). So lange, wie eine Datei identisch zur Version im Repository ist, gilt sie als unverändert (\"unmodified\"). Eine Änderung führt entsprechend zum Zustand \"modified\", und ein git add \u003cfile\u003e speichert die Änderungen im Stage. Ein Commit überführt die im Stage vorgemerkte Änderung in das Repo, d.h. die Datei gilt wieder als \"unmodified\".\nWenn eine Datei nicht weiter versioniert werden soll, kann sie aus dem Repo entfernt werden. Dies kann mit git rm \u003cfile\u003e geschehen, wobei die Datei auch aus der Workingcopy gelöscht wird. Wenn die Datei erhalten bleiben soll, aber nicht versioniert werden soll (also als \"untracked\" markiert werden soll), dann muss sie mit git rm --cached \u003cfile\u003e aus der Versionskontrolle gelöscht werden. Achtung: Die Datei ist dann nur ab dem aktuellen Commit gelöscht, d.h. frühere Revisionen enthalten die Datei noch!\nWenn eine Datei umbenannt werden soll, geht das mit git mv \u003cfileAlt\u003e \u003cfileNeu\u003e. Letztlich ist dies nur eine Abkürzung für die Folge git rm --cached \u003cfileAlt\u003e, manuelles Umbenennen der Datei in der Workingcopy und git add \u003cfileNeu\u003e.\nCommits betrachten Liste aller Commits: git log\ngit log -\u003cn\u003e oder git log --since=\"3 days ago\" Meldungen eingrenzen ... git log --stat Statistik ... git log --author=\"pattern\" Commits eines Autors git log \u003cfile\u003e Änderungen einer Datei Inhalt eines Commits: git show\nÄnderungen und Logs betrachten git diff [\u003cfile\u003e]\nÄnderungen zwischen Workingcopy und letztem Commit (ohne Stage)\nDas \"staging area\" wird beim Diff von Git behandelt, als wären die dort hinzugefügten Änderungen bereits eingecheckt (genauer: als letzter Commit im aktuellen Branch im Repo vorhanden). D.h. wenn Änderungen in einer Datei mittels git add \u003cdatei\u003e dem Stage hinzugefügt wurden, zeigt git diff \u003cdatei\u003e keine Änderungen an!\ngit diff commitA commitB\nÄnderungen zwischen Commits\nBlame: git blame \u003cfile\u003e\nWer hat was wann gemacht?\nDateien ignorieren: .gitignore Nicht alle Dateien gehören ins Repo: generierte Dateien: .class temporäre Dateien Datei .gitignore anlegen und committen Wirkt auch für Unterordner Inhalt: Reguläre Ausdrücke für zu ignorierende Dateien und Ordner # Compiled source # *.class *.o *.so # Packages # *.zip # All directories and files in a directory # bin/**/* man 5 gitignore Zeitmaschine Änderungen in Workingcopy rückgängig machen\nÄnderungen nicht in Stage: git checkout \u003cfile\u003e oder git restore \u003cfile\u003e Änderungen in Stage: git reset HEAD \u003cfile\u003e oder git restore --staged \u003cfile\u003e =\u003e Hinweise von git status beachten!\nDatei aus altem Stand holen:\ngit checkout \u003ccommit\u003e \u003cfile\u003e, oder git restore --source \u003ccommit\u003e \u003cfile\u003e Commit verwerfen, Geschichte neu: git revert \u003ccommit\u003e\nHinweis: In den neueren Versionen von Git ist der Befehl git restore hinzugekommen, mit dem Änderungen rückgängig gemacht werden können. Der bisherige Befehl git checkout steht immer noch zur Verfügung und bietet über git restore hinaus weitere Anwendungsmöglichkeiten.\nStempel (Tag) vergeben: git tag \u003ctagname\u003e \u003ccommit\u003e Tags anzeigen: git tag und git show \u003ctagname\u003e Wann und wie committen? Jeder Commit stellt einen Rücksetzpunkt dar!\nTypische Regeln:\nKleinere \"Häppchen\" einchecken: ein Feature oder Task (das nennt man auch atomic commit: das kleinste Set an Änderungen, die gemeinsam Sinn machen und die ggf. gemeinsam zurückgesetzt werden können) Logisch zusammenhängende Änderungen gemeinsam einchecken Projekt muss nach Commit compilierbar sein Projekt sollte nach Commit lauffähig sein Ein Commit sollte in sich geschlossen sein, d.h. die kleinste Menge an Änderungen enthalten, die gemeinsam einen Sinn ergeben und die (bei Bedarf) gemeinsam zurückgesetzt oder verschoben werden können. Das nennt man auch atomic commit.\nWenn Sie versuchen, die Änderungen in Ihrem Commit zu beschreiben (siehe nächste Folie \"Commit-Messages\"), dann werden Sie einen atomic commit mit einem kurzen Satz (natürlich im Imperativ!) beschreiben können. Wenn Sie mehr Text brauchen, haben Sie wahrscheinlich keinen atomic commit mehr vor sich.\nLesen Sie dazu auch How atomic Git commits dramatically increased my productivity - and will increase yours too.\nSchreiben von Commit-Messages: WARUM?! Schauen Sie sich einmal einen Screenshot eines git log --oneline 61e48f0..e2c8076 im Dungeon-CampusMinden/Dungeon an:\nNun stellen Sie sich vor, Sie sind auf der Suche nach Informationen, suchen einen bestimmten Commit oder wollen eine bestimmte Änderung finden ...\nWenn man das genauer analysiert, dann stören bestimmte Dinge:\nMischung aus Deutsch und Englisch \"Vor-sich-hin-Murmeln\": \"Layer system 5\" Teileweise werden Tags genutzt wie [BUG], aber nicht durchgängig Mischung zwischen verschiedenen Formen: \"Repo umbenennen\", \"Benenne Repo um\", \"Repo umbenannt\" Unterschiedliche Groß- und Kleinschreibung Sehr unterschiedlich lange Zeilen/Kommentare Das Beachten einheitlicher Regeln ist enorm wichtig!\nLeider sagt sich das so leicht - in der Praxis macht man es dann doch schnell wieder unsauber. Dennoch, auch im Dungeon-Repo gibt es einen positiven Trend (git log --oneline 8039d6c..7f49e89):\nTypische Regeln und Konventionen tauchen überall auf, beispielsweise in [Chacon2014] oder bei Tim Pope (siehe nächstes Beispiel) oder bei \"How to Write a Git Commit Message\".\nShort (50 chars or less) summary of changes More detailed explanatory text, if necessary. Wrap it to about 72 characters or so. In some contexts, the first line is treated as the subject of an email and the rest of the text as the body. The blank line separating the summary from the body is critical (unless you omit the body entirely); tools like rebase can get confused if you run the two together. Further paragraphs come after blank lines. - Bullet points are okay, too - Typically a hyphen or asterisk is used for the bullet, preceded by a single space, with blank lines in between, but conventions vary here Quelle: \"A Note About Git Commit Messages\" by Tim Pope on tbaggery.com\nDenken Sie sich die Commit-Message als E-Mail an einen zukünftigen Entwickler, der das in fünf Jahren liest!\nVom Aufbau her hat eine E-Mail auch eine Summary und dann den eigentlichen Inhalt ... Erklären Sie das \"WARUM\" der Änderung! (Das \"WER\", \"WAS\", \"WANN\" wird bereits automatisch von Git aufgezeichnet ...)\nLesen (und beachten) Sie unbedingt auch \"How to Write a Git Commit Message\"!\nAusflug \"Conventional Commits\" Die Commit-Messages dienen vor allem der Dokumentation und werden von Entwicklern gelesen.\nWenn man die Messages ein wenig stärker formalisieren würde, dann könnte man diese aber auch mit Tools verarbeiten und beispielsweise automatisiert Changelogs oder Release-Texte verfassen!\nBetrachten Sie einmal das Projekt ConventionalCommits.org. Dies ist ein solcher Versuch, die Commit-Messages (a) einheitlicher und lesbarer zu gestalten und (b) auch eine Tool-gestützte Auswertung zu erlauben.\nDas Projekt schlägt als Erweitung der üblichen Regeln zum Formatieren von Commit-Messages vor, dass in der ersten Zeile der Summary noch eine Abkürzung für die in diesem Commit erfolgte Änderung (Bug-Fix, neues Feature, ...) vorangestellt wird. Dieser Abkürzung kann in Klammern noch der Scope der Änderung hinzugefügt werden, beispielsweise den Bereich im Projekt, der von diesem Commit berührt wird. Wenn es eine breaking change ist, also alter Code nach dieser Änderung sich anders verhält oder vielleicht sogar nicht mehr kompiliert, wird noch ein \"!\" hinter dem Typ der Änderung ergänzt.\nBeispiel: Stellen Sie sich vor, im Dungeon-Projekt wurde ein neues Verhalten hinzugefügt.\nNormalerweise hätten Sie vielleicht diese Message geschrieben (angepasste Version aus Dungeon-CampusMinden/Dungeon/pull/469):\nadd fight skill - `DamageProjectileSkill` creates a new entity which causes `HealthDamage` when hitting another entity - `FireballSkill` is a more concrete implementation of this - Melee skills can be created with `DamageProjectileSkill` using a customised range - Example: the `FireballSkill` has a range of 10, a melee would have a considerably smaller range fixes #24 fixes #126 fixes #224 Mit ConventionalCommits.org könnte das dann so aussehen:\nfeat: add fight skill - `DamageProjectileSkill` creates a new entity which causes `HealthDamage` when hitting another entity - `FireballSkill` is a more concrete implementation of this - Melee skills can be created with `DamageProjectileSkill` using a customised range - Example: the `FireballSkill` has a range of 10, a melee would have a considerably smaller range fixes #24 fixes #126 fixes #224 Da es sich um ein neues Feature handelt, wurde der Summary in der ersten Zeile ein feat: vorangestellt.\nDie zu verwendenden Typen/Abkürzungen sind im Prinzip frei definierbar. Das Projekt ConventionalCommits.org schlägt eine Reihe von Abkürzungen vor. Auf diese Weise sollen in möglichst allen Projekten, die Conventional Commits nutzen, die selben Abkürzungen/Typen eingesetzt werden und so eine Tool-gestützte Auswertung möglich werden.\nOder zusätzlich mit dem Scope der Änderung:\nfeat(game): add fight skill - `DamageProjectileSkill` creates a new entity which causes `HealthDamage` when hitting another entity - `FireballSkill` is a more concrete implementation of this - Melee skills can be created with `DamageProjectileSkill` using a customised range - Example: the `FireballSkill` has a range of 10, a melee would have a considerably smaller range fixes #24 fixes #126 fixes #224 Der Typ feat wurde hier noch ergänzt um einen frei definierbaren Identifier für den Projektbereich. Dieser wird in Klammern direkt hinter den Typ notiert (hier feat(game):).\nIm Beispiel habe ich als Bereich \"game\" genommen, weil die Änderung sich auf den Game-Aspekt des Projekts bezieht. Im konkreten Projekt wären andere Bereiche eventuell \"dsl\" (für die im Projekt entwickelte Programmiersprache plus Interpreter) und \"blockly\" (für die Integration von Google Blockly zur Programmierung des Dungeons mit LowCode-Ansätzen). Das ist aber letztlich vom Projekt abhängig und weitestgehend Geschmackssache.\nOder zusätzlich noch als Auszeichnung \"breaking change\" (hier mit scope, geht aber auch ohne scope):\nfeat(game)!: add fight skill - `DamageProjectileSkill` creates a new entity which causes `HealthDamage` when hitting another entity - `FireballSkill` is a more concrete implementation of this - Melee skills can be created with `DamageProjectileSkill` using a customised range - Example: the `FireballSkill` has a range of 10, a melee would have a considerably smaller range fixes #24 fixes #126 fixes #224 Angenommen, das neue Feature muss in der API etwas ändern, so dass existierender Code nun nicht mehr funktionieren würde. Dies wird mit dem extra Ausrufezeichen hinter dem Typ/Scope kenntlich gemacht (hier feat(game)!:).\nZusätzlich kann man einen \"Footer\" in die Message einbauen, also eine extra Zeile am Ende, die mit dem String \"BREAKING CHANGE:\" eingeleitet wird. (vgl. Conventional Commits \u003e Examples)\nEs gibt noch viele weitere Initiativen, Commit-Messages lesbarer zu gestalten und zu vereinheitlichen. Schauen Sie sich beispielsweise einmal gitmoji.dev an. (Mit einem Einsatz in einem professionellen Umfeld wäre ich hier aber sehr ... vorsichtig.)\nWrap-Up Änderungen einpflegen zweistufig (add, commit) Status der Workingcopy mit status ansehen Logmeldungen mit log ansehen Änderungen auf einem File mit diff bzw. blame ansehen Projektstand markieren mit tag Ignorieren von Dateien/Ordnern: Datei .gitignore",
    "description": "Versionsverwaltung mit Git: Typische Arbeitsschritte Repository anlegen (oder clonen)\nDateien neu erstellen (und löschen, umbenennen, verschieben)\nÄnderungen einpflegen (\"committen\")\nÄnderungen und Logs betrachten\nÄnderungen rückgängig machen\nProjektstand markieren (\"taggen\")\nEntwicklungszweige anlegen (\"branchen\")\nEntwicklungszweige zusammenführen (\"mergen\")\nÄnderungen verteilen (verteiltes Arbeiten, Workflows)\nDateien unter Versionskontrolle stellen git add . (oder git add \u003cfile\u003e)\n=\u003e Stellt alle Dateien (bzw. die Datei \u003cfile\u003e) im aktuellen Verzeichnis unter Versionskontrolle",
    "tags": [],
    "title": "Basics der Versionsverwaltung mit Git (lokale Repos)",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/git/git-basics.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024)",
    "content": "Lambda-Ausdrücke und funktionale Interfaces Methoden-Referenzen Stream-API Record-Klassen Optional Interfaces: Default-Methoden",
    "description": "Lambda-Ausdrücke und funktionale Interfaces Methoden-Referenzen Stream-API Record-Klassen Optional Interfaces: Default-Methoden",
    "tags": [],
    "title": "Modern Java: Funktionaler Stil und Stream-API",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/modern-java.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Modern Java",
    "content": "Problem: Sortieren einer Studi-Liste List\u003cStudi\u003e sl = new ArrayList\u003c\u003e(); // Liste sortieren? sl.sort(???); // Parameter: java.util.Comparator\u003cStudi\u003e public class MyCompare implements Comparator\u003cStudi\u003e { @Override public int compare(Studi o1, Studi o2) { return o1.getCredits() - o2.getCredits(); } } // Liste sortieren? MyCompare mc = new MyCompare(); sl.sort(mc); Da Comparator\u003cT\u003e ein Interface ist, muss man eine extra Klasse anlegen, die die abstrakte Methode aus dem Interface implementiert und ein Objekt von dieser Klasse erzeugen und dieses dann der sort()-Methode übergeben.\nDie Klasse bekommt wie in Java üblich eine eigene Datei und ist damit in der Package-Struktur offen sichtbar und \"verstopft\" mir damit die Strukturen: Diese Klasse ist doch nur eine Hilfsklasse ... Noch schlimmer: Ich brauche einen Namen für diese Klasse!\nDen ersten Punkt könnte man über verschachtelte Klassen lösen: Die Hilfsklasse wird innerhalb der Klasse definiert, die das Objekt benötigt. Für den zweiten Punkt brauchen wir mehr Anlauf ...\nErinnerung: Verschachtelte Klassen (\"Nested Classes\") Man kann Klassen innerhalb von Klassen definieren: Verschachtelte Klassen.\nImplizite Referenz auf Instanz der äußeren Klasse, Zugriff auf alle Elemente Begriffe: \"normale\" innere Klassen: \"inner classes\" statische innere Klassen: \"static nested classes\" Einsatzzweck: Hilfsklassen: Zusätzliche Funktionalität kapseln; Nutzung nur in äußerer Klasse Kapselung von Rückgabewerten Sichtbarkeit: Wird u.U. von äußerer Klasse \"überstimmt\"\nInnere Klassen (\"Inner Classes\") Objekt der äußeren Klasse muss existieren Innere Klasse ist normales Member der äußeren Klasse Implizite Referenz auf Instanz äußerer Klasse Zugriff auf alle Elemente der äußeren Klasse Sonderfall: Definition innerhalb von Methoden (\"local classes\") Nur innerhalb der Methode sichtbar Kennt zusätzlich final Attribute der Methode Beispiel:\npublic class Outer { ... private class Inner { ... } Outer.Inner inner = new Outer().new Inner(); } Beispiel mit Iterator als innere Klasse: nested.StudiListNested Statische innere Klassen (\"Static Nested Classes\") Keine implizite Referenz auf Objekt Nur Zugriff auf Klassenmethoden und -attribute Beispiel:\nclass Outer { ... static class StaticNested { ... } } Outer.StaticNested nested = new Outer.StaticNested(); Lösung: Comparator als anonyme innere Klasse List\u003cStudi\u003e sl = new ArrayList\u003c\u003e(); // Parametrisierung mit anonymer Klasse sl.sort( new Comparator\u003cStudi\u003e() { @Override public int compare(Studi o1, Studi o2) { return o1.getCredits() - o2.getCredits(); } }); // Semikolon nicht vergessen!!! =\u003e Instanz einer anonymen inneren Klasse, die das Interface Comparator\u003cStudi\u003e implementiert\nFür spezielle, einmalige Aufgabe: nur eine Instanz möglich Kein Name, kein Konstruktor, oft nur eine Methode Müssen Interface implementieren oder andere Klasse erweitern Achtung Schreibweise: ohne implements oder extends! Konstruktor kann auch Parameter aufweisen Zugriff auf alle Attribute der äußeren Klasse plus alle final lokalen Variablen Nutzung typischerweise bei GUIs: Event-Handler etc. Demo: nested.DemoAnonymousInnerClass Vereinfachung mit Lambda-Ausdruck List\u003cStudi\u003e sl = new ArrayList\u003c\u003e(); // Parametrisierung mit anonymer Klasse sl.sort( new Comparator\u003cStudi\u003e() { @Override public int compare(Studi o1, Studi o2) { return o1.getCredits() - o2.getCredits(); } }); // Semikolon nicht vergessen!!! // Parametrisierung mit Lambda-Ausdruck sl.sort( (Studi o1, Studi o2) -\u003e o1.getCredits() - o2.getCredits() ); Anmerkung: Damit für den Parameter alternativ auch ein Lambda-Ausdruck verwendet werden kann, muss der erwartete Parameter vom Typ her ein \"funktionales Interface\" (s.u.) sein!\nDemo: nested.DemoLambda Syntax für Lambdas (Studi o1, Studi o2) -\u003e o1.getCredits() - o2.getCredits() Ein Lambda-Ausdruck ist eine Funktion ohne Namen und besteht aus drei Teilen:\nParameterliste (in runden Klammern), Pfeil Funktionskörper (rechte Seite) Falls es genau einen Parameter gibt, können die runden Klammern um den Parameter entfallen.\nDabei kann der Funktionskörper aus einem Ausdruck (\"expression\") bestehen oder einer Menge von Anweisungen (\"statements\"), die dann in geschweifte Klammern eingeschlossen werden müssen (Block mit Anweisungen).\nDer Wert des Ausdrucks ist zugleich der Rückgabewert des Lambda-Ausdrucks.\nVarianten:\n(parameters) -\u003e expression\n(parameters) -\u003e { statements; }\nQuiz: Welches sind keine gültigen Lambda-Ausdrücke? () -\u003e {} () -\u003e \"wuppie\" () -\u003e { return \"fluppie\"; } (Integer i) -\u003e return i + 42; (String s) -\u003e { \"foo\"; } (String s) -\u003e s.length() (Studi s) -\u003e s.getCredits() \u003e 300 (List\u003cStudi\u003e sl) -\u003e sl.isEmpty() (int x, int y) -\u003e { System.out.println(\"Erg: \"); System.out.println(x+y); } () -\u003e new Studi() s -\u003e s.getCps() \u003e 100 \u0026\u0026 s.getCps() \u003c 300 s -\u003e { return s.getCps() \u003e 100 \u0026\u0026 s.getCps() \u003c 300; } Show Me Auflösung:\n(4) und (5): return ist eine Anweisung, d.h. bei (4) fehlen die geschweiften Klammern. \"foo\" ist ein String und als solcher ein Ausdruck, d.h. hier sind die geschweiften Klammern zu viel (oder man ergänze den String mit einem return, also return \"foo\"; ...).\nDefinition \"Funktionales Interface\" (\"functional interfaces\") @FunctionalInterface public interface Wuppie\u003cT\u003e { int wuppie(T obj); boolean equals(Object obj); default int fluppie() { return 42; } } Wuppie\u003cT\u003e ist ein funktionales Interface (\"functional interface\") (seit Java 8)\nHat genau eine abstrakte Methode Hat evtl. weitere Default-Methoden Hat evtl. weitere abstrakte Methoden, die public Methoden von java.lang.Object überschreiben Die Annotation @FunctionalInterface selbst ist nur für den Compiler: Falls das Interface kein funktionales Interface ist, würde er beim Vorhandensein dieser Annotation einen Fehler werfen. Oder anders herum: Allein durch das Annotieren mit @FunctionalInterface wird aus einem Interface noch kein funktionales Interface! Vergleichbar mit @Override ...\nWährend man für eine anonyme Klasse lediglich ein \"normales\" Interface (oder eine Klasse) benötigt, braucht man für Lambda-Ausdrücke zwingend ein passendes funktionales Interface!\nAnmerkung: Es scheint keine einheitliche deutsche Übersetzung für den Begriff functional interface zu geben. Es wird häufig mit \"funktionales Interface\", manchmal aber auch mit \"Funktionsinterface\" übersetzt.\nDas in den obigen Beispielen eingesetzte Interface java.util.Comparator\u003cT\u003e ist also ein funktionales Interface: Es hat nur eine eigene abstrakte Methode int compare(T o1, T o2);.\nIm Package java.util.function sind einige wichtige funktionale Interfaces bereits vordefiniert, beispielsweise Predicate (Test, ob eine Bedingung erfüllt ist) und Function (verarbeite einen Wert und liefere einen passenden Ergebniswert). Diese kann man auch in eigenen Projekten nutzen!\nQuiz: Welches ist kein funktionales Interface? public interface Wuppie { int wuppie(int a); } public interface Fluppie extends Wuppie { int wuppie(double a); } public interface Foo { } public interface Bar extends Wuppie { default int bar() { return 42; } } Show Me Auflösung:\nWuppie hat genau eine abstrakte Methode =\u003e funktionales Interface Fluppie hat zwei abstrakte Methoden =\u003e kein funktionales Interface Foo hat gar keine abstrakte Methode =\u003e kein funktionales Interface Bar hat genau eine abstrakte Methode (und eine Default-Methode) =\u003e funktionales Interface Lambdas und funktionale Interfaces: Typprüfung interface java.util.Comparator\u003cT\u003e { int compare(T o1, T o2); // abstrakte Methode } // Verwendung ohne weitere Typinferenz Comparator\u003cStudi\u003e c1 = (Studi o1, Studi o2) -\u003e o1.getCredits() - o2.getCredits(); // Verwendung mit Typinferenz Comparator\u003cStudi\u003e c2 = (o1, o2) -\u003e o1.getCredits() - o2.getCredits(); Der Compiler prüft in etwa folgende Schritte, wenn er über einen Lambda-Ausdruck stolpert:\nIn welchem Kontext habe ich den Lambda-Ausdruck gesehen? OK, der Zieltyp ist hier Comparator\u003cStudi\u003e. Wie lautet die eine abstrakte Methode im Comparator\u003cT\u003e-Interface? OK, das ist int compare(T o1, T o2); Da T hier an Studi gebunden ist, muss der Lambda-Ausdruck der Methode int compare(Studi o1, Studi o2); entsprechen: 2x Studi als Parameter und als Ergebnis ein int Ergebnis: a) Cool, passt zum Lambda-Ausdruck c1. Fertig. b) D.h. in c2 müssen o1 und o2 vom Typ Studi sein. Cool, passt zum Lambda-Ausdruck c2. Fertig. Wrap-Up Anonyme Klassen: \"Wegwerf\"-Innere Klassen\nMüssen Interface implementieren oder Klasse erweitern Java8: Lambda-Ausdrücke statt anonymer Klassen (funktionales Interface nötig)\nZwei mögliche Formen: Form 1: (parameters) -\u003e expression Form 2: (parameters) -\u003e { statements; } Im jeweiligen Kontext muss ein funktionales Interface verwendet werden, d.h. ein Interface mit genau einer abstrakten Methode Der Lambda-Ausdruck muss von der Signatur her dieser einen abstrakten Methode entsprechen",
    "description": "Problem: Sortieren einer Studi-Liste List\u003cStudi\u003e sl = new ArrayList\u003c\u003e(); // Liste sortieren? sl.sort(???); // Parameter: java.util.Comparator\u003cStudi\u003e public class MyCompare implements Comparator\u003cStudi\u003e { @Override public int compare(Studi o1, Studi o2) { return o1.getCredits() - o2.getCredits(); } } // Liste sortieren? MyCompare mc = new MyCompare(); sl.sort(mc); Da Comparator\u003cT\u003e ein Interface ist, muss man eine extra Klasse anlegen, die die abstrakte Methode aus dem Interface implementiert und ein Objekt von dieser Klasse erzeugen und dieses dann der sort()-Methode übergeben.",
    "tags": [],
    "title": "Lambda-Ausdrücke und funktionale Interfaces",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/modern-java/lambdas.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024)",
    "content": "Javadoc Logging Code Smells Coding Conventions und Metriken Refactoring",
    "description": "Javadoc Logging Code Smells Coding Conventions und Metriken Refactoring",
    "tags": [],
    "title": "Programmiermethoden und Clean Code",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/coding.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Coding",
    "content": "Dokumentation mit Javadoc /** * Beschreibung Beschreibung (Summary). * * \u003cp\u003eHier kommt dann ein laengerer Text, der die Dinge * bei Bedarf etwas ausfuehrlicher erklaert. */ public void wuppie() {} Javadoc-Kommentare sind (aus Java-Sicht) normale Block-Kommentare, wobei der Beginn mit /** eingeleitet wird. Dieser Beginn ist für das Tool javadoc (Bestandteil des JDK, genau wie java und javac) das Signal, dass hier ein Kommentar anfängt, den das Tool in eine HTML-Dokumentation übersetzen soll.\nTypischerweise wird am Anfang jeder Kommentarzeile ein * eingefügt; dieser wird von Javadoc ignoriert.\nSie können neben normalem Text und speziellen Annotationen auch HTML-Elemente wie \u003cp\u003e und \u003ccode\u003e oder \u003cul\u003e nutzen.\nMit javadoc *.java können Sie in der Konsole aus den Java-Dateien die Dokumentation generieren lassen. Oder Sie geben das in Ihrer IDE in Auftrag ... (die dann diesen Aufruf gern für Sie tätigt).\nStandard-Aufbau /** * Beschreibung Beschreibung (Summary). * * \u003cp\u003e Hier kommt dann ein laengerer Text, der die Dinge * bei Bedarf etwas ausfuehrlicher erklaert. * * @param date Tag, Wert zw. 1 .. 31 * @return Anzahl der Sekunden seit 1.1.1970 * @throws NumberFormatException * @deprecated As of JDK version 1.1 */ public int setDate(int date) { setField(Calendar.DATE, date); } Erste Zeile bei Methoden/Attributen geht in die generierte \"Summary\" in der Übersicht, der Rest in die \"Details\" Die \"Summary\" sollte kein kompletter Satz sein, wird aber wie ein Satz geschrieben (Groß beginnen, mit Punkt beenden). Es sollte nicht beginnen mit \"Diese Methode macht ...\" oder \"Diese Klasse ist ...\". Ein gutes Beispiel wäre \"Berechnet die Steuerrückerstattung.\" Danach kommen die Details, die in der generierten Dokumentation erst durch Aufklappen der Elemente sichtbar sind. Erklären Sie, wieso der Code was machen soll und welche Designentscheidungen getroffen wurden (und warum). Leerzeilen gliedern den Text in Absätze. Neue Absätze werden mit einem \u003cp\u003e eingeleitet. (Ausnahmen: Wenn der Text mit \u003cul\u003e o.ä. beginnt oder der Absatz mit den Block-Tags.) Die \"Block-Tags\" @param, @return, @throws, @deprecated werden durch einen Absatz von der restlichen Beschreibung getrennt und tauchen in exakt dieser Reihenfolge auf. Die Beschreibung dieser Tags ist nicht leer - anderenfalls lässt man das Tag weg. Falls die Zeile für die Beschreibung nicht reicht, wird umgebrochen und die Folgezeile mit vier Leerzeichen (beginnend mit dem @) eingerückt. Mit @param erklären Sie die Bedeutung eines Parameters (von links nach rechts) einer Methode. Beispiel: @param date Tag, Wert zw. 1 .. 31. Wiederholen Sie dies für jeden Parameter. Mit @return beschreiben Sie den Rückgabetyp/-wert. Beispiel: @return Anzahl der Sekunden seit 1.1.1970. Bei Rückgabe von void wird diese Beschreibung weggelassen (die Beschreibung wäre dann ja leer). Mit @throws geben Sie an, welche \"checked\" Exceptions die Methode wirft. Mit @deprecated können Sie im Kommentar sagen, dass ein Element veraltet ist und möglicherweise mit der nächsten Version o.ä. entfernt wird. (siehe nächste Folie) =\u003e Dies sind die Basis-Regeln aus dem populären Google-Java-Style [googlestyleguide].\nVeraltete Elemente /** * Beschreibung Beschreibung Beschreibung. * * @deprecated As of v102, replaced by \u003ccode\u003eFoo.fluppie()\u003c/code\u003e. */ @Deprecated public void wuppie() {} Annotation zum Markieren als \"veraltet\" (in der generierten Dokumentation): @deprecated Für Sichtbarkeit zur Laufzeit bzw. im Tooling/IDE: normale Code-Annotation @Deprecated Dies ist ein guter Weg, um Elemente einer öffentlichen API als \"veraltet\" zu kennzeichnen. Üblicherweise wird diese Kennzeichnung für einige wenige Releases beibehalten und danach das veraltete Element aus der API entfernt.\nAutoren, Versionen, ... /** * Beschreibung Beschreibung Beschreibung. * * @author Dagobert Duck * @version V1 * @since schon immer */ Annotationen für Autoren und Version: @author, @version, @since Diese Annotationen finden Sie vor allem in Kommentaren zu Packages oder Klassen.\nWas muss kommentiert werden? Alle public Klassen\nAlle public und protected Elemente der Klassen\nAusnahme: @Override (An diesen Methoden kann, aber muss nicht kommentiert werden.)\nAlle anderen Elemente bei Bedarf mit normalen Kommentaren versehen.\nBeispiel aus dem JDK: ArrayList Schauen Sie sich gern mal Klassen aus der Java-API an, beispielsweise eine java.util.ArrayList:\nGenerierte Dokumentation: zu \"ArrayList\" runterscrollen bzw. direkt Quellcode: ArrayList.java Best Practices: Was beschreibe ich eigentlich? Unter Documentation Best Practices finden Sie eine sehr gute Beschreibung, was das Ziel der Dokumentation sein sollte. Versuchen Sie, dieses zu erreichen!\nWrap-Up Javadoc-Kommentare sind normale Block-Kommentare beginnend mit /**\nGenerierung der HTML-Dokumentation mit javadoc *.java\nErste Zeile ist eine Zusammenfassung (fast immer sichtbar)\nLängerer Text danach als \"Description\" einer Methode/Klasse\nAnnotationen für besondere Elemente: @param, @return, @throws, @deprecated\nFaustregel: Alle public und protected Elemente mit Javadoc kommentieren!",
    "description": "Dokumentation mit Javadoc /** * Beschreibung Beschreibung (Summary). * * \u003cp\u003eHier kommt dann ein laengerer Text, der die Dinge * bei Bedarf etwas ausfuehrlicher erklaert. */ public void wuppie() {} Javadoc-Kommentare sind (aus Java-Sicht) normale Block-Kommentare, wobei der Beginn mit /** eingeleitet wird. Dieser Beginn ist für das Tool javadoc (Bestandteil des JDK, genau wie java und javac) das Signal, dass hier ein Kommentar anfängt, den das Tool in eine HTML-Dokumentation übersetzen soll.",
    "tags": [],
    "title": "Javadoc",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/coding/javadoc.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Praktikum",
    "content": "Dieses Blatt ist bewusst einfach gestaltet und dient zum Teil der Wiederholung Ihrer Kenntnisse aus der LV \"Programmieren 1\".\nA02.1: Gradle (15%) Folgen Sie der Anleitung auf gradle.org und installieren Sie Gradle auf Ihrem Rechner. Legen Sie in der Konsole ein neues Gradle-Projekt für eine Java-Applikation an (ohne IDE!). Das Build-Script soll in Groovy erzeugt und als Test-API soll JUnit4 verwendet werden.\nWie finden Sie auf der Konsole heraus, welche Tasks es gibt? Erklären Sie das Projektlayout, d.h. wo kommen beispielsweise die Java-Dateien hin?\nErklären Sie, in welche Abschnitte das generierte Buildskript unterteilt ist und welche Aufgaben diese Abschnitte jeweils erfüllen. Gehen Sie dabei im Detail auf das Plugin application und die dort bereitgestellten Tasks und deren Abhängigkeiten untereinander ein.\nÖffnen Sie das Projekt in Ihrer IDE. Wie können Sie hier die verschiedenen Tasks ansteuern?\nMachen Sie sich Notizen, welche Sie im Praktikum nutzen dürfen, um dort das Buildskript zu erklären.\nZoo Sie finden in den Vorgaben im Package zoo einige Interfaces und Klassen, mit denen man einen Zoo modellieren kann.\nLaden Sie sich die Vorgaben im Browser von GitHub herunter1, entpacken Sie das Zip-File und laden Sie den Ordner als Gradle-Projekt in Ihre IDE.\nA02.2: Nicht-generische Klassen (10%) Sie finden einige Interfaces, die das Interface Animal erweitern, beispielsweise Fish, Reptile, Cat, ...\nErstellen Sie für jedes dieser Interfaces jeweils zwei Java-Klassen, die konkrete Mitglieder der jeweiligen Tier-Klasse bzw. -Familie2 repräsentieren und die jeweils das Interface implementieren. Beispielsweise könnte eine Forelle eine Art in der Klasse der Fische sein, d.h. die Java-Klasse Trout könnte das Interface Fish implementieren.\nDiese Java-Klassen sollen nicht-generisch sein. Die move()-Methode soll einfach einen String auf der Konsole ausgeben, wie sich dieses Tier bewegen würde. Mit der getName()-Methode soll ein kurzer Name, beispielsweise der Tierklasse, zurückgegeben werden.\nHinweis: Die mit default markierten Methoden in Fish, Mammal und Reptile brauchen Sie in Ihren Klassen nicht implementieren. Wir werden später im Semester noch über die sogenannten “Default-Methoden” sprechen.\nA02.3: Generische Klassen (15%) Um Gehege zu modellieren, erstellen Sie in eine generische Klasse Habitat mit einer Typ-Variablen. Stellen Sie durch geeignete Beschränkung der Typ-Variablen sicher, dass nur Gehege mit von Animal abgeleiteten Typen gebildet werden können.\nEs sollen (mindestens) folgende Methoden existieren:\nvoid add(Animal animal) zur Aufnahme eines Tieres in das Gehege void remove(Animal animal) um ein Tier aus einem Gehege zu entfernen String getName() um den Namen des Geheges zu bestimmen Hinweis: Der Parametertyp Animal in den Methoden muss entsprechend angepasst werden.\nJedes einzelne Tier im Gehege kann maximal einmal vorkommen. Begründen Sie die Wahl der Datenstruktur.\nLegen Sie in Ihrer main()-Methode mindestens zwei konkrete Gehege als Instanzen der neuen generischen Klasse Habitat an. Dabei sollen in diesen konkreten Gehegen nur jeweils verschiedene Tiere einer \"Art\" (beispielweise Löwen, Hamster, ...) vorkommen. Fügen Sie einige passende Tiere in die beiden Gehege ein.\nA02.4: Generische Klassen reloaded (30%) Für die Repräsentation eines Zoologischen Gartens mit mehreren verschiedenen Gehegen erstellen Sie nun eine generische Klasse Zoo mit einer Typ-Variablen. Stellen Sie durch geeignete Beschränkung der Typ-Variablen sicher, dass nur Zoos mit von Habitat abgeleiteten Typen gebildet werden können.\nEin Zoo soll (mindestens) folgende Methoden besitzen:\nvoid build(Habitat habitat) zur Aufnahme eines neuen Geheges in den Zoo void abandon(Habitat habitat) um ein Gehege aus dem Zoo zu entfernen void visitAllHabitats() um die Gehege in der Reihenfolge des Hinzufügens zu besuchen (d.h. ihren Namen auf der Konsole auszugeben) Hinweis: Der Parametertyp Habitat in den Methoden muss entsprechend angepasst werden.\nJedes Gehege gibt es pro Zoo nur maximal einmal, und die Reihenfolge des Errichtens definiert eine Ordnung auf den Gehegen. Begründen Sie die Wahl der Datenstruktur.\nLegen Sie in Ihrer main()-Methode einen konkreten Zoo als Instanz der neuen generischen Klasse Zoo an. Dieser Zoo soll einige Gehege für verschiedene Tiere beinhalten.\nA02.5: Ableiten nicht-generischer Klassen (20%) Leiten Sie von Zoo eine nicht-generische Klasse Aquarium ab. Aquarien können nur mit Gehegen angelegt werden, deren Tiere vom Typ Fish (oder abgeleitet) sind.\nLegen Sie in Ihrer main()-Methode ein konkretes Aquarium als Instanz der neuen nicht-generischen Klasse Aquarium an und gruppieren Sie darin verschiedene Fisch-\"Gehege\".\nA02.6: DevDungeon (10%) Klonen Sie das Projekt DevDungeon und laden Sie es in Ihrer IDE als Gradle-Projekt. Betrachten Sie das Sub-Projekt \"devDungeon\". Dies ist ein von einem Studierenden (@Flamtky) erstelltes Spiel mit mehreren Leveln, in denen Sie spielerisch verschiedene Aufgaben in-game und ex-game lösen müssen.\nStarten Sie den DevDungeon mit ./gradlew devDungeon:runDevDungeon. Spielen Sie sich für diese Aufgabe durch das erste Level (Intro-Level) und machen Sie sich mit der Spielmechanik vertraut. Sie bekommen in jedem relevanten Übergang passende Hinweise; allgemein können Sie sich auch die kurze Anleitung \"How to play\" anschauen.\nWICHTIG: Achten Sie bitte darauf, dass im Projektpfad keine Leerzeichen und keine Sonderzeichen (Umlaute o.ä.) vorkommen! Dies kann zu seltsamen Fehler führen. Bitte auch darauf achten, dass Sie als JDK ein Java SE 21 (LTS) verwenden.\nerst auf Code klicken und dann auf Download ZIP ↩︎\nOk, wir machen hier Informatik. Vermutlich ist die Biologie nicht ganz korrekt ;-) ↩︎",
    "description": "Dieses Blatt ist bewusst einfach gestaltet und dient zum Teil der Wiederholung Ihrer Kenntnisse aus der LV \"Programmieren 1\".\nA02.1: Gradle (15%) Folgen Sie der Anleitung auf gradle.org und installieren Sie Gradle auf Ihrem Rechner. Legen Sie in der Konsole ein neues Gradle-Projekt für eine Java-Applikation an (ohne IDE!). Das Build-Script soll in Groovy erzeugt und als Test-API soll JUnit4 verwendet werden.\nWie finden Sie auf der Konsole heraus, welche Tasks es gibt? Erklären Sie das Projektlayout, d.h. wo kommen beispielsweise die Java-Dateien hin?",
    "tags": [],
    "title": "Blatt 02: Zoo (Generics, Collections, Gradle)",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/homework/b02.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Praktikum",
    "content": "Git A03.1: Git Status erklären (15%) Betrachten Sie die folgende Ausgabe von git status in einer lokalen Workingcopy (Arbeitskopie):\npm-lecture % git status On branch b03 Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git restore \u003cfile\u003e...\" to discard changes in working directory) modified: CONTRIBUTING.md modified: homework/b03.md Untracked files: (use \"git add \u003cfile\u003e...\" to include in what will be committed) foo.java no changes added to commit (use \"git add\" and/or \"git commit -a\") Erklären Sie die Ausgabe.\nGeben Sie eine Befehlssequenz an, mit der Sie nur die Änderungen in foo.java committen können.\nA03.2: Git-Spiel (55%) (Verteilung: 15%, 10%, 10%, 10%, 10%)\nKlonen Sie die Vorgaben \"Git-Quest\". Sie finden die Geschichte des Helden Markus im Dungeon.1\nÖffnen Sie eine Konsole und beantworten Sie mit Hilfe der Befehle git checkout, git log und git show sowie git diff folgende Fragen:\nWas passierte an tag 01? Wann hat der Held zum ersten Mal 4 experience Punkte? Wann hat der Held zum ersten Mal 10 hunger Punkte? Wie viele Heiltränke hat der Held insgesamt in seinem Rucksack gehabt? Was hat der Held im Shop gekauft? Und wie viel Gold hat er dafür bezahlt? Was passierte zwischen Tag 03 und Tag 04, d.h. was änderte sich zwischen diesen Commits? Hat der Held etwas gegessen? Falls ja, was und wann? Beim letzten Commit (Tag 04.5) ist etwas schief gelaufen, es wurden versehentlich zu wenig experience Punkte eingestellt. Ändern Sie diesen letzten Commit und passen Sie die experience Punkte auf 42 an.\nSchreiben Sie die Geschichte in der Datei questlog.md fort und erzeugen Sie einen neuen Commit für Tag 04.6. Ändern Sie bitte hierzu nur die eine Datei questlog.md.\nSchreiben Sie die Geschichte noch weiter fort (Tag 04.7), aber ändern Sie diesmal mehrere Dateien, die an diesem Tag (neuer Commit) gemeinsam eingecheckt werden sollen.\nFälschlicherweise wurden die Statuspunkte und die Ausrüstung bisher gemeinsam in der Datei stats.md geführt. Korrigieren Sie das und verschieben Sie die Ausrüstungsgegenstände aus der Datei stats.md in eine neue Datei gear.md. Checken Sie Ihre Änderungen als Tag 04.8 (neuer Commit) gemeinsam ein. (Hinweis: Es reicht, wenn diese Änderung als letzter Commit auf der Spitze des master-Branches existiert. Sie brauchen/sollen die Trennung von Statuspunkten und Ausrüstung nicht rückwirkend in die Historie einbauen!)\nDemonstrieren Sie Ihr Vorgehen im Praktikum jeweils live.\nA03.3: Commit-Meldungen (20%) Gute Commit-Meldungen schreiben erfordert Übung. Schauen Sie sich die beiden Commits Dungeon-CampusMinden/Dungeon/commit/46530b6 und Dungeon-CampusMinden/Dungeon/commit/3e37472 an.\nDiskutieren Sie jeweils, was Ihnen an den Commits auffällt: Was gefällt Ihnen, was stört Sie? Schlagen Sie Verbesserungen vor.\nLambda-Ausdrücke A03.4: Dojo-Dungeon: Der Vergessene Wald (10%) Klonen Sie das Projekt Dungeon und laden Sie es in Ihrer IDE als Gradle-Projekt. Betrachten Sie das Sub-Projekt \"dojo-dungeon\". Dies ist ein von den Tutoren2 erstelltes kleines Spiel mit vier Leveln, in denen Sie spielerisch Aufgaben lösen sollen - auf diesem Aufgabenblatt ist nur das erste Level relevant.\nStarten Sie den Dojo-Dungeon mit ./gradlew dojo-dungeon:runDojoDungeon. Spielen Sie sich für diese Aufgabe durch das erste Level (\"Der Vergessene Wald\"). Sie werden drei Räume finden: Im ersten Raum müssen Sie die Monster besiegen - eines wird Ihnen dabei einen Schlüssel geben. Heben Sie diesen auf, nur damit öffnet sich die Tür zum zweiten Raum. Dort bekommen Sie eine Quest: Sie sollen im Asset-Ordner vom \"dojo-dungeon\"-Sub-Projekt eine Java-Datei korrigieren. Tun Sie dies und folgen Sie den Anweisungen. Ist die Aufgabe erfolgreich gelöst, gelangen Sie in den dritten Raum. Hier werden Ihnen Fragen zu Lambda-Ausdrücken gestellt, die Sie bitte beantworten. Danach steht Ihnen das nächste Level offen, aber das brauchen Sie für diese Aufgabe (noch) nicht zu lösen.\nDas Spiel wird über die Tastatur bedient, die kurze Anleitung \"How to play\" erklärt die einzelnen Tasten.\nMachen Sie Screenshots der Fragen und Ihrer Antworten für die Vorstellung im Praktikum. Zeigen und erklären Sie die Korrekturen an der Java-Datei.\nWICHTIG: Achten Sie bitte darauf, dass im Projektpfad keine Leerzeichen und keine Sonderzeichen (Umlaute o.ä.) vorkommen! Dies kann zu seltsamen Fehler führen. Bitte auch darauf achten, dass Sie als JDK ein Java SE 21 (LTS) verwenden.\nFür alle, die schon mit Branches umgehen können: Betrachten Sie auf diesem Blatt bitte nur den Branch master. ↩︎\nDer Dank für den \"dojo-dungeon\" geht an @Denniso3, @tgrothe und @JudiTeller. ↩︎",
    "description": "Git A03.1: Git Status erklären (15%) Betrachten Sie die folgende Ausgabe von git status in einer lokalen Workingcopy (Arbeitskopie):\npm-lecture % git status On branch b03 Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git restore \u003cfile\u003e...\" to discard changes in working directory) modified: CONTRIBUTING.md modified: homework/b03.md Untracked files: (use \"git add \u003cfile\u003e...\" to include in what will be committed) foo.java no changes added to commit (use \"git add\" and/or \"git commit -a\") Erklären Sie die Ausgabe.",
    "tags": [],
    "title": "Blatt 03: Git-Quest und Dojo-Dungeon (Git Basics, Lambda-Ausdrücke)",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/homework/b03.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Git",
    "content": "Neues Feature entwickeln/ausprobieren A---B---C master Bisher nur lineare Entwicklung: Commits bauen aufeinander auf (lineare Folge von Commits) master ist der (Default-) Hauptentwicklungszweig Pointer auf letzten Commit Default-Name: \"master\" (muss aber nicht so sein bzw. kann geändert werden) Anmerkung: Git und auch Github haben den Namen für den Default-Branch von master auf maingeändert. Der Name an sich ist aber für Git bedeutungslos und kann mittels git config --global init.defaultBranch \u003cname\u003e geändert werden. In Github hat der Default-Branch eine gewisse Bedeutung, beispielsweise ist der Default-Branch das automatische Ziel beim Anlegen von Pull-Requests. In Github kann man den Default-Namen global in den User-Einstellungen (Abschnitt \"Repositories\") und für jedes einzelne Repository in den Repo-Einstellungen (Abschnitt \"Branches\") ändern.\nEntwicklung des neuen Features soll stabilen master-Branch nicht beeinflussen =\u003e Eigenen Entwicklungszweig für die Entwicklung des Features anlegen:\nNeuen Branch erstellen: git branch wuppie Neuen Branch auschecken: git checkout wuppie oder git switch wuppie Alternativ: git checkout -b wuppie oder git switch -c wuppie (neuer Branch und auschecken in einem Schritt)\nA---B---C master, wuppie Startpunkt: prinzipiell beliebig (jeder Commit in der Historie möglich).\nDie gezeigten Beispiel zweigen den neuen Branch direkt vom aktuell ausgecheckten Commit/Branch ab. Also aufpassen, was gerade in der Workingcopy los ist!\nAlternativ nutzen Sie die Langform: git branch wuppie master (mit master als Startpunkt; hier kann jeder beliebige Branch, Tag oder Commit genutzt werden).\nNach Anlegen des neuen Branches zeigen beide Pointer auf den selben Commit.\nAnmerkung: In neueren Git-Versionen wurde der Befehl \"switch\" eingeführt, mit dem Sie in der Workingcopy auf einen anderen Branch wechseln können. Der bisherige Befehl \"checkout\" funktioniert aber weiterhin.\nArbeiten im Entwicklungszweig ... D wuppie / A---B---C master Entwicklung des neuen Features erfolgt im eigenen Branch: beeinflusst den stabilen master-Branch nicht Wenn in der Workingcopy der Feature-Branch ausgecheckt ist, gehen die Commits in den Feature-Branch; der master bleibt auf dem alten Stand Wenn der master ausgecheckt wäre, würden die Änderungen in den master gehen, d.h. der master würde sich ab Commit C parallel zu wuppie entwickeln Problem: Fehler im ausgelieferten Produkt D wuppie / A---B---C master Fix für master nötig:\ngit checkout master git checkout -b fix Änderungen in fix vornehmen ... Das führt zu dieser Situation:\nD wuppie / A---B---C master \\ E fix git checkout \u003cbranchname\u003e holt den aktuellen Stand des jeweiligen Branches in die Workingcopy. (Das geht in neueren Git-Versionen auch mit git switch \u003cbranchname\u003e.)\nMan kann weitere Branches anlegen, d.h. hier im Beispiel ein neuer Feature-Branch fix, der auf dem master basiert. Analog könnte man auch Branches auf der Basis von wuppie anlegen ...\nFix ist stabil: Integration in master D wuppie / A---B---C master \\ E fix git checkout master git merge fix =\u003e fast forward von master git branch -d fix Der letzte Schritt entfernt den Branch fix.\nD wuppie / A---B---C---E master Allgemein: git merge \u003cbranchname\u003e führt die Änderungen im angegebenen Branch \u003cbranchname\u003e in den aktuell in der Workingcopy ausgecheckten Branch ein. Daraus resultiert für den aktuell ausgecheckten Branch ein neuer Commit, der Branch \u003cbranchname\u003e bleibt dagegen auf seinem bisherigen Stand.\nBeispiel:\nDie Workingcopy ist auf A git merge B führt A und B zusammen: B wird in A gemergt Wichtig: Der Merge-Commit (sofern nötig) findet hierbei in A statt! In der Abbildung ist A der master und B der fix.\nNach dem Merge existieren beide Branches weiter (sofern sie nicht explizit gelöscht werden)\nHier im Beispiel findet ein sogenannter \"Fast forward\" statt.\n\"Fast forward\" ist ein günstiger Spezialfall beim Merge: Beide Branches liegen in einer direkten Kette, d.h. der Zielbranch kann einfach \"weitergeschaltet\" werden. Ein Merge-Commit ist in diesem Fall nicht notwendig und wird auch nicht angelegt.\nFeature weiter entwickeln ... D---F wuppie / A---B---C---E master git switch wuppie Weitere Änderungen im Branch wuppie ... git switch \u003cbranchname\u003e holt den aktuellen Stand des jeweiligen Branches in die Workingcopy. Man kann also jederzeit in der Workingcopy die Branches wechseln und entsprechend weiterarbeiten.\nHinweis: Während der neue git switch-Befehl nur Branches umschalten kann, funktioniert git checkout sowohl mit Branchnamen und Dateinamen - damit kann man also auch eine andere Version einer Datei in der Workingcopy \"auschecken\". Falls gleiche Branch- und Dateinamen existieren, muss man für das Auschecken einer Datei noch \"--\" nutzen: git checkout -- \u003cdateiname\u003e.\nFeature ist stabil: Integration in master D---F wuppie D---F wuppie / =\u003e / \\ A---B---C---E master A---B---C---E---G master git checkout master git merge wuppie =\u003e Kein fast forward möglich: Git sucht nach gemeinsamen Vorgänger Hier im Beispiel ist der Standardfall beim Mergen dargestellt: Die beiden Branches liegen nicht in einer direkten Kette von Commits, d.h. hier wurde parallel weitergearbeitet.\nGit sucht in diesem Fall nach dem gemeinsamen Vorgänger beider Branches und führt die jeweiligen Änderungen (Differenzen) seit diesem Vorgänger in einem Merge-Commit zusammen.\nIm master entsteht ein neuer Commit, da kein fast forward beim Zusammenführen der Branches möglich!\nAnmerkung: git checkout wuppie; git merge master würde den master in den wuppie mergen, d.h. der Merge-Commit wäre dann in wuppie.\nBeachten Sie dabei die \"Merge-Richtung\":\nDie Workingcopy ist auf A git merge B führt A und B zusammen: B wird in A gemergt Wichtig: Der Merge-Commit (sofern nötig) findet hierbei in A statt! In der Abbildung ist A der master und B der wuppie.\nAchtung: Richtung beachten! git checkout A; git merge B führt beide Branches zusammen, genauer: führt die Änderungen von B in A ein, d.h. der entsprechende Merge-Commit ist in A!\nKonflikte beim Mergen (Parallele) Änderungen an selber Stelle =\u003e Merge-Konflikte\n$ git merge wuppie Auto-merging hero.java CONFLICT (content): Merge conflict in hero.java Automatic merge failed; fix conflicts and then commit the result. Git fügt Konflikt-Marker in die Datei ein:\n\u003c\u003c\u003c\u003c\u003c\u003c\u003c HEAD:hero.java public void getActiveAnimation() { return null; ======= public Animation getActiveAnimation() { return this.idleAnimation; \u003e\u003e\u003e\u003e\u003e\u003e\u003e wuppie:hero.java Der Teil mit HEAD ist aus dem aktuellen Branch in der Workingcopy Der Teil aus dem zu mergenden Branch ist unter wuppie notiert Das ======= trennt beide Bereiche Merge-Konflikte auflösen Manuelles Editieren nötig (Auflösung des Konflikts):\nEntfernen der Marker Hinzufügen der Datei zum Index Analog für restliche Dateien mit Konflikt Commit zum Abschließen des Merge-Vorgangs Alternativ: Nutzung graphischer Oberflächen mittels git mergetool\nKonsole: Branchen und Mergen Rebasen: Verschieben von Branches D---F wuppie D---F wuppie / =\u003e / \\ A---B---C---E master A---B---C---E---G master Bisher haben wir Branches durch Mergen zusammengeführt. Dabei entsteht in der Regel ein extra Merge-Commit (im Beispiel G), außer es handelt sich um ein fast forward. Außerdem erkennt man in der Historie sehr gut, dass hier in einem separaten Branch gearbeitet wurde, der irgendwann in den master gemergt wurde.\nLeider wird dieses Vorgehen in großen Projekten recht schnell sehr unübersichtlich. Außerdem werden Merges in der Regeln nur von besonders berechtigten Personen (Manager) durchgeführt, die im Falle von Merge-Konflikten diese dann selbst auflösen müssten (ohne aber die fachliche Befähigung zu haben). Hier greift man dann häufig zur Alternative Rebase. Dabei wird der Ursprung eines Branches auf einen bestimmten Commit verschoben. Im Anschluss ist dann ein Merge mit fast forward, also ohne die typischen rautenförmigen Ketten in der Historie und ohne extra Merge-Commit möglich. Dies kann aber auch als Nachteil gesehen werden, da man in der Historie den früheren Branch nicht mehr erkennt! Ein weiterer schwerwiegender Nachteil ist, dass alle Commits im verschobenen Branch umgeschrieben werden und damit neue Commit-IDs bekommen. Das verursacht bei der Zusammenarbeit in Projekten massive Probleme! Als Vorteil gilt, dass man mögliche Merge-Konflikte bereits beim Rebasen auflösen muss, d.h. hier muss derjenige, der den Merge \"beantragt\", durch einen vorherigen Rebase den konfliktfreien Merge sicherstellen. Mehr dazu in “Branching-Strategien” und “Workflows”.\ngit rebase master wuppie führt zu\nD'---F' wuppie / A---B---C---E master Nach dem Rebase von wuppie auf master sieht es so aus, als ob der Branch wuppie eben erst vom master abgezweigt wurde. Damit ist dann ein fast forward Merge von wuppie in den master möglich, d.h. es gibt keine Raute und auch keinen extra Merge-Commit (hier nicht gezeigt).\nMan beachte aber die Änderung der Commit-IDs von wuppie: Aus D wird D'! (Datum, Ersteller und Message bleiben aber erhalten.)\nDon't lose your HEAD Branches sind wie Zeiger auf letzten Stand (Commit) eines Zweiges\nHEAD: Spezieller Pointer\nZeigt auf den aktuellen Branch der Workingcopy Früheren Commit auschecken (ohne Branch): \"headless state\"\nWorkingcopy ist auf früherem Commit\nKein Branch =\u003e Änderungen gehen verloren!\nEventuelle Änderungen würden ganz normal als Commits auf dem HEAD-Branch aufgezeichnet. Sobald man aber einen anderen Branch auscheckt, wird der HEAD auf diesen anderen Branch gesetzt, so dass die eben gemachten Commits \"in der Luft hängen\". Sofern man die SHA's kennt, kommt man noch auf die Commits zurück. Allerdings laufen von Zeit zu Zeit interne Aufräum-Aktionen, so dass die Chance gut steht, dass die \"kopflosen\" Commits irgendwann tatsächlich verschwinden.\nWrap-Up Anlegen von Branches mit git branch Umschalten der Workingcopy auf anderen Branch: git checkout oder git switch Mergen von Branches und Auflösen von Konflikten: git merge Verschieben von Branches mit git rebase",
    "description": "Neues Feature entwickeln/ausprobieren A---B---C master Bisher nur lineare Entwicklung: Commits bauen aufeinander auf (lineare Folge von Commits) master ist der (Default-) Hauptentwicklungszweig Pointer auf letzten Commit Default-Name: \"master\" (muss aber nicht so sein bzw. kann geändert werden) Anmerkung: Git und auch Github haben den Namen für den Default-Branch von master auf maingeändert. Der Name an sich ist aber für Git bedeutungslos und kann mittels git config --global init.defaultBranch \u003cname\u003e geändert werden. In Github hat der Default-Branch eine gewisse Bedeutung, beispielsweise ist der Default-Branch das automatische Ziel beim Anlegen von Pull-Requests. In Github kann man den Default-Namen global in den User-Einstellungen (Abschnitt \"Repositories\") und für jedes einzelne Repository in den Repo-Einstellungen (Abschnitt \"Branches\") ändern.",
    "tags": [],
    "title": "Git Branches: Features unabhängig entwickeln und mit Git verwalten",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/git/branches.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Git",
    "content": "Nutzung von Git in Projekten: Verteiltes Git (und Workflows) Git ermöglicht ein einfaches und schnelles Branchen. Dies kann man mit entsprechenden Branching-Strategien sinnvoll für die SW-Entwicklung einsetzen.\nIm Folgenden sollen also die Frage betrachtet werden: Wie setze ich Branches sinnvoll ein?\nUmgang mit Branches: Themen-Branches I---J---K wuppieV1 / D---F wuppie / A---B---C---E master \\ G---H test Branchen ist in Git sehr einfach und schnell. Deshalb wird (gerade auch im Vergleich mit SVN) gern und viel gebrancht.\nEin häufiges anzutreffendes Modell ist dabei die Nutzung von Themen-Branches: Man hat einen Hauptzweig (master). Wann immer eine neue Idee oder ein Baustein unabhängig entwickelt werden soll/kann, wird ein entsprechender Themen-Branch aufgemacht. Dabei handelt es sich normalerweise um kleine Einheiten!\nThemenbranches haben in der Regel eine kurze Lebensdauer: Wenn die Entwicklung abgeschlossen ist, wird die Idee bzw. der Baustein in den Hauptzweig integriert und der Themenbranch gelöscht.\nVorteil: Die Entwicklung im Themenbranch ist in sich gekapselt und stört nicht die Entwicklung in anderen Branches (und diese stören umgekehrt nicht die Entwicklung im Themenbranch).\nNachteil:\nMangelnder Überblick durch viele Branches Ursprung der Themenbranches muss überlegt gewählt werden, d.h. alle dort benötigten Features müssen zu dem Zeitpunkt im Hauptzweig vorhanden sein Umgang mit Branches: Langlaufende Branches A---B---D master \\ C---E---I develop \\ F---G---H topic Häufig findet man in (größeren) Projekten Branches, die über die gesamte Lebensdauer des Projekts existieren, sogenannte \"langlaufende Branches\".\nNormalerweise gibt es einen Branch, in dem stets der stabile Stand des Projekts enthalten ist. Dies ist häufig der master. In diesem Branch gibt es nur sehr wenige Commits: normalerweise nur Merges aus dem develop-Branch (etwa bei Fertigstellung einer Release-Version) und ggf. Fehlerbehebungen.\nDie aktive Entwicklung findet in einem separaten Branch statt: develop. Hier nutzt man zusätzlich Themen-Branches für die Entwicklung einzelner Features, die nach Fertigstellung in den develop gemergt werden.\nKleinere Projekte kommen meist mit den zwei langlaufenden Branches in der obigen Darstellung aus. Bei größeren Projekten finden sich häufig noch etliche weitere langlaufende Branches, beispielsweise \"Proposed Updates\" etc. beim Linux-Kernel.\nVorteile: Mehr Struktur im Projekt durch in ihrer Semantik wohldefinierte Branches Durch weniger Commits pro Branch lässt sich die Historie leichter verfolgen (u.a. auch aus bestimmter Rollen-Perspektive: Entwickler, Manager, ...) Nachteile: Bestimmte \"ausgezeichnete\" Branches; zusätzliche Regeln zum Umgang mit diesen beachten Komplexe Branching-Strategie: Git-Flow A---B---------------------G---J1 master \\ / \\ / \\ / X fix \\ / \\ C-------------F----I--J2 develop \\ / \\ / \\ / H1 featureB \\ / D1----D2 featureA \\ E1---E2---E3---E4---E5 featureC Das Git-Flow-Modell von Vincent Driessen (nvie.com/posts/a-successful-git-branching-model) zeigt einen in der Praxis überaus bewährten Umgang mit Branches. Lesen Sie an der angegebenen Stelle nach, besser kann man die Nutzung dieses eleganten Modells eigentlich nicht erklären :-)\nGit-Flow: Hauptzweige master und develop A---B-------E---------------J master \\ / / C---D---F---G---H---I---K develop Bei Git-Flow gibt es zwei langlaufende Branches: Den master, der immer den stabilen Stand enthält und in den nie ein direkter Commit gemacht wird, sowie den develop, wo letztlich (ggf. über Themenbranches) die eigentliche Entwicklung stattfindet.\nÄnderungen werden zunächst im develop erstellt und getestet. Wenn die Features stabil sind, erfolgt ein Merge von develop in den master. Hier kann noch der Umweg über einen release-Branch genommen werden: Als \"Feature-Freeze\" wird vom develop ein release-Branch abgezweigt. Darin wird das Release dann aufpoliert, d.h. es erfolgen nur noch kleinere Korrekturen und Änderungen, aber keine echte Entwicklungsarbeit mehr. Nach Fertigstellung wird der release dann sowohl in den master als auch develop gemergt.\nGit-Flow: Weitere Branches als Themen-Branches A---B---------------------I-------------K master \\ / / C------------F----H-------------J---L develop \\ / \\ / / \\ / G1 featureB / \\ / / D1---D2 featureA / \\ / E1---E2---E3---E4---E5 featureC Für die Entwicklung eigenständiger Features bietet es sich auch im Git-Flow an, vom develop entsprechende Themenbranches abzuzweigen und darin jeweils isoliert die Features zu entwickeln. Wenn diese Arbeiten eine gewisse Reife haben, werden die Featurebranches in den develop integriert.\nGit-Flow: Merging-Detail ---C--------E develop \\ / git merge --no-ff D1---D2 featureA vs.\n---C---D1---D2 develop git merge Wenn beim Mergen ein \"fast forward\" möglich ist, würde Git beim Mergen eines (Feature-) Branches in den develop (oder allgemein in einen anderen Branch) keinen separaten Commit erzeugen (Situation rechts in der Abbildung).\nDamit erscheint der develop-Branch wie eine lineare Folge von Commits. In manchen Projekten wird dies bevorzugt, weil die Historie sehr übersichtlich aussieht.\nAllerdings verliert man die Information, dass hier ein Feature entwickelt wurde und wann es in den develop integriert wurde (linke Seite in obiger Abbildung). Häufig wird deshalb ein extra Merge-Commit mit git merge --no-ff \u003cbranch\u003e (extra Schalter \"--no-ff\") erzwungen, obwohl ein \"fast forward\" möglich wäre.\nAnmerkung: Man kann natürlich auch über Konventionen in den Commit-Kommentaren eine gewisse Übersichtlichkeit erzwingen. Beispielsweise könnte man vereinbaren, dass alle Commit-Kommentare zu einem Feature \"A\" mit \"feature a:\" starten müssen.\nGit-Flow: Umgang mit Fehlerbehebung A---B---D--------F1 master \\ \\ / \\ E1---E2 fix \\ \\ C1-------F2 develop Wenn im stabilen Branch (also dem master) ein Problem bekannt wird, darf man es nicht einfach im master fixen. Stattdessen wird ein extra Branch vom master abgezweigt, in dem der Fix entwickelt wird. Nach Fertigstellung wird dieser Branch sowohl in den master als auch den develop gemergt, damit auch im Entwicklungszweig der Fehler behoben ist.\nDadurch entspricht jeder Commit im master einem Release.\nVereinfachte Braching-Strategie: GitHub Flow A---B---C----D-----------E master \\ \\ / / \\ ta1 topicA / \\ / tb1---tb2---tb3 topicB Github verfolgt eine deutlich vereinfachte Strategie: \"GitHub Flow\" (vgl. \"GitHub Flow\" (S. Chacon) bzw. \"GitHub flow\" (GitHub, Inc.)).\nHier ist der stabile Stand ebenfalls immer im master. Features werden ebenso wie im Git-Flow-Modell in eigenen Feature-Branches entwickelt.\nAllerdings zweigen Feature-Branches immer direkt vom master ab und werden nach dem Test auch immer dort wieder direkt integriert (es gibt also keine weiteren langlaufenden Branches wie develop oder release).\nIn der obigen Abbildung ist zu sehen, dass für die Entwicklung eines Features ein entsprechender Themenbranch vom master abgezweigt wird. Darin erfolgt dann die Entwicklung des Features, d.h. mehrere Commits. Das Mergen des Features in den master erfolgt dann aber nicht lokal, sondern mit einem \"Pull-Request\" auf dem Server: Sobald man im Feature-Branch einen \"diskussionswürdigen\" Stand hat, wird ein Pull-Request (PR) über die Weboberfläche aufgemacht (streng genommen gehört dies in die Kategorie “Zusammenarbeit” bzw. “Workflows”; außerdem gehört ein PR nicht zu Git selbst, sondern zum Tooling von Github). In einem PR können andere Entwickler den Code kommentieren und ergänzen. Jeder weitere Commit auf dem Themenbranch wird ebenfalls Bestandteil des Pull-Requests. Parallel laufen ggf. automatisierte Tests etc. und durch das Akzeptieren des PR in der Weboberfläche erfolgt schließlich der Merge des Feature-Branches in den master.\nDiskussion: Git-Flow vs. GitHub Flow In der Praxis zeigt sich, dass das Git-Flow-Modell besonders gut geeignet ist, wenn man tatsächlich so etwas wie \"Releases\" hat, die zudem nicht zu häufig auftreten.\nDas GitHub-Flow-Vorgehen bietet sich an, wenn man entweder keine Releases hat oder diese sehr häufig erfolgen (typisch bei agiler Vorgehensweise). Zudem vermeidet man so, dass die Feature-Branches zu lange laufen, womit normalerweise die Wahrscheinlichkeit von Merge-Konflikten stark steigt. Achtung: Da die Feature-Branches direkt in den master, also den stabilen Produktionscode gemergt werden, ist es hier besonders wichtig, vor dem Merge entsprechende Tests durchzuführen und den Merge erst zu machen, wenn alle Tests \"grün\" sind.\nHier ein paar Einstiegsseiten für die Diskussion, die teilweise sehr erbittert (und mit ideologischen Zügen) geführt wird (erinnert an die Diskussionen, welche Linux-Distribution die bessere sei):\nGit-Flow-Modell von Vincent Driessen Kurzer Überblick über das GitHub-Flow-Modell Diskussion des GitHub-Flow-Modells (Github) Luca Mezzalira: \"Git-Flow vs Github Flow\" Scott Schacon, Autor des Pro-Git-Buchs Noch eine (längere) Betrachtung (Robin Daugherty) Wrap-Up Einsatz von Themenbranches für die Entwicklung Unterschiedliche Modelle: Git-Flow: umfangreiches Konzept, gut für Entwicklung mit festen Releases GitHub Flow: deutlich schlankeres Konzept, passend für kontinuierliche Entwicklung ohne echte Releases",
    "description": "Nutzung von Git in Projekten: Verteiltes Git (und Workflows) Git ermöglicht ein einfaches und schnelles Branchen. Dies kann man mit entsprechenden Branching-Strategien sinnvoll für die SW-Entwicklung einsetzen.\nIm Folgenden sollen also die Frage betrachtet werden: Wie setze ich Branches sinnvoll ein?\nUmgang mit Branches: Themen-Branches I---J---K wuppieV1 / D---F wuppie / A---B---C---E master \\ G---H test Branchen ist in Git sehr einfach und schnell. Deshalb wird (gerade auch im Vergleich mit SVN) gern und viel gebrancht.",
    "tags": [],
    "title": "Branching-Strategien mit Git",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/git/branching-strategies.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Modern Java",
    "content": "Beispiel: Sortierung einer Liste List\u003cStudi\u003e sl = new ArrayList\u003cStudi\u003e(); // Anonyme innere Klasse Collections.sort(sl, new Comparator\u003cStudi\u003e() { @Override public int compare(Studi o1, Studi o2) { return Studi.cmpCpsClass(o1, o2); } }); // Lambda-Ausdruck Collections.sort(sl, (o1, o2) -\u003e Studi.cmpCpsClass(o1, o2)); // Methoden-Referenz Collections.sort(sl, Studi::cmpCpsClass); Anmerkung Für das obige Beispiel wird davon ausgegangen, dass in der Klasse Studi eine statische Methode cmpCpsClass() existiert:\npublic static int cmpCpsClass(Studi s1, Studi s2) { return s1.getCps() - s2.getCps(); } Wenn man im Lambda-Ausdruck nur Methoden der eigenen Klasse aufruft, kann man das auch direkt per Methoden-Referenz abkürzen!\nErinnerung: Comparator\u003cT\u003e ist ein funktionales Interface Instanzen können wie üblich durch Ableiten bzw. anonyme Klassen erzeugt werden Alternativ kann seit Java8 auch ein passender Lambda-Ausdruck verwendet werden Ab Java8: Referenzen auf passende Methoden (Signatur!) können ein funktionales Interface \"implementieren\" Die statische Methode static int cmpCpsClass(Studi s1, Studi s2) hat die selbe Signatur wie int compare(Studi s1, Studi s2) aus Comparator\u003cStudi\u003e Kann deshalb wie eine Instanz von Comparator\u003cStudi\u003e genutzt werden Name der Methode spielt dabei keine Rolle Überblick: Arten von Methoden-Referenzen Referenz auf eine statische Methode\nForm: ClassName::staticMethodName Wirkung: Aufruf mit (args) -\u003e ClassName.staticMethodName(args) Referenz auf Instanz-Methode eines bestimmten Objekts\nForm: objectref::instanceMethodName Wirkung: Aufruf mit (args) -\u003e objectref.instanceMethodName(args) Referenz auf Instanz-Methode eines bestimmten Typs\nForm: ClassName::instanceMethodName Wirkung: Aufruf mit (arg0, rest) -\u003e arg0.instanceMethodName(rest) (arg0 ist vom Typ ClassName) Anmerkung: Analog zur Referenz auf eine statische Methode gibt es noch die Form der Referenz auf einen Konstruktor: ClassName::new. Für Referenzen auf Konstruktoren mit mehr als 2 Parametern muss ein eigenes passendes funktionales Interface mit entsprechend vielen Parametern definiert werden ...\nMethoden-Referenz 1: Referenz auf statische Methode public class Studi { public static int cmpCpsClass(Studi s1, Studi s2) { return s1.getCredits() - s2.getCredits(); } public static void main(String... args) { List\u003cStudi\u003e sl = new ArrayList\u003cStudi\u003e(); // Referenz auf statische Methode Collections.sort(sl, Studi::cmpCpsClass); // Entsprechender Lambda-Ausdruck Collections.sort(sl, (o1, o2) -\u003e Studi.cmpCpsClass(o1, o2)); } } Demo: methodreferences.DemoStaticMethodReference Collections.sort() erwartet in diesem Szenario als zweiten Parameter eine Instanz von Comparator\u003cStudi\u003e mit einer Methode int compare(Studi o1, Studi o2).\nDie übergebene Referenz auf die statische Methode cmpCpsClass der Klasse Studi hat die selbe Signatur und wird deshalb von Collections.sort() genauso genutzt wie die eigentlich erwartete Methode Comparator\u003cStudi\u003e#compare(Studi o1, Studi o2), d.h. statt compare(o1, o2) wird nun für jeden Vergleich Studi.cmpCpsClass(o1, o2) aufgerufen.\nMethoden-Referenz 2: Referenz auf Instanz-Methode (Objekt) public class Studi { public int cmpCpsInstance(Studi s1, Studi s2) { return s1.getCredits() - s2.getCredits(); } public static void main(String... args) { List\u003cStudi\u003e sl = new ArrayList\u003cStudi\u003e(); Studi holger = new Studi(\"Holger\", 42); // Referenz auf Instanz-Methode eines Objekts Collections.sort(sl, holger::cmpCpsInstance); // Entsprechender Lambda-Ausdruck Collections.sort(sl, (o1, o2) -\u003e holger.cmpCpsInstance(o1, o2)); } } Demo: methodreferences.DemoInstanceMethodReferenceObject Collections.sort() erwartet in diesem Szenario als zweites Argument wieder eine Instanz von Comparator\u003cStudi\u003e mit einer Methode int compare(Studi o1, Studi o2).\nDie übergebene Referenz auf die Instanz-Methode cmpCpsInstance des Objekts holger hat die selbe Signatur und wird entsprechend von Collections.sort() genauso genutzt wie die eigentlich erwartete Methode Comparator\u003cStudi\u003e#compare(Studi o1, Studi o2), d.h. statt compare(o1, o2) wird nun für jeden Vergleich holger.cmpCpsInstance(o1, o2) aufgerufen.\nMethoden-Referenz 3: Referenz auf Instanz-Methode (Typ) public class Studi { public int cmpCpsInstance(Studi studi) { return this.getCredits() - studi.getCredits(); } public static void main(String... args) { List\u003cStudi\u003e sl = new ArrayList\u003cStudi\u003e(); // Referenz auf Instanz-Methode eines Typs Collections.sort(sl, Studi::cmpCpsInstance); // Entsprechender Lambda-Ausdruck Collections.sort(sl, (o1, o2) -\u003e o1.cmpCpsInstance(o2)); } } Demo: methodreferences.DemoInstanceMethodReferenceType Collections.sort() erwartet in diesem Szenario als zweites Argument wieder eine Instanz von Comparator\u003cStudi\u003e mit einer Methode int compare(Studi o1, Studi o2).\nDie übergebene Referenz auf die Instanz-Methode cmpCpsInstance des Typs Studi hat die Signatur int cmpCpsInstance(Studi studi) und wird von Collections.sort() so genutzt: Statt compare(o1, o2) wird nun für jeden Vergleich o1.cmpCpsInstance(o2) aufgerufen.\nAusblick: Threads Erinnerung an bzw. Vorgriff auf “Threads: Intro”:\npublic interface Runnable { void run(); } Damit lassen sich Threads auf verschiedene Arten erzeugen:\npublic class ThreadStarter { public static void wuppie() { System.out.println(\"wuppie(): wuppie\"); } } Thread t1 = new Thread(new Runnable() { public void run() { System.out.println(\"t1: wuppie\"); } }); Thread t2 = new Thread(() -\u003e System.out.println(\"t2: wuppie\")); Thread t3 = new Thread(ThreadStarter::wuppie); Beispiel: methodreferences.ThreadStarter Ausblick: Datenstrukturen als Streams Erinnerung an bzw. Vorgriff auf “Stream-API”:\nclass X { public static boolean gtFour(int x) { return (x \u003e 4) ? true : false; } } List\u003cString\u003e words = Arrays.asList(\"Java8\", \"Lambdas\", \"PM\", \"Dungeon\", \"libGDX\", \"Hello\", \"World\", \"Wuppie\"); List\u003cInteger\u003e wordLengths = words.stream() .map(String::length) .filter(X::gtFour) .sorted() .collect(toList()); Beispiel: methodreferences.CollectionStreams Collections können als Datenstrom betrachtet werden: stream() Iteration über die Collection, analog zu externer Iteration mit foreach Daten aus dem Strom filtern: filter, braucht Prädikat Auf alle Daten eine Funktion anwenden: map Daten im Strom sortieren: sort (auch mit Comparator) Daten wieder einsammeln mit collect =\u003e Typische Elemente funktionaler Programmierung\n=\u003e Verweis auf Wahlfach \"Spezielle Methoden der Programmierung\"\nWrap-Up Seit Java8: Methoden-Referenzen statt anonymer Klassen (funktionales Interface nötig)\nDrei mögliche Formen:\nForm 1: Referenz auf statische Methode: ClassName::staticMethodName (verwendet wie (args) -\u003e ClassName.staticMethodName(args)) Form 2: Referenz auf Instanz-Methode eines Objekts: objectref::instanceMethodName (verwendet wie (args) -\u003e objectref.instanceMethodName(args)) Form 3: Referenz auf Instanz-Methode eines Typs: ClassName::instanceMethodName (verwendet wie (o1, args) -\u003e o1.instanceMethodName(args)) Im jeweiligen Kontext muss ein passendes funktionales Interface verwendet werden (d.h. ein Interface mit genau einer abstrakten Methode)",
    "description": "Beispiel: Sortierung einer Liste List\u003cStudi\u003e sl = new ArrayList\u003cStudi\u003e(); // Anonyme innere Klasse Collections.sort(sl, new Comparator\u003cStudi\u003e() { @Override public int compare(Studi o1, Studi o2) { return Studi.cmpCpsClass(o1, o2); } }); // Lambda-Ausdruck Collections.sort(sl, (o1, o2) -\u003e Studi.cmpCpsClass(o1, o2)); // Methoden-Referenz Collections.sort(sl, Studi::cmpCpsClass); Anmerkung Für das obige Beispiel wird davon ausgegangen, dass in der Klasse Studi eine statische Methode cmpCpsClass() existiert:\npublic static int cmpCpsClass(Studi s1, Studi s2) { return s1.getCps() - s2.getCps(); } Wenn man im Lambda-Ausdruck nur Methoden der eigenen Klasse aufruft, kann man das auch direkt per Methoden-Referenz abkürzen!",
    "tags": [],
    "title": "Methoden-Referenzen",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/modern-java/methodreferences.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Coding",
    "content": "Wie prüfen Sie die Werte von Variablen/Objekten? Debugging\nBeeinflusst Code nicht Kann schnell komplex und umständlich werden Sitzung transient - nicht wiederholbar \"Poor-man's-debugging\" (Ausgaben mit System.out.println)\nMüssen irgendwann entfernt werden Ausgabe nur auf einem Kanal (Konsole) Keine Filterung nach Problemgrad - keine Unterscheidung zwischen Warnungen, einfachen Informationen, ... Logging\nVerschiedene (Java-) Frameworks: java.util.logging (JDK), log4j (Apache), SLF4J, Logback, ... Java Logging API - Überblick Paket java.util.logging\nEine Applikation kann verschiedene Logger instanziieren. Die Logger bauen per Namenskonvention hierarchisch aufeinander auf. Jeder Logger kann selbst mehrere Handler haben, die eine Log-Nachricht letztlich auf eine bestimmte Art und Weise an die Außenwelt weitergeben.\nLog-Meldungen werden einem Level zugeordnet. Jeder Logger und Handler hat ein Mindest-Level eingestellt, d.h. Nachrichten mit einem kleineren Level werden verworfen.\nZusätzlich gibt es noch Filter, mit denen man Nachrichten (zusätzlich zum Log-Level) nach weiteren Kriterien filtern kann.\nKonsole: logging.LoggingDemo Erzeugen neuer Logger import java.util.logging.Logger; Logger l = Logger.getLogger(MyClass.class.getName()); Factory-Methode der Klasse java.util.logging.Logger\npublic static Logger getLogger(String name); =\u003e Methode liefert bereits vorhandenen Logger mit diesem Namen (sonst neuen Logger)\nBest Practice: Nutzung des voll-qualifizierten Klassennamen: MyClass.class.getName()\nLeicht zu implementieren Leicht zu erklären Spiegelt modulares Design Ausgaben enthalten automatisch Hinweis auf Herkunft (Lokalität) der Meldung Alternativen: Funktionale Namen wie \"XML\", \"DB\", \"Security\" Ausgabe von Logmeldungen public void log(Level level, String msg); Diverse Convenience-Methoden (Auswahl):\npublic void warning(String msg) public void info(String msg) public void entering(String srcClass, String srcMethod) public void exiting(String srcClass, String srcMethod) Beispiel\nimport java.util.logging.Logger; Logger l = Logger.getLogger(MyClass.class.getName()); l.info(\"Hello World :-)\"); Wichtigkeit von Logmeldungen: Stufen java.util.logger.Level definiert 7 Stufen:\nSEVERE, WARNING, INFO, CONFIG, FINE, FINER, FINEST (von höchster zu niedrigster Prio) Zusätzlich ALL und OFF Nutzung der Log-Level:\nLogger hat Log-Level: Meldungen mit kleinerem Level werden verworfen Prüfung mit public boolean isLoggable(Level) Setzen mit public void setLevel(Level) Konsole: logging.LoggingLevel =\u003e Warum wird im Beispiel nach log.setLevel(Level.ALL); trotzdem nur ab INFO geloggt? Wer erzeugt eigentlich die Ausgaben?!\nJemand muss die Arbeit machen ... Pro Logger mehrere Handler möglich\nLogger übergibt nicht verworfene Nachrichten an Handler Handler haben selbst ein Log-Level (analog zum Logger) Handler verarbeiten die Nachrichten, wenn Level ausreichend Standard-Handler: StreamHandler, ConsoleHandler, FileHandler\nHandler nutzen zur Formatierung der Ausgabe einen Formatter\nStandard-Formatter: SimpleFormatter und XMLFormatter\nKonsole: logging.LoggingHandler =\u003e Warum wird im Beispiel nach dem Auskommentieren von log.setUseParentHandlers(false); immer noch eine zusätzliche Ausgabe angezeigt (ab INFO aufwärts)?!\nIch ... bin ... Dein ... Vater ... Logger bilden Hierarchie über Namen\nTrenner für Namenshierarchie: \".\" (analog zu Packages) =\u003e mit jedem \".\" wird eine weitere Ebene der Hierarchie aufgemacht ... Jeder Logger kennt seinen Eltern-Logger: Logger#getParent() Basis-Logger: leerer Name (\"\") Voreingestelltes Level des Basis-Loggers: Level.INFO (!) Weiterleiten von Nachrichten\nNicht verworfene Log-Aufrufe werden an Eltern-Logger weitergeleitet (Default) Abschalten mit Logger#setUseParentHandlers(false); Diese leiten an ihre Handler sowie an ihren Eltern-Logger weiter (unabhängig von Log-Level!) Konsole: logging.LoggingParent; Tafel: Skizze Logger-Baum Wrap-Up Java Logging API im Paket java.util.logging\nNeuer Logger über Factory-Methode der Klasse Logger\nEinstellbares Log-Level (Klasse Level) Handler kümmern sich um die Ausgabe, nutzen dazu Formatter Mehrere Handler je Logger registrierbar Log-Level auch für Handler einstellbar (!) Logger (und Handler) \"interessieren\" sich nur für Meldungen ab bestimmter Wichtigkeit Logger reichen nicht verworfene Meldungen defaultmäßig an Eltern-Logger weiter (rekursiv)",
    "description": "Wie prüfen Sie die Werte von Variablen/Objekten? Debugging\nBeeinflusst Code nicht Kann schnell komplex und umständlich werden Sitzung transient - nicht wiederholbar \"Poor-man's-debugging\" (Ausgaben mit System.out.println)\nMüssen irgendwann entfernt werden Ausgabe nur auf einem Kanal (Konsole) Keine Filterung nach Problemgrad - keine Unterscheidung zwischen Warnungen, einfachen Informationen, ... Logging\nVerschiedene (Java-) Frameworks: java.util.logging (JDK), log4j (Apache), SLF4J, Logback, ... Java Logging API - Überblick Paket java.util.logging",
    "tags": [],
    "title": "Logging",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/coding/logging.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Praktikum",
    "content": "Ihr Code soll einheitlich formatiert und dokumentiert sein. Sie können beides prüfen: ./gradlew spotlessCheck für die Formatierung und ./gradlew checkstyleMain für die Dokumentation1 mit Javadoc.2 Während Sie die Dokumentation bei Fehlern manuell anpassen müssen (siehe Lektion “Javadoc”), können Sie mit ./gradlew spotlessApply den Code automatisch formatieren lassen - tun Sie das am besten vor jedem Commit.\nA04.1: Javadoc-Kommentare (10%) Gute Javadoc-Kommentare schreiben erfordert Übung. Schauen Sie sich die in Commit Dungeon-CampusMinden/Dungeon/commit/46530b6 neu hinzugefügte Datei code/core/src/controller/ControllerLayer.java an.\nDiskutieren Sie jeweils, was Ihnen an der Dokumentation dieser Klasse auffällt: Was gefällt Ihnen, was stört Sie? Schlagen Sie Verbesserungen vor.\nA04.2: Anonyme Klassen und Lambda-Ausdrücke (40%) Klonen Sie die Vorgaben \"Calculator\" und laden Sie das Projekt als Gradle-Projekt in Ihre IDE.\nIm Package calculator finden Sie einige Interfaces und Klassen, mit denen man einen einfachen Taschenrechner modellieren kann: Dieser kann einfache mathematische Operationen auf zwei Integern ausführen.\nIn der Klasse calculator.Calculator finden Sie vier mit TODO markierte Stellen in der Methode setupOperationSelector:\nErstellen Sie eine neue Java-Klasse Sub, die das Interface Operation implementiert und eine Subtraktion bereitstellt. Erweitern Sie den Calculator und binden Sie eine Instanz dieser Klasse ein. Nutzen Sie hier keine anonymen Klassen oder Lambda-Ausdrücke. Erstellen Sie eine weitere Operation \"Mul\" (Multiplikation von zwei Integern). Nutzen Sie dazu eine passende anonyme Klasse. Erstellen Sie eine weitere Operation \"Div\" (Integerdivision). Erstellen Sie einen passenden Lambda-Ausdruck. Für die JComboBox operationSelector wird ein ActionListener mit Hilfe einer anonymen Klasse definiert. Konvertieren Sie dies in einen entsprechenden Lambda-Ausdruck. A04.3: DevDungeon: Zerbrechende Tiles und Speed Potions (50%) Klonen Sie das Projekt DevDungeon und laden Sie es in Ihrer IDE als Gradle-Projekt. Betrachten Sie das Sub-Projekt \"devDungeon\". Dies ist ein von einem Studierenden (@Flamtky) erstelltes Spiel mit mehreren Leveln, in denen Sie spielerisch verschiedene Aufgaben in-game und ex-game lösen müssen.\nStarten Sie den DevDungeon mit ./gradlew devDungeon:runDevDungeon. Spielen Sie sich für diese Aufgabe durch das erste Level (\"Damaged Bridge\")3.\nZiel ist es, die mysteriöse Brücke in der Mitte des ersten Levels lebendig zu überqueren. Beobachten Sie die Startsequenz: Was fällt ihnen an dem Monster auf, dass Sie ganz am Anfang angreifen will? Sie finden weitere Hinweise in den Briefkästen und über die Popups ... Beachten Sie auch die Hinweise am versteckten Item. Um dieses nutzbar zu machen, müssen Sie in den Java-Code des Spiels gehen (im src/-Unterordner im Sub-Projekt \"devDungeon\") und den Effekt für das Item reparieren (implementieren). Analysieren Sie den Code für das Item und seinen Effekt, und schauen Sie sich die anderen Effekte im selben Package an. Schreiben Sie nun Code für die mit \"TODO\" markierte Methode des Effekts. Starten Sie dann das Spiel neu und schauen Sie, ob das Item nun funktioniert.\nWICHTIG: Bevor Sie mit der Implementierung beginnen, schauen Sie sich bitte die Einführung in die Programmierung des Dungeons und die verwendete Entity-Component-System-Architektur in der Lektion Intro Dungeon an. Dort werden Ihnen Hintergründe zum Dungeon und der für diese Aufgabe relevanten Component erklärt.\nHinweis: Sie können das Demo-Level deaktivieren, indem Sie in der Klasse starter.DevDungeon das Flag SKIP_TUTORIAL auf den Wert true setzen. Damit gelangen Sie direkt in das in dieser Aufgabe relevante Level.\nHinweis: Aktuell ist das Projekt DevDungeon an einigen Stellen noch Work-in-Progress, beispielsweise fehlt häufig noch die Javadoc. Alle Gradle-Tasks, die von Checkstyle-Tasks abhängen (checkstyleMain, check, build, ...) werden deshalb fehlschlagen. Sie können den DevDungeon aber wie oben beschrieben mit ./gradlew devDungeon:runDevDungeon (bzw. über den Task devDungeon:runDevDungeon aus der IDE heraus) starten.\nWICHTIG: Achten Sie bitte darauf, dass im Projektpfad keine Leerzeichen und keine Sonderzeichen (Umlaute o.ä.) vorkommen! Dies kann zu seltsamen Fehler führen. Bitte auch darauf achten, dass Sie als JDK ein Java SE 21 (LTS) verwenden.\nzumindest für den syntaktischen Aspekt ... ↩︎\nSie können auch beides zusammen per ./gradlew check prüfen lassen. ↩︎\nDas erste richtige Level, also das erste Level nach dem Demo-Level. Zur Erinnerung: Das Demo-Level hatte Ihnen in Blatt 02 gezeigt, wie Sie das Spiel bedienen können. Zusätzlich gibt es die kurze Anleitung \"How to play\" ... ↩︎",
    "description": "Ihr Code soll einheitlich formatiert und dokumentiert sein. Sie können beides prüfen: ./gradlew spotlessCheck für die Formatierung und ./gradlew checkstyleMain für die Dokumentation1 mit Javadoc.2 Während Sie die Dokumentation bei Fehlern manuell anpassen müssen (siehe Lektion “Javadoc”), können Sie mit ./gradlew spotlessApply den Code automatisch formatieren lassen - tun Sie das am besten vor jedem Commit.\nA04.1: Javadoc-Kommentare (10%) Gute Javadoc-Kommentare schreiben erfordert Übung. Schauen Sie sich die in Commit Dungeon-CampusMinden/Dungeon/commit/46530b6 neu hinzugefügte Datei code/core/src/controller/ControllerLayer.java an.",
    "tags": [],
    "title": "Blatt 04: Calculator und DevDungeon (Lambda-Ausdrücke)",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/homework/b04.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Git",
    "content": "Nutzung von Git in Projekten: Verteiltes Git (und Workflows) Git ermöglicht eine einfaches Zusammenarbeit in verteilten Teams. Nachdem wir die verschiedenen Branching-Strategien betrachtet haben, soll im Folgenden die Frage betrachtet werden: Wie arbeite ich sinnvoll über Git mit anderen Kollegen und Teams zusammen? Welche Modelle haben sich etabliert?\nClonen kann sich lohnen ... https://github.com/Programmiermethoden-CampusMinden/Prog2-Lecture ---C---D---E master =\u003e git clone https://github.com/Programmiermethoden-CampusMinden/Prog2-Lecture\n./Prog2-Lecture/ (lokaler Rechner) ---C---D---E master ^origin/master Git-Repository mit der URL \u003cURL-Repo\u003e in lokalen Ordner \u003cdirectory\u003e auschecken:\ngit clone \u003cURL-Repo\u003e [\u003cdirectory\u003e] Workingcopy ist automatisch über den Namen origin mit dem remote Repo auf dem Server verbunden Lokaler Branch master ist mit dem remote Branch origin/master verbunden (\"Tracking Branch\", s.u.), der den Stand des master-Branches auf dem Server spiegelt Für die URL sind verschiedene Protokolle möglich, beispielsweise:\n\"file://\" für über das Dateisystem erreichbare Repositories (ohne Server) \"https://\" für Repo auf einem Server: Authentifikation mit Username und Passwort (!) \"git@\" für Repo auf einem Server: Authentifikation mit SSH-Key (diese Variante wird im Praktikum im Zusammenspiel mit dem Gitlab-Server im SW-Labor verwendet) Eigener und entfernter master entwickeln sich weiter ... https://github.com/Programmiermethoden-CampusMinden/Prog2-Lecture ---C---D---E---F---G master ./Prog2-Lecture/ (lokaler Rechner) ---C---D---E---H master ^origin/master Nach dem Auschecken liegen (in diesem Beispiel) drei master-Branches vor:\nDer master auf dem Server, der lokale master, und die lokale Referenz auf den master-Branch auf dem Server: origin/master. Der lokale master ist ein normaler Branch und kann durch Commits verändert werden.\nDer master auf dem Server kann sich ebenfalls ändern, beispielsweise weil jemand anderes seine lokalen Änderungen mit dem Server abgeglichen hat (git push, s.u.).\nDer Branch origin/master lässt sich nicht direkt verändern! Das ist lediglich eine lokale Referenz auf den master-Branch auf dem Server und zeigt an, welchen Stand man bei der letzten Synchronisierung hatte. D.h. erst mit dem nächsten Abgleich wird sich dieser Branch ändern (sofern sich der entsprechende Branch auf dem Server verändert hat).\nAnmerkung: Dies gilt analog für alle anderen Branches. Allerdings wird nur der origin/master beim Clonen automatisch als lokaler Branch ausgecheckt.\nZur Abbildung: Während man lokal arbeitet (Commit H auf dem lokalen master), kann es passieren, dass sich auch das remote Repo ändert. Im Beispiel wurden dort die beiden Commits F und G angelegt (durch git push, s.u.).\nWichtig: Da in der Zwischenzeit das lokale Repo nicht mit dem Server abgeglichen wurde, zeigt der remote Branch origin/master immer noch auf den Commit E!\nÄnderungen im Remote holen und Branches zusammenführen https://github.com/Programmiermethoden-CampusMinden/Prog2-Lecture ---C---D---E---F---G master =\u003e git fetch origin\n./Prog2-Lecture/ (lokaler Rechner) ---C---D---E---H master \\ F---G origin/master Änderungen auf dem Server mit dem eigenen Repo abgleichen Mit git fetch origin alle Änderungen holen\nAlle remote Branches werden aktualisiert und entsprechen den jeweiligen Branches auf dem Server: Im Beispiel zeigt jetzt origin/master ebenso wie der master auf dem Server auf den Commit G. Neue Branches auf dem Server werden ebenfalls \"geholt\", d.h. sie liegen nach dem Fetch als entsprechende remote Branches vor Auf dem Server gelöschte Branches werden nicht automatisch lokal gelöscht; dies kann man mit git fetch --prune origin automatisch erreichen Wichtig: Es werden nur die remote Branches aktualisiert, nicht die lokalen Branches!\nmaster-Branch nach \"git fetch origin\" zusammenführen Mit git checkout master Workingcopy auf eigenen master umstellen Mit git merge origin/master Änderungen am origin/master in eigenen master mergen Mit git push origin master eigene Änderungen ins remote Repo pushen https://github.com/Programmiermethoden-CampusMinden/Prog2-Lecture ---C---D---E---H---I master \\ / F---G ./Prog2-Lecture/ (lokaler Rechner) ---C---D---E---H---I master \\ /^origin/master F---G Anmerkung: Schritt (2) kann man auch per git pull origin master erledigen ... Ein pull fasst fetch und merge zusammen (s.u.).\nAnmerkung Statt dem merge in Schritt (2) kann man auch den lokalen master auf den aktualisierten origin/master rebasen und vermeidet damit die \"Raute\". Der pull kann mit der Option \"--rebase\" auf \"rebase\" umgestellt werden (per Default wird bei pull ein \"merge\" ausgeführt).\nAuf dem Server ist nur ein fast forward merge möglich Sie können Ihre Änderungen in Ihrem lokalen master auch direkt in das remote Repo pushen, solange auf dem Server ein fast forward merge möglich ist.\nWenn aber (wie in der Abbildung) der lokale und der remote master divergieren, müssen Sie den Merge wie beschrieben lokal durchführen (fetch/merge oder pull) und das Ergebnis wieder in das remote Repo pushen (dann ist ja wieder ein fast forward merge möglich, es sei denn, jemand hat den remote master in der Zwischenzeit weiter geschoben - dann muss die Aktualisierung erneut durchgeführt werden).\nBeispiel für Zusammenführen (merge und push), Anmerkung zu fast forward merge Branches und Remotes Eigenen (neuen) lokalen Branch ins remote Repo schicken\ngit push \u003cremote\u003e \u003cbranch\u003e Neuer Branch im remote Repo\ngit fetch \u003cremote\u003e holt (auch) alle neuen Branches Lokale Änderungen an remote Branches nicht möglich! =\u003e Remote Branch in lokalen Branch mergen (oder auschecken) Zusammenfassung: Arbeiten mit Remotes Änderungen vom Server holen: git fetch \u003cremote\u003e =\u003e Holt alle Änderungen vom Repo \u003cremote\u003e ins eigene Repo (Workingcopy bleibt unangetastet!)\nAktuellen lokalen Branch auffrischen: git merge \u003cremote\u003e/\u003cbranch\u003e (oder alternativ git pull \u003cremote\u003e \u003cbranch\u003e)\nEigene Änderungen hochladen: git push \u003cremote\u003e \u003cbranch\u003e\nAnmerkung: push geht nur, wenn Ziel ein \"bare\"-Repository ist, und keine Konflikte entstehen =\u003e im remote Repo nur \"fast forward\"-Merge möglich\n=\u003e bei Konflikten erst fetch und merge, danach push\nAnmerkung: Ein \"bare\"-Repository enthält keine Workingcopy, sondern nur das Repo an sich. Die ist bei Repos, die Sie auf einem Server wie Gitlab oder Github anlegen, automatisch der Fall. Sie können aber auch lokal ein solches \"bare\"-Repo anlegen, indem Sie beim Initialisieren den Schalter --bare mitgeben: git init --bare ...\nBeispiel git fetch origin # alle Änderungen vom Server holen git checkout master # auf lokalen Master umschalten git merge origin/master # lokalen Master aktualisieren ... # Herumspielen am lokalen Master git push origin master # lokalen Master auf Server schicken Vereinfachung: Tracking Branches Tracking Branch: lokaler Branch, der remote Branch \"verfolgt\"\nBeispiel: lokaler master-Branch folgt origin/master per Default Vereinfachung im Workflow:\ngit pull entspricht git fetch \u003cremote\u003e plus git merge \u003cremote\u003e/\u003cbranch\u003e git push entspricht git push \u003cremote\u003e \u003cbranch\u003e Vorsicht: pull und push beziehen sich nur auf ausgecheckten Tracking Branch\nEinrichten von Tracking Branches git clone: lokaler master trackt automatisch origin/master\nRemote Branch als Tracking Branch einrichten:\nÄnderungen aus remote Repo holen: git fetch \u003cremote\u003e Tracking Branch anlegen: git checkout -t \u003cremote\u003e/\u003cbranch\u003e (=\u003e Option -t richtet den remote Branch als Tracking Branch ein) Lokalen neuen Branch ins remote Repo schicken und als Tracking Branch einrichten:\nLokalen Branch erzeugen: git checkout -b \u003cbranch\u003e Lokalen Branch ins Repo schicken: git push -u \u003cremote\u003e \u003cbranch\u003e (=\u003e Option -u richtet den lokalen Branch als Tracking Branch ein) Hinzufügen eines (weiteren) Remote Repository Sie können einem Repo beliebig viele Remotes hinzufügen:\ngit remote add \u003cname\u003e \u003curl\u003e\nBeispiel: git remote add andi git@github.com:andi/repo.git\nRemote origin wird bei clone automatisch angelegt Ansehen der Remotes mit git remote -v fetch, push und pull jeweils über den vergebenen Namen Beispiel: git fetch andi oder git push origin master\nWrap-Up Synchronisierung des lokalen Repos mit anderen Repos\nRepo kopieren: git clone \u003curl\u003e Interner Name fürs fremde Repo: origin Änderungen vom fremden Repo holen: git fetch \u003cremote\u003e Änderungen in lokalen Branch einpflegen: git merge \u003cremote\u003e/\u003cbranch\u003e Eigene Änderungen ins fremde Repo schieben: git push \u003cremote\u003e \u003cbranch\u003e Tracking Branches (Konzept, Anwendung)\nRemote Branches können lokal nicht verändert werden: In lokale Branches mergen, oder Tracking Branches anlegen =\u003e einfaches pull und push nutzen Tracking Branches sind lokale Branches, die remote Branches verfolgen (\"tracken\")",
    "description": "Nutzung von Git in Projekten: Verteiltes Git (und Workflows) Git ermöglicht eine einfaches Zusammenarbeit in verteilten Teams. Nachdem wir die verschiedenen Branching-Strategien betrachtet haben, soll im Folgenden die Frage betrachtet werden: Wie arbeite ich sinnvoll über Git mit anderen Kollegen und Teams zusammen? Welche Modelle haben sich etabliert?\nClonen kann sich lohnen ... https://github.com/Programmiermethoden-CampusMinden/Prog2-Lecture ---C---D---E master =\u003e git clone https://github.com/Programmiermethoden-CampusMinden/Prog2-Lecture",
    "tags": [],
    "title": "Arbeiten mit Git Remotes (dezentrale Repos)",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/git/remotes.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Git",
    "content": "Nutzung von Git in Projekten: Verteiltes Git (und Workflows) Git ermöglicht ein einfaches und schnelles Branchen. Dies kann man mit entsprechenden Branching-Strategien sinnvoll für die SW-Entwicklung einsetzen.\nAuf der anderen Seite ermöglicht Git ein sehr einfaches verteiltes Arbeiten. Auch hier ergeben sich verschiedene Workflows, wie man mit anderen Entwicklern an einem Projekt arbeiten will/kann.\nIm Folgenden sollen also die Frage betrachtet werden: Wie gestalte ich die Zusammenarbeit? Antwort: Workflows mit Git ...\nZusammenarbeit: Zentraler Workflow mit Git (analog zu SVN) In kleinen Projektgruppen wie beispielsweise Ihrer Arbeitsgruppe wird häufig ein einfacher zentralisierter Workflow bei der Versionsverwaltung genutzt. Im Mittelpunkt steht dabei ein zentrales Repository, auf dem alle Teammitglieder gleichberechtigt und direkt pushen dürfen.\nVorteile:\nEinfachstes denkbares Modell Ein gemeinsames Repo (wie bei SVN) Alle haben Schreibzugriff auf ein gemeinsames Repo Nachteile:\nDefinition und Umsetzung von Rollen mit bestimmten Rechten (\"Manager\", \"Entwickler\", \"Gast-Entwickler\", ...) schwierig bis unmöglich (das ist kein Git-Thema, sondern hängt von der Unterstützung durch den Anbieter des Servers ab) Jeder darf überall pushen: Enge und direkte Abstimmung nötig Modell funktioniert meist nur in sehr kleinen Teams (2..3 Personen) Zusammenarbeit: Einfacher verteilter Workflow mit Git In großen und/oder öffentlichen Projekten wird üblicherweise ein Workflow eingesetzt, der auf den Möglichkeiten von verteilten Git-Repositories basiert.\nDabei wird zwischen verschiedenen Rollen (\"Integrationsmanager\", \"Entwickler\") unterschieden.\nSie finden dieses Vorgehen beispielsweise beim Linux-Kernel und auch häufig bei Projekten auf Github.\nEs existiert ein geschütztes (\"blessed\") Master-Repo\nStellt die Referenz für das Projekt dar Push-Zugriff nur für ausgewählte Personen (\"Integrationsmanager\") Entwickler\nForken das Master-Repo auf dem Server und klonen ihren Fork lokal Arbeiten auf lokalem Klon: Unabhängige Entwicklung eines Features Pushen ihren Stand in ihren Fork (ihr eigenes öffentliches Repo): Veröffentlichung des Beitrags zum Projekt (sobald fertig bzw. diskutierbar) Lösen Pull- bzw. Merge-Request gegen das Master-Repo aus: Beitrag soll geprüft und ins Projekt aufgenommen werden (Merge ins Master-Repo durch den Integrationsmanager) Integrationsmanager\nPrüft die Änderungen im Pull- bzw. Merge-Request und fordert ggf. Nacharbeiten an bzw. lehnt Integration ab (technische oder politische Gründe) Führt Merge der Entwickler-Zweige mit den Hauptzweigen durch Akzeptieren der Pull- bzw. Merge-Requests durch: Beitrag der Entwickler ist im Projekt angekommen und ist beim nächsten Pull in deren lokalen Repos vorhanden Den hier gezeigten Zusammenhang kann man auf weitere Ebenen verteilen, vgl. den im Linux-Kernel gelebten \"Dictator and Lieutenants Workflow\" (siehe Literatur).\nHinweis: Hier wird nur die Zusammenarbeit im verteilten Team dargestellt. Dazu kommt noch das Arbeiten mit verschiedenen Branches!\nAnmerkung: In der Workingcopy wird das eigene (öffentliche) Repo oft als origin und das geschützte (\"blessed\") Master-Repo als upstream referenziert.\nAnmerkungen zum Forken Sie könnten auch das Original-Repo direkt clonen. Allerdings würden dann die push dort aufschlagen, was in der Regel nicht erwünscht ist (und auch nicht erlaubt ist).\nDeshalb forkt man das Original-Repo auf dem Server, d.h. auf dem Server wird eine Kopie des Original-Repos im eigenen Namespace angelegt. Auf diese Kopie hat man dann uneingeschränkten Zugriff.\nAnmerkungen zu den Namen für die Remotes: origin und upstream Üblicherweise checkt man die Kopie lokal aus (d.h. erzeugt einen Clone). In der Workingcopy verweist dann origin auf die Kopie. Um Änderungen am Original-Repo zu erhalten, fügt man dieses unter dem Namen upstream als weiteres Remote-Repo hinzu. Dies ist eine nützliche Konvention.\nUm Änderungen aus dem Original-Repo in den eigenen Fork (und die Workingcopy) zu bringen, führt man dann einfach folgendes aus (im Beispiel für den master):\n$ git checkout master # Workingcopy auf master $ git pull upstream master # Aktualisiere lokalen master mit master aus Original-Repo $ git push origin master # Pushe lokalen master in den Fork Feature-Branches aktualisieren: Mergen mit master vs. Rebase auf master Im Netz finden sich häufig Anleitungen, wonach man Änderungen im master mit einem Merge in den Feature-Branch holt, also sinngemäß:\n$ git checkout master # Workingcopy auf master $ git pull upstream master # Aktualisiere lokalen master mit master aus Vorgabe-Repo $ git checkout feature # Workingcopy auf feature $ git merge master # Aktualisiere feature: Merge master in feature $ git push origin feature # Push aktuellen feature ins Team-Repo Das funktioniert rein technisch betrachtet.\nAllerdings spielt in den meisten Git-Projekten der master üblicherweise eine besondere Rolle (vgl. Branching-Strategien) und ist üblicherweise stets das Ziel eines Merge, aber nie die Quelle! D.h. per Konvention geht der Fluß von Änderungen stets in den master (und nicht heraus).\nWenn man sich nicht an diese Konvention hält, hat man später möglicherweise Probleme, die Merge-Historie zu verstehen (welche Änderung kam von woher)!\nUm die Änderungen im master in einen Feature-Branch zu bekommen, sollte deshalb ein Rebase (des Feature-Branches auf den master) vor einem Merge (des master in den Feature-Branch) bevorzugt werden.\nMerk-Regel: Merge niemals nie den master in Feature-Branches!\nAchtung: Ein Rebase bei veröffentlichten Branches ist problematisch, da Dritte auf diesem Branch arbeiten könnten und entsprechend auf die Commit-IDs angewiesen sind. Nach einem Rebase stimmen diese Commit-IDs nicht mehr, was normalerweise mindestens zu Verärgerung führt ... Die Dritten müssten ihre Arbeit dann auf den neuen Feature-Branch (d.h. den Feature-Branch nach dessen Rebase) rebasen ... vgl. auch \"The Perils of Rebasing\" in Abschnitt \"3.6 Rebasing\" in [Chacon2014].\nMögliches Szenario im Praktikum Im Praktikum haben Sie das Vorgabe-Repo. Dieses könnten Sie als upstream in Ihre lokale Workingcopy einbinden.\nMit Ihrem Team leben Sie vermutlich einen zentralen Workflow, d.h. Sie binden Ihr gemeinsames Repo als origin in Ihre lokale Workingcopy ein.\nDann müssen Sie den lokalen master aus beiden Remotes aktualisieren. Zusätzlich wollen Sie Ihren aktuellen Themenbranch auf den aktuellen master rebasen.\n$ git checkout master # Workingcopy auf master $ git pull upstream master # Aktualisiere lokalen master mit master aus Vorgabe-Repo $ git pull origin master # Aktualisiere lokalen master mit master aus Team-Repo $ git push origin master # Pushe lokalen master in das Team-Repo zurück $ git rebase master feature # Rebase feature auf den aktuellen lokalen master $ git push -f origin feature # Push aktuellen feature ins Team-Repo (\"-f\" wg. geänderter IDs durch rebase) Anmerkung: Dabei können in Ihrem master die unschönen \"Rauten\" entstehen. Wenn Sie das vermeiden wollen, tauschen Sie den zweiten und den dritten Schritt und führen den Pull gegen den Upstream-master als pull --rebase durch. Dann müssen Sie Ihren lokalen master allerdings auch force-pushen in Ihr Team-Repo und die anderen Team-Mitglieder sollten darüber informiert werden, dass sich der master auf inkompatible Weise geändert hat ...\nKommunikation: Merge- bzw. Pull-Requests Mergen kann man auf der Konsole (oder in der IDE) und anschließend die (neuen) Branches auf den Server pushen.\nDie verschiedenen Git-Server erlauben ebenfalls ein GUI-gestütztes Mergen von Branches: \"Merge-Requests\" (MR, Gitlab) bzw. \"Pull-Requests\" (PR, Github). Das hat gegenüber dem lokalen Mergen wichtige Vorteile: Andere Entwickler sehen den beabsichtigten Merge (frühzeitig) und können direkt den Code kommentieren und die vorgeschlagenen Änderungen diskutieren, aber auch allgemeine Kommentare abgeben.\nFalls möglich, sollte man einen MR/PR immer dem Entwickler zuweisen, der sich weiter um diesen MR/PR kümmern wird (also zunächst ist man das erstmal selbst). Zusätzlich kann man einen Reviewer bestimmen, d.h. wer soll sich den Code ansehen.\nHier ein Screenshot der Änderungsansicht unseres Gitlab-Servers (SW-Labor):\nNachfolgend für den selben MR aus der letzten Abbildung noch die reine Diskussionsansicht:\nBest Practices bei Merge-/Pull-Requests MR/PR so zeitig wie möglich aufmachen Am besten sofort, wenn ein neuer Branch auf den Server gepusht wird! Ggf. mit dem Präfix \"WIP\" im Titel gegen unbeabsichtigtes vorzeitiges Mergen sperren ... (bei GitHub als \"Draft\"-PR öffnen) Auswahl Start- und Ziel-Branch (und ggf. Ziel-Repo) Es gibt verschiedene Stellen, um einen MR/PR zu erstellen. Manchmal kann man nur noch den Ziel-Branch einstellen, manchmal beides. Bitte auch darauf achten, welches Ziel-Repo eingestellt ist! Bei Forks wird hier immer das Original-Repo voreingestellt! Den Ziel-Branch kann man ggf. auch nachträglich durch Editieren des MR/PR anpassen (Start-Branch und Ziel-Repo leider nicht, also beim Erstellen aufpassen!). Titel (Summary): Das ist das, was man in der Übersicht sieht! Per Default wird die letzte Commit-Message eingesetzt. Analog zur Commit-Message: Bitte hier unbedingt einen sinnvollen Titel einsetzen: Was macht der MR/PR (kurz)? Beschreibung: Was passiert, wenn man diesen MR/PR akzeptiert (ausführlicher)? Analog zur Commit-Message sollte hier bei Bedarf die Summary ausformuliert werden und beschreiben, was der MR/PR ändert. Assignee: Wer soll sich drum kümmern? Ein MR/PR sollte immer jemanden zugewiesen sein, d.h. nicht \"unassigned\" sein. Ansonsten ist nicht klar, wer den Request durchführen/akzeptieren soll. Außerdem taucht ein nicht zugewiesener MR/PR nicht in der Übersicht \"meiner\" MR/PR auf, d.h. diese MR/PR haben die Tendenz, vergessen zu werden! Diskussion am (und neben) dem Code Nur die vorgeschlagenen Code-Änderungen diskutieren! Weitergehende Diskussionen (etwa über Konzepte o.ä.) besser in separaten Issues erledigen, da sonst die Anzeige des MR/PR langsam wird (ist beispielsweise ein Problem bei Gitlab). Weitere Commits auf dem zu mergenden Branch gehen automatisch mit in den Request Weitere Entwickler kann man mit \"@username\" in einem Kommentar auf \"CC\" setzen und in die Diskussion einbinden Anmerkung: Bei Gitlab (d.h. auch bei dem Gitlab-Server im SW-Labor) gibt es \"Merge-Requests\" (MR). Bei Github gibt es \"Pull-Requests\" (PR) ...\nWrap-Up Git-Workflows für die Zusammenarbeit:\neinfacher zentraler Ansatz für kleine Arbeitsgruppen vs. einfacher verteilter Ansatz mit einem \"blessed\" Repo (häufig in Open-Source-Projekten zu finden) Aktualisieren Ihres Clones und Ihres Forks mit Änderungen aus dem \"blessed\" Repo\nUnterschied zwischen einem Pull/Merge und einem Pull/Rebase\nErstellen von Beiträgen zu einem Projekt über Merge-Requests\nWelche Commits werden Bestandteil eines Merge-Requests (und warum) Diskussion über den Code in Merge-Requests",
    "description": "Nutzung von Git in Projekten: Verteiltes Git (und Workflows) Git ermöglicht ein einfaches und schnelles Branchen. Dies kann man mit entsprechenden Branching-Strategien sinnvoll für die SW-Entwicklung einsetzen.\nAuf der anderen Seite ermöglicht Git ein sehr einfaches verteiltes Arbeiten. Auch hier ergeben sich verschiedene Workflows, wie man mit anderen Entwicklern an einem Projekt arbeiten will/kann.\nIm Folgenden sollen also die Frage betrachtet werden: Wie gestalte ich die Zusammenarbeit? Antwort: Workflows mit Git ...",
    "tags": [],
    "title": "Zusammenarbeit: Git-Workflows und Merge-/Pull-Requests",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/git/workflows.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Modern Java",
    "content": "Motivation Es wurden Studis, Studiengänge und Fachbereiche modelliert (aus Gründen der Übersichtlichkeit einfach als Record-Klassen).\nNun soll pro Fachbereich die Anzahl der Studis ermittelt werden, die bereits 100 ECTS oder mehr haben. Dazu könnte man über alle Studiengänge im Fachbereich iterieren, und in der inneren Schleife über alle Studis im Studiengang. Dann filtert man alle Studis, deren ECTS größer 100 sind und erhöht jeweils den Zähler:\npublic record Studi(String name, int credits) {} public record Studiengang(String name, List\u003cStudi\u003e studis) {} public record Fachbereich(String name, List\u003cStudiengang\u003e studiengaenge) {} private static long getCountFB(Fachbereich fb) { long count = 0; for (Studiengang sg : fb.studiengaenge()) { for (Studi s : sg.studis()) { if (s.credits() \u003e 100) count += 1; } } return count; } Dies ist ein Beispiel, welches klassisch in OO-Manier als Iteration über Klassen realisiert ist. (Inhaltlich ist es vermutlich nicht sooo sinnvoll.)\nInnere Schleife mit Streams umgeschrieben private static long getCountSG(Studiengang sg) { return sg.studis().stream() .map(Studi::credits) .filter(c -\u003e c \u003e 100) .count(); } private static long getCountFB2(Fachbereich fb) { long count = 0; for (Studiengang sg : fb.studiengaenge()) { count += getCountSG(sg); } return count; } Erklärung des Beispiels Im Beispiel wurde die innere Schleife in einen Stream ausgelagert.\nMit der Methode Collection#stream() wird aus der Collection ein neuer Stream erzeugt. Auf diesem wird für jedes Element durch die Methode map() die Methode Studi#credits() angewendet, was aus einem Strom von Studi einen Strom von Integer macht. Mit filter() wird auf jedes Element das Prädikat c -\u003e c \u003e 100 angewendet und alle Elemente aus dem Strom entfernt, die der Bedingung nicht entsprechen. Am Ende wird mit count() gezählt, wie viele Elemente im Strom enthalten sind.\nWas ist ein Stream? Ein \"Stream\" ist ein Strom (Folge) von Daten oder Objekten. In Java wird die Collections-API für die Speicherung von Daten (Objekten) verwendet. Die Stream-API dient zur Iteration über diese Daten und entsprechend zur Verarbeitung der Daten. In Java speichert ein Stream keine Daten.\nDas Konzept kommt aus der funktionalen Programmierung und wurde in Java nachträglich eingebaut (wobei dieser Prozess noch lange nicht abgeschlossen zu sein scheint).\nIn der funktionalen Programmierung kennt man die Konzepte \"map\", \"filter\" und \"reduce\": Die Funktion \"map()\" erhält als Parameter eine Funktion und wendet diese auf alle Elemente eines Streams an. Die Funktion \"filter()\" bekommt ein Prädikat als Parameter und prüft jedes Element im Stream, ob es dem Prädikat genügt (also ob das Prädikat mit dem jeweiligen Element zu true evaluiert - die anderen Objekte werden entfernt). Mit \"reduce()\" kann man Streams zu einem einzigen Wert zusammenfassen (denken Sie etwa an das Aufsummieren aller Elemente eines Integer-Streams). Zusätzlich kann man in der funktionalen Programmierung ohne Probleme unendliche Ströme darstellen: Die Auswertung erfolgt nur bei Bedarf und auch dann auch nur so weit wie nötig. Dies nennt man auch \"lazy evaluation\".\nDie Streams in Java versuchen, diese Konzepte aus der funktionalen Programmierung in die objektorientierte Programmierung zu übertragen. Ein Stream in Java hat eine Datenquelle, von wo die Daten gezogen werden - ein Stream speichert selbst keine Daten. Es gibt \"intermediäre Operationen\" auf einem Stream, die die Elemente verarbeiten und das Ergebnis als Stream zurückliefern. Daraus ergibt sich typische Pipeline-artige Verkettung der Operationen. Allerdings werden diese Operationen erst durchgeführt, wenn eine \"terminale Operation\" den Stream \"abschließt\". Ein Stream ohne eine terminale Operation macht also tatsächlich nichts.\nDie Operationen auf dem Stream sind üblicherweise zustandslos, können aber durchaus auch einen Zustand haben. Dies verhindert üblicherweise die parallele Verarbeitung der Streams. Operationen sollten aber nach Möglichkeit keine Seiteneffekte haben, d.h. keine Daten außerhalb des Streams modifizieren. Operationen dürfen auf keinen Fall die Datenquelle des Streams modifizieren!\nErzeugen von Streams List\u003cString\u003e l1 = List.of(\"Hello\", \"World\", \"foo\", \"bar\", \"wuppie\"); Stream\u003cString\u003e s1 = l1.stream(); Stream\u003cString\u003e s2 = Stream.of(\"Hello\", \"World\", \"foo\", \"bar\", \"wuppie\"); Random random = new Random(); Stream\u003cInteger\u003e s3 = Stream.generate(random::nextInt); Pattern pattern = Pattern.compile(\" \"); Stream\u003cString\u003e s4 = pattern.splitAsStream(\"Hello world! foo bar wuppie!\"); Dies sind möglicherweise die wichtigsten Möglichkeiten, in Java einen Stream zu erzeugen.\nAusgehend von einer Klasse aus der Collection-API kann man die Methode Collection#stream() aufrufen und bekommt einen seriellen Stream.\nAlternativ bietet das Interface Stream verschiedene statische Methoden wie Stream.of() an, mit deren Hilfe Streams angelegt werden können. Dies funktioniert auch mit Arrays ...\nUnd schließlich kann man per Stream.generate() einen Stream anlegen, wobei als Argument ein \"Supplier\" (Interface java.util.function.Supplier\u003cT\u003e) übergeben werden muss. Dieses Argument wird dann benutzt, um die Daten für den Stream zu generieren.\nWenn man aufmerksam hinschaut, findet man an verschiedensten Stellen die Möglichkeit, die Daten per Stream zu verarbeiten, u.a. bei regulären Ausdrücken.\nMan kann per Collection#parallelStream() auch parallele Streams erzeugen, die intern das \"Fork\u0026Join-Framework\" nutzen. Allerdings sollte man nur dann parallele Streams anlegen, wenn dadurch tatsächlich Vorteile durch die Parallelisierung zu erwarten sind (Overhead!).\nIntermediäre Operationen auf Streams private static void dummy(Studiengang sg) { sg.studis().stream() .peek(s -\u003e System.out.println(\"Looking at: \" + s.name())) .map(Studi::credits) .peek(c -\u003e System.out.println(\"This one has: \" + c + \" ECTS\")) .filter(c -\u003e c \u003e 5) .peek(c -\u003e System.out.println(\"Filtered: \" + c)) .sorted() .forEach(System.out::println); } An diesem (weitestgehend sinnfreien) Beispiel werden einige intermediäre Operationen demonstriert.\nDie Methode peek() liefert einen Stream zurück, die aus den Elementen des Eingabestroms bestehen. Auf jedes Element wird die Methode void accept(T) des Consumer\u003cT\u003e angewendet (Argument der Methode), was aber nicht zu einer Änderung der Daten führt. Hinweis: Diese Methode dient vor allem zu Debug-Zwecken! Durch den Seiteneffekt kann die Methode eine schlechtere Laufzeit zur Folge haben oder sogar eine sonst mögliche parallele Verarbeitung verhindern oder durch eine parallele Verarbeitung verwirrende Ergebnisse zeigen!\nDie Methode map() liefert ebenfalls einen Stream zurück, der durch die Anwendung der Methode R apply(T) der als Argument übergebenen Function\u003cT,R\u003e auf jedes Element des Eingabestroms entsteht. Damit lassen sich die Elemente des ursprünglichen Streams verändern; für jedes Element gibt es im Ergebnis-Stream ebenfalls ein Element (der Typ ändert sich, aber nicht die Anzahl der Elemente).\nMit der Methode filter() wird ein Stream erzeugt, der alle Objekte des Eingabe-Streams enthält, auf denen die Anwendung der Methode boolean test(T) des Arguments Predicate\u003cT\u003e zu true evaluiert (der Typ und Inhalt der Elemente ändert sich nicht, aber die Anzahl der Elemente).\nMit sorted() wird ein Stream erzeugt, der die Elemente des Eingabe-Streams sortiert (existiert auch mit einem Comparator\u003cT\u003e als Parameter).\nDiese Methoden sind alles intermediäre Operationen. Diese arbeiten auf einem Stream und erzeugen einen neuen Stream und werden erst dann ausgeführt, wenn eine terminale Operation den Stream abschließt.\nDabei sind die gezeigten intermediären Methoden bis auf sorted() ohne inneren Zustand. sorted() ist eine Operation mit innerem Zustand (wird für das Sortieren benötigt). Dies kann ordentlich in Speicher und Zeit zuschlagen und u.U. nicht/nur schlecht parallelisierbar sein. Betrachten Sie den fiktiven parallelen Stream stream.parallel().sorted().skip(42): Hier müssen erst alle Elemente sortiert werden, bevor mit skip(42) die ersten 42 Elemente entfernt werden. Dies kann auch nicht mehr parallel durchgeführt werden.\nDie Methode forEach() schließlich ist eine terminale Operation, die auf jedes Element des Eingabe-Streams die Methode void accept(T) des übergebenen Consumer\u003cT\u003e anwendet. Diese Methode ist eine terminale Operation, d.h. sie führt zur Auswertung der anderen intermediären Operationen und schließt den Stream ab.\nWas tun, wenn eine Methode Streams zurückliefert Wir konnten vorhin nur die innere Schleife in eine Stream-basierte Verarbeitung umbauen. Das Problem ist: Die äußere Schleife würde einen Stream liefern (Stream von Studiengängen), auf dem wir die map-Funktion anwenden müssten und darin dann für jeden Studiengang einen (inneren) Stream mit den Studis eines Studiengangs verarbeiten müssten.\nprivate static long getCountSG(Studiengang sg) { return sg.studis().stream().map(Studi::credits).filter(c -\u003e c \u003e 100).count(); } private static long getCountFB2(Fachbereich fb) { long count = 0; for (Studiengang sg : fb.studiengaenge()) { count += getCountSG(sg); } return count; } Dafür ist die Methode flatMap() die Lösung. Diese Methode bekommt als Argument ein Objekt vom Typ Function\u003c? super T, ? extends Stream\u003c? extends R\u003e\u003e mit einer Methode Stream\u003c? extends R\u003e apply(T). Die Methode flatMap() verarbeitet den Stream in zwei Schritten:\nMappe über alle Elemente des Eingabe-Streams mit der Funktion. Im Beispiel würde also aus einem Stream\u003cStudiengang\u003e jeweils ein Stream\u003cStream\u003cStudi\u003e\u003e, also alle Studiengang-Objekte werden durch je ein Stream\u003cStudi\u003e-Objekt ersetzt. Wir haben jetzt also einen Stream von Stream\u003cStudi\u003e-Objekten.\n\"Klopfe den Stream wieder flach\", d.h. nimm die einzelnen Studi-Objekte aus den Stream\u003cStudi\u003e-Objekten und setze diese stattdessen in den Stream. Das Ergebnis ist dann wie gewünscht ein Stream\u003cStudi\u003e (Stream mit Studi-Objekten).\nprivate static long getCountFB3(Fachbereich fb) { return fb.studiengaenge().stream() .flatMap(sg -\u003e sg.studis().stream()) .map(Studi::credits) .filter(c -\u003e c \u003e 100) .count(); } Zum direkten Vergleich hier noch einmal der ursprüngliche Code mit zwei verschachtelten Schleifen und entsprechenden Hilfsvariablen:\nprivate static long getCountFB(Fachbereich fb) { long count = 0; for (Studiengang sg : fb.studiengaenge()) { for (Studi s : sg.studis()) { if (s.credits() \u003e 100) count += 1; } } return count; } Streams abschließen: Terminale Operationen Stream\u003cString\u003e s = Stream.of(\"Hello\", \"World\", \"foo\", \"bar\", \"wuppie\"); long count = s.count(); s.forEach(System.out::println); String first = s.findFirst().get(); Boolean b = s.anyMatch(e -\u003e e.length() \u003e 3); List\u003cString\u003e s1 = s.collect(Collectors.toList()); List\u003cString\u003e s2 = s.toList(); // ab Java16 Set\u003cString\u003e s3 = s.collect(Collectors.toSet()); List\u003cString\u003e s4 = s.collect(Collectors.toCollection(LinkedList::new)); Streams müssen mit einer terminalen Operation abgeschlossen werden, damit die Verarbeitung tatsächlich angestoßen wird (lazy evaluation).\nEs gibt viele verschiedene terminale Operationen. Wir haben bereits count() und forEach() gesehen. In der Sitzung zu “Optionals” werden wir noch findFirst() näher kennenlernen.\nDaneben gibt es beispielsweise noch allMatch(), anyMatch() und noneMatch(), die jeweils ein Prädikat testen und einen Boolean zurückliefern (matchen alle, mind. eines oder keines der Objekte im Stream).\nMit min() und max() kann man sich das kleinste und das größte Element des Streams liefern lassen. Beide Methoden benötigen dazu einen Comparator\u003cT\u003e als Parameter.\nMit der Methode collect() kann man eine der drei Methoden aus Collectors über den Stream laufen lassen und eine Collection erzeugen lassen:\ntoList() sammelt die Elemente in ein List-Objekt (bzw. direkt mit stream.toList() (ab Java16)) toSet() sammelt die Elemente in ein Set-Objekt toCollection() sammelt die Elemente durch Anwendung der Methode T get() des übergebenen Supplier\u003cT\u003e-Objekts auf Die ist nur die sprichwörtliche \"Spitze des Eisbergs\"! Es gibt viele weitere Möglichkeiten, sowohl bei den intermediären als auch den terminalen Operationen. Schauen Sie in die Dokumentation!\nDemo: streams.Demo Spielregeln Operationen dürfen nicht die Stream-Quelle modifizieren\nOperationen können die Werte im Stream ändern (map) oder die Anzahl (filter)\nKeine Streams in Attributen/Variablen speichern oder als Argumente übergeben: Sie könnten bereits \"gebraucht\" sein!\n=\u003e Ein Stream sollte immer sofort nach der Erzeugung benutzt werden\nOperationen auf einem Stream sollten keine Seiteneffekte (Veränderungen von Variablen/Attributen außerhalb des Streams) haben (dies verhindert u.U. die parallele Verarbeitung)\nWrap-Up Stream\u003cT\u003e: Folge von Objekten vom Typ T, Verarbeitung \"lazy\" (Gegenstück zu Collection\u003cT\u003e: Dort werden Daten gespeichert, hier werden Daten verarbeitet)\nNeuen Stream anlegen: Collection#stream() oder Stream.of() ...\nIntermediäre Operationen: peek(), map(), flatMap(), filter(), sorted() ...\nTerminale Operationen: count(), forEach(), allMatch(), collect() ...\ncollect(Collectors.toList()) collect(Collectors.toSet()) collect(Collectors.toCollection()) (mit Supplier\u003cT\u003e) Streams speichern keine Daten\nIntermediäre Operationen laufen erst bei Abschluss des Streams los\nTerminale Operation führt zur Verarbeitung und Abschluss des Streams\nSchöne Doku: \"The Stream API\", und auch \"Package java.util.stream\".",
    "description": "Motivation Es wurden Studis, Studiengänge und Fachbereiche modelliert (aus Gründen der Übersichtlichkeit einfach als Record-Klassen).\nNun soll pro Fachbereich die Anzahl der Studis ermittelt werden, die bereits 100 ECTS oder mehr haben. Dazu könnte man über alle Studiengänge im Fachbereich iterieren, und in der inneren Schleife über alle Studis im Studiengang. Dann filtert man alle Studis, deren ECTS größer 100 sind und erhöht jeweils den Zähler:\npublic record Studi(String name, int credits) {} public record Studiengang(String name, List\u003cStudi\u003e studis) {} public record Fachbereich(String name, List\u003cStudiengang\u003e studiengaenge) {} private static long getCountFB(Fachbereich fb) { long count = 0; for (Studiengang sg : fb.studiengaenge()) { for (Studi s : sg.studis()) { if (s.credits() \u003e 100) count += 1; } } return count; } Dies ist ein Beispiel, welches klassisch in OO-Manier als Iteration über Klassen realisiert ist. (Inhaltlich ist es vermutlich nicht sooo sinnvoll.)",
    "tags": [],
    "title": "Stream-API",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/modern-java/stream-api.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Modern Java",
    "content": "Motivation; Klasse Studi public class Studi { private final String name; private final int credits; public Studi(String name, int credits) { this.name = name; this.credits = credits; } public String getName() { return name; } public int getCredits() { return credits; } } Klasse Studi als Record public record StudiR(String name, int credits) {} Immutable Klasse mit Feldern String name und int credits =\u003e \"(String name, int credits)\" werden \"Komponenten\" des Records genannt\nStandardkonstruktor setzt diese Felder (\"Kanonischer Konstruktor\")\nGetter für beide Felder:\npublic String name() { return this.name; } public int credits() { return this.credits; } Record-Klassen wurden in Java14 eingeführt und werden immer wieder in neuen Releases erweitert/ergänzt.\nDer kanonische Konstruktor hat das Aussehen wie die Record-Deklaration, im Beispiel also public StudiR(String name, int credits). Dabei werden die Komponenten über eine Kopie der Werte initialisiert.\nFür die Komponenten werden automatisch private Attribute mit dem selben Namen angelegt.\nFür die Komponenten werden automatisch Getter angelegt. Achtung: Die Namen entsprechen denen der Komponenten, es fehlt also der übliche \"get\"-Präfix!\nEigenschaften und Einschränkungen von Record-Klassen Records erweitern implizit die Klasse java.lang.Record: Keine andere Klassen mehr erweiterbar! (Interfaces kein Problem)\nRecord-Klassen sind implizit final\nKeine weiteren (Instanz-) Attribute definierbar (nur die Komponenten)\nKeine Setter definierbar für die Komponenten: Attribute sind final\nStatische Attribute mit Initialisierung erlaubt\nRecords: Prüfungen im Konstruktor Der Konstruktor ist erweiterbar:\npublic record StudiS(String name, int credits) { public StudiS(String name, int credits) { if (name == null) { throw new IllegalArgumentException(\"Name cannot be null!\"); } else { this.name = name; } if (credits \u003c 0) { this.credits = 0; } else { this.credits = credits; } } } In dieser Form muss man die Attribute selbst setzen.\nAlternativ kann man die \"kompakte\" Form nutzen:\npublic record StudiT(String name, int credits) { public StudiT { if (name == null) { throw new IllegalArgumentException(\"Name cannot be null!\"); } if (credits \u003c 0) { credits = 0; } } } In der kompakten Form kann man nur die Werte der Parameter des Konstruktors ändern. Das Setzen der Attribute ergänzt der Compiler nach dem eigenen Code.\nEs sind weitere Konstruktoren definierbar, diese müssen den kanonischen Konstruktor aufrufen:\npublic StudiT() { this(\"\", 42); } Getter und Methoden Getter werden vom Compiler automatisch generiert. Dabei entsprechen die Methoden-Namen den Namen der Attribute:\npublic record StudiR(String name, int credits) {} public static void main(String... args) { StudiR r = new StudiR(\"Sabine\", 75); int x = r.credits(); String y = r.name(); } Getter überschreibbar und man kann weitere Methoden definieren:\npublic record StudiT(String name, int credits) { public int credits() { return credits + 42; } public void wuppie() { System.out.println(\"WUPPIE\"); } } Die Komponenten/Attribute sind aber final und können nicht über Methoden geändert werden!\nBeispiel aus den Challenges In den Challenges zum Thema Optional gibt es die Klasse Katze in den Vorgaben.\nDie Katze wurde zunächst \"klassisch\" modelliert: Es gibt drei Eigenschaften name, gewichtund lieblingsBox. Ein Konstruktor setzt diese Felder und es gibt drei Getter für die einzelnen Eigenschaften. Das braucht 18 Zeilen Code (ohne Kommentare Leerzeilen). Zudem erzeugt der Boilerplate-Code relativ viel \"visual noise\", so dass der eigentliche Kern der Klasse schwerer zu erkennen ist.\nIn einem Refactoring wurde diese Klasse durch eine äquivalente Record-Klasse ersetzt, die nur noch 2 Zeilen Code (je nach Code-Style auch nur 1 Zeile) benötigt. Gleichzeitig wurde die Les- und Wartbarkeit deutlich verbessert.\nWrap-Up Records sind immutable Klassen: final Attribute (entsprechend den Komponenten) Kanonischer Konstruktor Automatische Getter (Namen wie Komponenten) Konstruktoren und Methoden können ergänzt/überschrieben werden Keine Vererbung von Klassen möglich (kein extends) Schöne Doku: \"Using Record to Model Immutable Data\".",
    "description": "Motivation; Klasse Studi public class Studi { private final String name; private final int credits; public Studi(String name, int credits) { this.name = name; this.credits = credits; } public String getName() { return name; } public int getCredits() { return credits; } } Klasse Studi als Record public record StudiR(String name, int credits) {} Immutable Klasse mit Feldern String name und int credits =\u003e \"(String name, int credits)\" werden \"Komponenten\" des Records genannt\nStandardkonstruktor setzt diese Felder (\"Kanonischer Konstruktor\")",
    "tags": [],
    "title": "Record-Klassen",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/modern-java/records.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024)",
    "content": "Frameworks: How-To Dungeon",
    "description": "Frameworks: How-To Dungeon",
    "tags": [],
    "title": "Umgang mit Frameworks",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/frameworks.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Frameworks",
    "content": "How-To Dungeon In diesem Semester werden Sie im Praktikum schrittweise Erweiterungen in verschiedenen \"fertigen\" Rogue-like Computerspielen programmieren und dabei (hoffentlich) die Methoden aus der Vorlesung einsetzen können.\nDas Projekt \"PM-Dungeon\" stellt wichtige Bausteine für das Spiel bereit, beispielsweise eine Game-Loop und eine API für das Generieren und Benutzen von Leveln und vieles andere mehr. Im Hintergrund werkelt das etablierte Open-Source-Spieleframework libGDX.\nWir werden uns in diesem How-To einen Überblick verschaffen und einen ersten Einstieg versuchen: Wir programmieren einen einfachen Helden.\nProjekt PM-Dungeon Das Projekt PM-Dungeon entstand in verschiedenen Forschungsprojekten und wurde (und wird) aktiv von Studierenden und wissenschaftlichen Mitarbeitern am Campus Minden entwickelt.\nZuletzt lief das Forschungsprojekt \"Dungeon\", gefördert durch die Stiftung für Innovation in der Hochschullehre im \"Freiraum 2022\". Dabei sollten diesmal nicht die Studierenden selbst Code schreiben, sondern die Lehrenden sollen Aufgaben in einer speziellen (von uns entwickelten) Programmiersprache schreiben (können), woraus dann ein fertiges Dungeon-Spiel generiert wird (mit der Aufgabe als Quest o.ä. im Dungeon eingebettet) und die Studierenden können durch das Spielen die Aufgaben lösen.\nSie werden merken, dass trotz klarer Richtlinien und Ideen die Entwicklung in der Praxis doch nicht so einfach ist und dass viele Dinge immer wieder geübt und erinnert werden müssen: Namen von Klassen und Methoden, sinnvolles Javadoc, Dokumentation jenseits des Javadoc, aber auch Commit-Messages und PR-Summaries.\nInstallation des Frameworks Sie finden das Projekt auf GitHub: github.com/Dungeon-CampusMinden/Dungeon.\nLaden Sie sich den Quellcode herunter, um damit in der IDE arbeiten zu können. Prinzipiell gibt es viele verschiedene Wege, in diesem Tutorial laden wir es per Git in der Konsole herunter:\ngit clone git@github.com:Dungeon-CampusMinden/Dungeon.git pm-dungeon Dabei entsteht der Ordner pm-dungeon/ mit dem Dungeon-Projekt als Inhalt.\nWICHTIG: Achten Sie bitte darauf, dass im Projektpfad keine Leerzeichen und keine Sonderzeichen (Umlaute o.ä.) vorkommen! Dies kann zu seltsamen Fehler führen. Bitte auch darauf achten, dass Sie als JDK ein Java SE 21 (LTS) verwenden.\nJava: Java SE 21 (LTS) Wir benutzen im Dungeon-Projekt die aktuelle LTS-Version des JDK, d.h. Java SE 21 (LTS). Sie können sich das JDK bei Oracle herunterladen oder Alternativen ausprobieren. Bitte unbedingt die jeweilige 64-bit Version nutzen!\nIn der Konsole sollte\njava -version ungefähr diese Ausgabe erzeugen (ignorieren Sie die Minor-Version, wichtig ist Major-Version: 21 bzw. \"LTS\"):\njava version \"21.0.3\" 2024-04-16 LTS Java(TM) SE Runtime Environment (build 21.0.3+7-LTS-152) Java HotSpot(TM) 64-Bit Server VM (build 21.0.3+7-LTS-152, mixed mode, sharing) Erster Test Für einen ersten Test gehen Sie in der Konsole in den vorhin erzeugten neuen Ordner pm-dungeon/ und führen Sie dort den Befehl\n./gradlew game:runBasicStarter aus. Dabei sollte das (mitgelieferte) Build-Tool Gradle starten und die benötigten Java-Bibliotheken herunterladen und schließlich das Spiel in einer Minimalversion starten - Sie sollten also ein Level sehen.\nDies dauert je nach Internetanbindung etwas - beim nächsten Start geht es dann aber deutlich schneller, weil ja bereits alles da ist.\nImport in der IDE Importieren Sie das Projekt als Gradle-basiertes Projekt, dann übernimmt die IDE die Konfiguration für Sie.\nÜber das Gradle-Menü können Sie nun in der IDE den \"runBasicStarter\"-Task (Menüpunkt \"game\") starten, und es erscheint wieder ein minimales Level.\nÜberblick über die (Sub-) Projekte Sie finden im Package-Explorer eine Reihe von Unterprojekten (Gradle-Subprojekte). Für PR2 sind eigentlich nur die Subprojekte \"dojo-dungeon\" und \"devDungeon\" relevant sowie die Dokumentation in den verschiedenen doc/-Ordnern (die derzeit leider noch eine ziemliche Baustelle ist).\nDojo-Dungeon und DevDungeon stellen zwei verschiedene (mehr oder weniger fertige) Spiele dar, die von Studierenden erstellt wurden (Dojo-Dungeon: @Denniso3, @tgrothe und @JudiTeller; DevDungeon: @Flamtky). Diese Spiele nutzen wir an einigen Stellen im Praktikum.\nDie Basis für die beiden Spiele stellt das Dungeon-Framework dar, welches in den Gradle-Subprojekten \"game\" und \"dungeon\" zu finden ist. Game stellt dabei eine Art minimale Basis zum Programmieren eigener Spiele dar (alle Klassen im Package core), und Dungeon erweitert diese Basis und fügt einige häufig benötigte Elemente und weitere Texturen (Package contrib) hinzu. Zusätzlich gibt es hier noch einige Klassen für die DSL, was für PR2 aber nicht relevant ist.\nDas Subprojekt \"blockly\" ist die Einbindung einer blockbasierten Programmiersprache in das Dungeon-Framework und spielt für PR2 ebenfalls keine Rolle.\nDie Strukturen in allen Sub-Projekten ist ähnlich: Sie finden unter \u003csubproject\u003e/src/ die Java-Packages und in \u003csubproject\u003e/assets/ vordefinierte Texturen und Soundfiles sowie Crafting-Rezepte (beispielsweise für Boden, Wände und den Hero). Alle Sourcen sind (mehr oder weniger) mit Javadoc dokumentiert, zusätzlich gibt es jeweils in \u003csubproject\u003e/doc/ weitere Anleitungen und Hinweise.\nFür die Aufgaben im Praktikum starten Sie am besten zunächst beim relevanten Code in den Sub-Projekten Dojo-Dungeon und DevDungeon. Schauen Sie sich die für die Aufgabe benutzten Klassen und deren Javadoc an. In der Regel nutzen diese auch Klassen aus Dungeon und Game, deren Aufbau und Javadoc Sie sich ebenfalls anschauen sollten. Zusätzlich gibt es für Game und Dungeon noch weitere Dokumentation in den doc/-Ordnern.\nÜberblick über die Java-Strukturen Jedes Spiel besteht aus einer Game-Loop, die je nach Konfiguration 30 Mal oder 60 Mal pro Sekunde ausgeführt wird. Diese Game-Loop wird mit Hilfe der Game#run()-Methode gestartet und die Kontrolle geht dabei vollständig an libGDX über. Im Wesentlichen werden pro Durchlauf (\"Frame\") die Aktionen berechnet und das Spielfeld neu gezeichnet. Alle Aktionen im Spiel, etwa das Bewegen von Spielelementen oder das Berechnen von Angriffen o.ä., werden über sogenannte Systeme berechnet. Diese werden einmal pro Frame aufgerufen und bestimmen den neuen Zustand (Position, Animation, Stats, ...) der Spielelemente, die dann beim nächsten Rendern im Spiel angezeigt werden.\nDie Klasse core.Game ist der zentrale Einstiegspunkt. Hier werden alle wichtigen Dinge konfiguriert, und es gibt die Game#run()-Methode, die das Spiel startet. Zusätzlich gibt es weitere Methoden, die für Sie relevant sind:\nGame#userOnSetup(): Diese Methode wird einmal beim Start des Spiels aufgerufen und kann für die Konfiguration und Initialisierung der verschiedenen Systeme genutzt werden. Hier wird beispielsweise u.a. auch das erste Level geladen. Game#userOnFrame(): Diese Methode wird zu Beginn eines jeden Frame aufgerufen, noch bevor die execute()-Methode der verschiedenen Systeme aufgerufen wird. Game#userOnLevelLoad(): Diese Methode wird aufgerufen, wenn ein Level geladen wird. Hier können Sie später die Entitäten erstellen, die initial im Level verteilt werden sollen. Es gibt noch eine ganze Reihe von Packages, beispielsweise core.Component mit verschiedenen wichtigen Components oder core.level mit Klassen zum Generieren zufälliger neuer Level und zum Laden und zum Zugriff (wo bin ich und warum?) oder core.systems mit den Systemen, die bestimmte Dinge im Spiel managen. Die Gliederung in Entitäten (entities), Komponenten (components) und Systeme (systems) nennt sich auch \"ECS-Architektur\" (zu ECS später mehr).\nSie finden im \"Quickstart: How to Dungeon\" eine gute Anleitung, die auf die Strukturen tiefer eingeht.\nMein Held Um einen besseren Blick in das System zu bekommen, erstellen wir schrittweise einen eigenen einfachen Helden.\nLegen Sie sich im starter-Package eine neue Klasse an, mit der Sie das Spiel konfigurieren und starten können:\npackage starter; import core.Game; public class Main { public static void main(String... args) { // Start the game loop Game.run(); } } In IntelliJ können Sie nun die main()-Funktion direkt ausführen, dazu wird im Hintergrund die vorhandene Gradle-Konfiguration genutzt. Mit anderen IDEs funktioniert das vielleicht nicht direkt, dann erweitern Sie einfach die Gradle-Konfiguration um einen entsprechenden Task:\ntasks.register('run', JavaExec) { mainClass = 'starter.Main' classpath = sourceSets.main.runtimeClasspath } Einschub: ECS oder Entities, Components und Systems Der Held ist ein Element im Spiel. Diese Struktur muss geeignet modelliert werden.\nUnser Dungeon implementiert dabei eine Variante eines Entity Component System (ECS) und folgt damit \"großen Vorbildern\" wie beispielsweise Unity.\nNeben verschiedenen Hilfsstrukturen gibt es dabei nur Entitäten, Komponenten und Systeme. Hier werden sämtliche Informationen und Verhalten modelliert.\nEntity Die Idee dahinter ist: Alle Elemente im Spiel werden als Entität realisiert, d.h. der Held und die Monster und die Items, die man so finden kann, sind alles Entitäten. Sogar Feuerbälle sind letztlich Entitäten. (Im Prinzip könnten sogar die Boden- und Wandkacheln Entitäten sein - sind es aus Effizienzgründen aktuell aber nicht.)\nEine Entität an sich kann erst einmal nichts und dient nur als Container für Components.\nDas Spiel kennt alle zu einem Zeitpunkt vorhandenen Entitäten, diese müssen per Game#add registriert werden. Man kann die Entitäten über die API abrufen (Game#allEntities, Game#find und Game#hero).\nUnsere Basisklasse für Entitäten ist aktuell core.Entity.\nComponent Components bündeln bestimmte Werte einer Entität für bestimmte Zwecke, d.h. statt der Attribute in einer Klasse (Entität) nutzen wir hier eine weitere Kapselung.\nBeispielsweise könnte man die Lebenspunkte u.ä. in einer HealthComponent verpacken und dann in einer Entität speichern. Oder man könnte in einer VelocityComponent hinterlegen, wie schnell eine Entität in x- und in y-Richtung bewegt werden kann (Wände würden dabei einfach den Wert 0 bekommen). Oder man könnte in einer PositionComponent speichern, wo die Entität gerade ist. Schauen Sie einfach mal in die Packages core.components und contrib.components.\nWichtig ist: Eine Instanz einer Component ist immer an eine Entität gekoppelt, eine Component ohne (Bindung an eine) Entität ist sinnfrei. Andersherum kann eine Entität immer nur eine einzige Instanz einer bestimmten Component (eines Component-Typs) haben, also beispielsweise nicht zwei Objekte vom Typ PositionComponent.\nComponents speichern vor allem Werte und haben nur in Ausnahmefällen eigenes Verhalten.\nDas Basisinterface für Components ist derzeit core.Component.\nSystem Mit Entitäten und passenden Components, über die wir die Eigenschaften ausdrücken, können wir bereits Spielelemente im Dungeon repräsentieren.\nFür die Bewegung und Interaktion sorgen nun passende Systeme. Das Spiel kennt alle Systeme (diese werden einmal beim Start im Spiel per Game#add registriert) und ruft in der Game-Loop pro Frame deren execute()-Methode auf. In der Regel iterieren die Systeme beim Ausführen der execute()-Methode über die Entitäten des Spiels (via Game#allEntities), suchen sich Entitäten mit bestimmten Components heraus und bearbeiten den Zustand dieser Components.\nDabei könnte beispielsweise ein HealthSystem sich alle Entitäten filtern, deren HealthComponent unterhalb einer kritischen Schwelle liegen und diese rot anmalen lassen, d.h. in der DrawComponent wird die Textur (\"Animation\") ausgetauscht. Oder ein PlayerSystem könnte dafür sorgen, dass die Eingaben auf der Tastatur geeignet an den Helden weitergegeben werden und (über andere Systeme) in eine Bewegung oder Kampf o.ä. umgewandelt werden.\nSie finden unsere Systeme in den Packages core.systems und contrib.systems, und die Basisklasse ist derzeit core.System - falls Sie einmal eigene Systeme implementieren wollen. (vgl. auch Doku)\nNun aber Helden! Ein Held ist eine Entität Also legen wir nun endlich einen neuen Helden als Instanz von core.Entity an und registrieren diese Entität im Spiel:\npublic class Main { public static void main(String... args) { // Add some one-time configuration Game.userOnSetup( () -\u003e { Entity hero = new Entity(\"Hero\"); Game.add(hero); }); // Start the game loop Game.run(); } } Der in der Methode Game#userOnSetup übergebene Lamda-Ausdruck wird (später) einmalig beim Start der Game-Loop von libGDX aufgerufen. Auf diese Weise können wir unseren Helden ins Spiel bekommen. (Alle anderen Entitäten sollten Sie besser über die Methode Game#onLevelLoad anlegen, also beim Laden eines neuen Levels.)\nPrinzipiell haben Sie damit alles, um das Spiel starten zu können. In der Praxis sehen Sie aber keinen Helden: Der hat nämlich weder eine Position noch eine Textur, kann also gar nicht angezeigt werden.\nWo bin ich grad? Der Held braucht eine Position. Dazu gibt es core.components.PositionComponent. Fügen wir diese einfach dem Helden hinzu:\npublic class Main { public static void main(String... args) { // Add some one-time configuration Game.userOnSetup( () -\u003e { Entity hero = new Entity(\"Hero\"); hero.add(new PositionComponent()); Game.add(hero); }); // Start the game loop Game.run(); } } Wenn man keine Position mitgibt, wird einfach eine zufällige Position im Level genutzt. Alternativ kann man eine eigene Position mitgeben.\nIm Dungeon existieren aktuell zwei Koordinatensysteme: core.level.utils.Coordinate (Integer-basiert) und core.utils.Point (Float-basiert). Die Level werden als Matrix von Tile (Boden, Wand, Loch, ...) gespeichert. Die Position dieser Tile wird als Coordinate gespeichert, was dem Index des Tiles in der Matrix entspricht. Entitäten können aktuell aber auch zwischen zwei Tiles oder schräg-links-oben auf einem Tile stehen, dafür gibt es die Positionen als Point. Entsprechend könnte man den neuen Helden bei (0,0) in das Level setzen: new PositionComponent(new Point(0, 0)) bzw. kurz new PositionComponent(0f, 0f) (wobei diese Position möglicherweise nicht spielbar ist, da hier eine Wand oder sogar nichts ist).\nWenn Sie jetzt das Spiel starten, sehen Sie - immer noch nichts (außer den Wänden). Hmmm.\nAnimateure Um den Held zeichnen zu können, brauchen wir eine Animation - also eine DrawComponent.\npublic class Main { public static void main(String... args) { // Add some one-time configuration Game.userOnSetup( () -\u003e { Entity hero = new Entity(\"Hero\"); hero.add(new PositionComponent()); try { hero.add(new DrawComponent(new SimpleIPath(\"character/knight\"))); } catch (IOException e) { System.err.println(\"Could not load textures for hero.\"); throw new RuntimeException(e); } hero.add(new CameraComponent()); hero.add(new PlayerComponent()); Game.add(hero); }); // Start the game loop Game.run(); } } In den Asset-Ordnern der Sub-Projekte Game und Dungeon gibt es bereits vordefinierte Texturen. Im Beispiel wird (nur) im Sub-Projekt \"game\" gesucht (weil unsere Main-Klasse dort liegt), und zwar in \u003cgame\u003e/assets/character/knight/. Dort finden sich Unterordner für verschiedene Zustände des Ritters, und darin jeweils einige Texturen (einfache kleine .png-Dateien), die als Animation in einem bestimmten Zustand nacheinander abgespielt werden. Über den angegebenen (Teil-) Pfad werden in DrawComponent automatisch die entsprechenden Animationen erzeugt und geladen. Die Asset-Ordner sind in der Gradle-Konfiguration definiert. (Wenn Sie Ihre Main-Klasse in Dungeon ansiedeln, stehen Ihnen automatisch die Texturen aus Dungeon plus aus Game zur Verfügung.)\nDa es passieren kann, dass der übergebene Pfad nicht gefunden wird, muss hier mit Exception-Handling gearbeitet werden. Wir geben hier erstmal eine Fehlermeldung aus und propagieren eine neue RuntimeException, die letztlich dafür sorgt, dass das Spiel abgebrochen würde.\nZusätzlich brauchen wir für den Helden noch eine CameraComponent. Das core.systems.CameraSystem wird dafür sorgen, dass die Entität mit dieser Component immer im Fokus der Kamera ist. Da wir den Held später noch manuell steuern wollen, bekommt er auch gleich noch eine PlayerComponent.\nJetzt wackelt der Held auf der Stelle herum ...\nBewege mich Für die Bewegung ist das VelocitySystem zuständig. Dieses fragt in allen Entitäten die VelocityComponent sowie die PositionComponent ab, berechnet die nächste neue Position und speichert diese in der PositionComponent, und setzt bei tatsächlicher Bewegung auch eine passende Bewegungsanimation in der DrawComponent.\nDas PlayerSystem und die PlayerComponent sorgen im Zusammenspiel für eine Reaktion auf die Tastatureingaben.\npublic class Main { public static void main(String... args) { // Add some one-time configuration Game.userOnSetup( () -\u003e { Entity hero = new Entity(\"Hero\"); hero.add(new PositionComponent()); try { hero.add(new DrawComponent(new SimpleIPath(\"character/knight\"))); } catch (IOException e) { System.err.println(\"Could not load textures for hero.\"); throw new RuntimeException(e); } hero.add(new CameraComponent()); hero.add(new VelocityComponent(5f, 5f)); PlayerComponent pc = new PlayerComponent(); pc.registerCallback( KeyboardConfig.MOVEMENT_UP.value(), entity -\u003e { VelocityComponent vc = entity.fetch(VelocityComponent.class).get(); vc.currentYVelocity(vc.yVelocity()); }); hero.add(pc); Game.add(hero); }); // Start the game loop Game.run(); } } Die VelocityComponent wird im Konstruktor mit einer (maximalen) Geschwindigkeit in x- und y-Richtung erzeugt. Nutzen Sie hier nicht zu große Werte - unter Umständen reicht dann ein einziger Tastendruck, um einmal über das Spielfeld geschleudert zu werden.\nÜber die Methoden VelocityComponent#xVelocity und VelocityComponent#yVelocity können Sie die Maximalgeschwindigkeit abfragen und auch setzen. Mit VelocityComponent#currentXVelocity bzw. VelocityComponent#currentYVelocity holen und setzen Sie dagegen die aktuelle Geschwindigkeit, die vom VelocitySystem zur Berechnung der nächsten Position genutzt wird (wobei die Maximalgeschwindigkeit als Obergrenze verwendet wird).\nIm Beispiel wird in der PlayerComponent des Helden der Taste \"W\" ein Lambda-Ausdruck zugeordnet, der die VelocityComponent der Entität (also des Helden) holt, die maximale Geschwindigkeit in y-Richtung ausliest und diese als aktuelle Geschwindigkeit in y-Richtung setzt. Damit kann mit der Taste \"W\" der Held nach oben laufen.\nAnmerkung: Das entity.fetch(VelocityComponent.class) liefert nicht direkt ein VelocityComponent-Objekt zurück, sondern ein Optional\u003cVelocityComponent\u003e. Darüber sprechen wir (später) noch in der Lektion “Optional”. Für jetzt soll es zunächst genügen, dass Sie das gewünschte \"verpackte\" Objekt mit der Methode get() aus dem Optional wieder herausbekommen.\nAnmerkung: Das gezeigte Schema ist insofern typisch, als dass verschiedene Systeme aus der Maximalgeschwindigkeit und weiteren Parametern die aktuelle Geschwindigkeit berechnen und in der VelocityComponent einer Entität setzen. Das VelocitySystem nutzt dann die aktuelle Geschwindigkeit für die tatsächliche Bewegung. Sie sollten in der Praxis also die Methoden VelocityComponent#currentXVelocity bzw. VelocityComponent#currentYVelocity eher nicht selbst aufrufen, sondern dies den Systemen überlassen. Wenn Sie einen Geschwindigkeitsboost haben wollen, würde es bei der obigen Konfiguration ausreichen, VelocityComponent#xVelocity und/oder VelocityComponent#yVelocity zu setzen/zu erhöhen - den Rest übernehmen dann das PlayerSystem und vor allem das VelocitySystem ...\nNun sollten Sie Ihren Helden (nach oben) bewegen können. (Tipp: Probieren Sie \"W\".)\nHinweis: Üblicherweise bearbeiten die Systeme bei der Iteration über alle Entitäten nur diejenigen Entitäten, die alle benötigten Components aufweisen.\nWalking mit System Neue Monster Wie kann ich ein Monster beim Laden des Levels erzeugen?\nBeim Laden eines Levels wird der mit Game#userOnLevelLoad registrierte Lambda-Ausdruck ausgeführt. Hier kann man beispielsweise ein neues Monster erzeugen (lassen):\npublic class Main { public static void main(String... args) { // Add some one-time configuration Game.userOnSetup( ... ); // Create a new monster in every new level Game.userOnLevelLoad(first -\u003e { Entity fb = new Entity(\"HUGO\"); fb.add(new PositionComponent(Game.hero().get().fetch(PositionComponent.class).get().position())); try { fb.add(new DrawComponent(new SimpleIPath(\"character/knight\"))); } catch (IOException e) { System.err.println(\"Could not load textures for HUGO.\"); throw new RuntimeException(e); } VelocityComponent vc = new VelocityComponent(10f, 10f); vc.currentYVelocity(vc.yVelocity()); fb.add(vc); Game.add(fb); }); // Start the game loop Game.run(); } } Im Lambda-Ausdruck erzeugen wir hier einfach eine neue Entität und fügen dieser wie vorhin beim Hero eine DrawComponent für die Anzeige sowie eine PositionComponent und eine VelocityComponent für die Position und Bewegung hinzu, und am Ende registrieren wir die Entität beim Spiel.\nWenn man das Spiel jetzt startet, wird an der Position des Helden eine neue Entität sichtbar (mit der selben Textur).\nAber warum bewegt die neue Figur sich nicht? Wir haben doch eine VelocityComponent hinzugefügt und eine aktuelle Geschwindigkeit gesetzt?!\nWenn man in VelocitySystem#execute (bzw. die dort aufgerufene Methode VelocitySystem#updatePosition) schaut, wird klar, dass die aktuelle Geschwindigkeit zwar neu berechnet und gesetzt wird, aber dass ein \"Reibungsfaktor\" (abhängig vom Feld, auf dem die Figur steht) eingerechnet wird und somit die aktuelle Geschwindigkeit schnell auf Null geht. Der Hintergrund ist einfach: Normalerweise soll eine Entität nicht einmal angeschubst werden und dann \"ewig\" laufen, insbesondere bei Reaktion auf Tastatureingaben. Deshalb werden die Entitäten kurz bewegt und bremsen dann wieder ab. Das Aufrechterhalten der Bewegung erfolgt normalerweise über Systeme ...\nSystems für das selbstständige Laufen Wir brauchen ein System, welches die aktuelle Geschwindigkeit einer Entität in jedem Frame wieder auf den alten Wert setzt. Dazu leiten wir von core.System ab. (Achtung: Es gibt auch eine Klasse System im JDK - hier müssen Sie genau hinschauen!)\nimport core.System; public class WalkerSystem extends System { @Override public void execute() { entityStream().forEach(e -\u003e { VelocityComponent vc = e.fetch(VelocityComponent.class).get(); vc.currentXVelocity(vc.xVelocity()); vc.currentYVelocity(vc.yVelocity()); }); } } public class Main { public static void main(String... args) { // Add some one-time configuration Game.userOnSetup( ... ); // Create a new monster in every new level Game.userOnLevelLoad( ... ); // Register our new system Game.add(new WalkerSystem()); // Start the game loop Game.run(); } } Wir leiten also von core.System ab und implementieren die execute-Methode. Wir holen uns dabei von jeder Entität die VelocityComponent und setzen die aktuelle Geschwindigkeit neu auf die maximale Geschwindigkeit. Zusätzlich registrieren wir das neue System im Spiel, damit es in jedem Frame einmal aufgerufen wird.\nNun läuft das neue Monster los (bis es gegen eine Wand läuft).\nAber der Held bewegt sich nun ebenfalls dauerhaft :(\nComponents für das selbstständige Laufen Das Problem ist, dass unser neues WalkerSystem alle Entitäten automatisch bewegt. (Ein weiteres Problem ist, dass das WalkerSystem davon ausgeht, dass es immer eine VelocityComponent gibt, was nicht unbedingt erfüllt ist!)\nWir brauchen also noch eine Component, mit der wir die zu bewegenden Entitäten markieren können.\nimport core.System; import core.Component; public class WalkerComponent implements Component {} public class WalkerSystem extends System { public WalkerSystem() { super(WalkerComponent.class); } @Override public void execute() { entityStream().forEach(e -\u003e { if (e.isPresent(WalkerComponent.class)) { VelocityComponent vc = e.fetch(VelocityComponent.class).get(); vc.currentXVelocity(vc.xVelocity()); vc.currentYVelocity(vc.yVelocity()); } }); } } public class Main { public static void main(String... args) { // Add some one-time configuration Game.userOnSetup( ... ); // Create a new monster in every new level Game.userOnLevelLoad(first -\u003e { Entity fb = new Entity(\"HUGO\"); ... fb.add(new WalkerComponent()); Game.add(fb); }); // Register our new system Game.add(new WalkerSystem()); // Start the game loop Game.run(); } } Die neue Component (WalkerComponent) ist einfach eine leere Klasse, die von core.Component erbt. Wir brauchen keine Werte o.ä., die wir hier ablegen wollen - eine leere Klasse reicht für das Beispiel. Dem neuen Monster geben wir diese neue Component nun mit.\nDas WalkerSystem wird auch etwas ergänzt: Im Konstruktor rufen wir den Super-Konstruktor auf und übergeben die WalkerComponent-Klasse - dies ist die Component, für die sich das System interessiert. Zusätzlich legen wir noch eine if-Abfrage um das Aktualisieren der aktuellen Geschwindigkeit: Der Block soll nur dann ausgeführt werden, wenn die im aktuellen Schleifendurchlauf gerade betrachtete Entität eine WalkerComponent hat.\nNun läuft nur das neue Monster automatisch, der Held bleibt stehen und reagiert erst auf Tastendrücke. Prima!\nAuf diese Weise können Sie beispielsweise den Monstern einen Gesundheitszustand geben und diese bei zu schlechter Gesundheit \"sterben\" lassen (aus dem Spiel entfernen). Sie könnten aber auch komplexere Dinge wie die Kollision zwischen zwei Entitäten realisieren.\nTatsächlich gibt es im Sub-Projekt \"dungeon\" (Package contrib) bereits eine Vielzahl an Components und passenden Systems, die solche typischen Aufgaben bereits realisieren.\nKämpfe wie ein NPC Wir haben beim Hero über das PlayerComponent eine Reaktion auf Tastatureingaben implementiert. Hier könnte man einer Taste auch den Start einer neuen Entität zuordnen, die sich dann automatisch bewegt. Man könnte also Feuerbälle schleudern ...\npublic class Main { public static void main(String... args) { // Add some one-time configuration Game.userOnSetup( () -\u003e { Entity hero = new Entity(\"Hero\"); ... PlayerComponent pc = new PlayerComponent(); pc.registerCallback(KeyboardConfig.FIRST_SKILL.value(), entity -\u003e { Entity fb = new Entity(\"Fireball\"); fb.add(new PositionComponent(entity.fetch(PositionComponent.class).get().position())); try { fb.add(new DrawComponent(new SimpleIPath(\"character/knight\"))); } catch (IOException e) { System.err.println(\"Could not load textures for fireball.\"); throw new RuntimeException(e); } fb.add(new VelocityComponent(2f, 2f)); fb.add(new WalkerComponent()); Game.add(fb); }, false); Game.add(hero); }); // Create a new monster in every new level Game.userOnLevelLoad( ... ); // Register our new system Game.add(new WalkerSystem()); // Start the game loop Game.run(); } } Wir registrieren einfach die Taste FIRST_SKILL (das ist ein \"Q\") in der PlayerComponent. Im hinterlegten Lamda-Ausdruck wird eine neue Entität erzeugt mit einer WalkerComponent, also ganz analog zu dem neuen Monster vorhin beim Laden eines neuen Levels. Zusätzlich wird hier noch ein dritter Parameter mit dem Wert false mitgegeben: Die PlayerComponent wird in jedem Frame ausgewertet - wenn die Taste \"Q\" also über mehrere Frames hinweg gedrückt ist (was sehr wahrscheinlich ist), würde in jedem dieser Frames je eine neue Entität erzeugt und losgeschickt. Über diesen dritten Parameter können wir steuern, dass genau das nicht passiert. Man muss also die Taste \"Q\" zunächst wieder loslassen und dann erneut drücken, um noch einen Feuerball zu erzeugen und auf den Weg zu schicken. Als Textur habe ich einfach die im Sub-Projekt \"game\" vorhandene Textur für die Heros genommen - im Sub-Projekt \"dungeon\" gibt es dagegen auch Feuerbälle u.ä., aber dann müsste die Klasse auch in dieses Sub-Projekt umgezogen werden.\nUnser Feuerball kann leider nichts, außer sich automatisch zu bewegen. Man könnte nun noch ein CollisionSystem entwickeln, welches Entitäten immer paarweise auf ihre Positionen vergleicht und eine Kollision feststellt, wenn sich die Entitäten zu nah kommen und diese Information in einer CollisionComponent speichern (wer mit wem und wann). Dann könnte man noch ein HealthSystem bauen, welches eine HealthComponent aktualisiert. Zusätzlich könnte man ein FightSystem schreiben, welches bei einer Kollision der getroffenen Entität (zufälligen?) Schaden zufügt, also die Werte in ihrer HealthComponent reduziert. (Alternativ könnte das CollisionSystem bei Kollision einen in der CollisionComponent gespeicherten Lambda-Ausdruck ausführen.) ... Die einzelnen Klassen interagieren also nicht direkt miteinander, sondern immer über den Umweg der Systems und Components.\nAll diese (und viele weitere) Components und Systems gibt es bereits im Package contrib im Sub-Projekt \"dungeon\".\nWrap-Up Damit endet der kurze Ausflug in den Dungeon.\nIn einem ECS haben wir Entities, Components und Systems.\nDie Entitäten sind nur Hüllen und gruppieren verschiedene Components. In diesen Components werden die Werte für die jeweiligen Zustände gehalten. Die Systems werden in jedem Durchlauf der Game-Loop aufgerufen und führen dabei ihre execute()-Methode aus. Typischerweise iterieren die Systeme dabei über alle Entitäten und verändern die Components der Entitäten. Denken Sie daran, dass alles in einer Game-Loop läuft, die 30x oder 60x pro Sekunde aufgerufen wird. Sie können in der Regel keine direkte Interaktion zwischen verschiedenen Objekten realisieren, sondern müssen immer den Weg über die Systems gehen.\nSchauen Sie gern in die vorhandenen Klassen und Packages und in die Dokumentation hinein:\nKlassen in game/src/ und dungeon/src Dokumentation unter game/doc/ und dungeon/doc/ Die Javadoc-Kommentare sollten Ihnen erste Ideen zur Funktionsweise geben (auch wenn für das angestrebte Ideal noch einiges an Arbeit notwendig ist). Schauen Sie gern die Dokumentation unter game/doc/ und dungeon/doc/ an, die im Laufe des Semesters schrittweise weiter wachsen wird.\nAnregungen für Spielideen können Sie beispielsweise in den folgenden Videos finden:\nShattered Pixel Dungeon Rogue Beginners Guide Playthrough Shattered Pixel Dungeon Duelist Update! Viel Spass im PM-Dungeon!",
    "description": "How-To Dungeon In diesem Semester werden Sie im Praktikum schrittweise Erweiterungen in verschiedenen \"fertigen\" Rogue-like Computerspielen programmieren und dabei (hoffentlich) die Methoden aus der Vorlesung einsetzen können.\nDas Projekt \"PM-Dungeon\" stellt wichtige Bausteine für das Spiel bereit, beispielsweise eine Game-Loop und eine API für das Generieren und Benutzen von Leveln und vieles andere mehr. Im Hintergrund werkelt das etablierte Open-Source-Spieleframework libGDX.\nWir werden uns in diesem How-To einen Überblick verschaffen und einen ersten Einstieg versuchen: Wir programmieren einen einfachen Helden.",
    "tags": [],
    "title": "Frameworks: How-To Dungeon",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/frameworks/dungeon.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Praktikum",
    "content": "Ihr Code soll einheitlich formatiert und dokumentiert sein. Sie können beides prüfen: ./gradlew spotlessCheck für die Formatierung und ./gradlew checkstyleMain für die Dokumentation1 mit Javadoc.2 Während Sie die Dokumentation bei Fehlern manuell anpassen müssen (siehe Lektion “Javadoc”), können Sie mit ./gradlew spotlessApply den Code automatisch formatieren lassen - tun Sie das am besten vor jedem Commit.\nA05.1: Git-Spiel (40%) (Verteilung: 10%, 10%, 10%, 10%)\nBetrachten Sie erneut die Vorgaben zur \"Git-Quest\". Die Geschichte des Helden Markus findet im master-Branch kein Ende, sondern erst im Hilfsbranch end.\nMachen Sie nun verschiedene Experimente mit Branches in Git, und starten Sie dabei jeweils mit einem frischen Klon der Vorgaben.\nÄndern Sie eine Datei, die im Branch end nicht verändert wurde. Erzeugen Sie mit diesen Änderungen auf dem master einen neuen Commit. Mergen Sie danach den Branch end in den master-Branch. Ändern Sie nun eine Datei, die auch im Branch end verändert wurde. Achten Sie dabei darauf, die Änderung an einer anderen Stelle in der Datei vorzunehmen. Erzeugen Sie mit diesen Änderungen auf dem master einen neuen Commit. Mergen Sie danach den Branch end in den master-Branch. Wie (2), aber ändern Sie nun eine Stelle, die auch im Branch end verändert wurde. Erzeugen Sie mit diesen Änderungen auf dem master einen neuen Commit. Mergen Sie danach den Branch end in den master-Branch. Was passiert, wenn die Änderung im master identisch zu der in end ist? Was passiert, wenn die Änderung im master anders ist als in end? Wie (2), aber setzen Sie bitte den Branch end auf die Spitze von master, bevor Sie end in master mergen. Was beobachten Sie jeweils? Erklären Sie Ihre Beobachtungen. Wenn es Konflikte gibt: Wie lösen Sie diese auf? Demonstrieren Sie das Vorgehen im Praktikum live.\nLSF-Contact Betrachten Sie die Vorgaben \"LSF-Contact\". Klonen Sie das Repo und laden Sie das Projekt als Gradle-Projekt in Ihre IDE.\nA05.2: Methoden-Referenzen (40%) Sie finden im Package lsfcontact eine Klasse Student. Jede Instanz dieser Klasse hat mindestens einen Namen (String), und man kann verschiedene Konktaktmöglichkeiten per Setter setzen: EMail-Adresse, Telefonnummer, Post-Adresse (alle String).\nDie Klasse LsfContactUtil soll ein Hilfsmodul im LSF simulieren, mit der man die Studierenden kontaktieren kann. Es gibt drei verschiedene Methoden, die jeweils mit einer Liste mit Student-Objekten aufgerufen werden und die alle Studierenden mit der entsprechend gesetzten Kontaktoption über diesen Kontaktweg ansprechen. Beispiel: Die Methode emailStudents filtert alle Studierenden, deren EMail-Adresse gesetzt ist (d.h. deren EMail-Adresse ein nicht-leerer String ist) und \"schickt\" diesen Studierenden eine \"EMail\" über den Aufruf der privaten Hilfsmethode email.\nDie Klasse Main erzeugt einige Student-Objekte, gruppiert sie in einer Liste und demonstriert die Aufrufe der Methoden in LsfContactUtil.\nEs fällt auf, dass die drei Methoden emailStudents, phoneStudents und writeStudents algorithmisch identisch sind und sich nur in der Abfrage der entsprechenden Kontaktoption und dem Aufruf der internen Kontakt-Methode unterscheiden. Auch die internen Kontakt-Methoden email, phone und write sind recht einfallslose Code-Duplikate.\nSchreiben Sie die Klasse LsfContactUtil so um, dass es nur noch eine public Methode für das Kontaktieren einer Liste von Student-Objekten gibt. Fassen Sie ebenfalls die drei private Hilfsmethoden zu einer neuen Hilfsmethode zusammen - dabei soll es inhaltlich bei dem System.out.println() mit den aktuell verwendeten Informationen bleiben. Überlegen Sie, wie Sie die Abfrage der Kontaktmöglichkeit und auch die Kriterien für die Prüfung der Strings von außen als Parameter in die Methode hineingeben können. Passen Sie die Schnittstellen an, so dass der neuen public Methode zusätzlich zur List\u003cStudent\u003e passende Methodenreferenzen übergeben werden können. Ändern Sie die Demo-Aufrufe in Main entsprechend. Die Klasse Student verändern Sie bitte nicht.\nTipp: Gehen Sie schrittweise vor und starten zunächst mit geeigneten Lambda-Ausdrücken. Schaffen Sie es, diese durch Methodenreferenzen zu ersetzen?\nAchten Sie darauf, alle Schritte nachvollziehbar in Ihrer Arbeitskopie per Git Commit festzuhalten. Demonstrieren Sie dies im Praktikum.\nA05.3: Logging (20%) Bauen Sie für das LsfContactUtil ein Logging auf der Basis von java.util.logging ein: Jede Benachrichtigung von Studierenden soll in ein gemeinsames CSV-File geloggt werden. Dabei soll pro Logging-Vorgang eine neue Zeile mit den folgenden Informationen angehängt werden:\nLog-Level, Name der den Log-Vorgang auslösenden Methode, Name der Klasse, in der die den Log-Vorgang auslösenden Methode angesiedelt ist, Log-Meldung, bestehend aus Name des kontaktierten Studierenden, genutzte Adresse des Studierenden (Mail- oder Postadresse oder Telefonnummer), Kontaktmodus (wird eine Mail geschickt oder ein Brief geschrieben oder ein Anruf getätigt). Demonstrieren Sie in der Abgabe, wie Sie im Test oder im Hauptprogramm den Logger steuern können, beispielsweise Änderung der Log-Level oder Abschalten des Loggings.\nzumindest für den syntaktischen Aspekt ... ↩︎\nSie können auch beides zusammen per ./gradlew check prüfen lassen. ↩︎",
    "description": "Ihr Code soll einheitlich formatiert und dokumentiert sein. Sie können beides prüfen: ./gradlew spotlessCheck für die Formatierung und ./gradlew checkstyleMain für die Dokumentation1 mit Javadoc.2 Während Sie die Dokumentation bei Fehlern manuell anpassen müssen (siehe Lektion “Javadoc”), können Sie mit ./gradlew spotlessApply den Code automatisch formatieren lassen - tun Sie das am besten vor jedem Commit.\nA05.1: Git-Spiel (40%) (Verteilung: 10%, 10%, 10%, 10%)\nBetrachten Sie erneut die Vorgaben zur \"Git-Quest\". Die Geschichte des Helden Markus findet im master-Branch kein Ende, sondern erst im Hilfsbranch end.",
    "tags": [],
    "title": "Blatt 05: Git-Quest und LSF-Contact (Git Branches, Methoden-Referenzen, Logging)",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/homework/b05.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024)",
    "content": "Einführung Softwaretest Testen mit JUnit (JUnit-Basics) Testfallermittlung: Wie viel und was muss man testen? Mocking mit Mockito",
    "description": "Einführung Softwaretest Testen mit JUnit (JUnit-Basics) Testfallermittlung: Wie viel und was muss man testen? Mocking mit Mockito",
    "tags": [],
    "title": "Testen mit JUnit und Mockito",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/testing.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Testing",
    "content": "Software-Fehler und ihre Folgen (Einige) Ursachen für Fehler Zeit- und Kostendruck Mangelhafte Anforderungsanalyse Hohe Komplexität Mangelhafte Kommunikation Keine/schlechte Teststrategie Mangelhafte Beherrschung der Technologie ... Irgendjemand muss mit Deinen Bugs leben! Leider gibt es im Allgemeinen keinen Weg zu zeigen, dass eine Software korrekt ist. Man kann (neben formalen Beweisansätzen) eine Software nur unter möglichst vielen Bedingungen ausprobieren, um zu schauen, wie sie sich verhält, und um die dabei zu Tage tretenden Bugs zu fixen.\nMal abgesehen von der verbesserten User-Experience führt weniger fehlerbehaftete Software auch dazu, dass man seltener mitten in der Nacht geweckt wird, weil irgendwo wieder ein Server gecrasht ist ... Weniger fehlerbehaftete Software ist auch leichter zu ändern und zu pflegen! In realen Projekten macht Maintenance den größten Teil an der Softwareentwicklung aus ... Während Ihre Praktikumsprojekte vermutlich nach der Abgabe nie wieder angeschaut werden, können echte Projekte viele Jahre bis Jahrzehnte leben! D.h. irgendwer muss sich dann mit Ihren Bugs herumärgern - vermutlich sogar Sie selbst ;)\nAlways code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live. Code for readability.\n-- John F. Woods\nDieses Zitat taucht immer mal wieder auf, beispielsweise auf der OSCON 2014 ... Es scheint aber tatsächlich, dass John F. Woods die ursprüngliche Quelle war (vgl. Stackoverflow: 876089).\nDa wir nur wenig Zeit haben und zudem vergesslich sind und obendrein die Komplexität eines Projekts mit der Anzahl der Code-Zeilen i.d.R. nicht-linear ansteigt, müssen wir das Testen automatisieren. Und hier kommt JUnit ins Spiel :)\nWas wann testen? Wichtigste Teststufen Modultest\nTesten einer Klasse und ihrer Methoden Test auf gewünschtes Verhalten (Parameter, Schleifen, ...) Integrationstest\nTest des korrekten Zusammenspiels mehrerer Komponenten Konzentration auf Schnittstellentests Systemtest\nTest des kompletten Systems unter produktiven Bedingungen Orientiert sich an den aufgestellten Use Cases Funktionale und nichtfunktionale Anforderungen testen =\u003e Verweis auf Wahlfach \"Softwarequalität\"\nJUnit: Test-Framework für Java JUnit --- Open Source Java Test-Framework zur Erstellung und Durchführung wiederholbarer Tests\nJUnit 3\nTests müssen in eigenen Testklassen stehen Testklassen müssen von Klasse TestCase erben Testmethoden müssen mit dem Präfix \"test\" beginnen JUnit 4\nAnnotation @Test für Testmethoden Kein Zwang zu spezialisierten Testklassen (insbesondere kein Zwang mehr zur Ableitung von TestCase) Freie Namenswahl für Testmethoden (benötigen nicht mehr Präfix \"test\") Damit können prinzipiell auch direkt im Source-Code Methoden als JUnit-Testmethoden ausgezeichnet werden ... (das empfiehlt sich in der Regel aber nicht)\nJUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage\nErweiterung um mächtigere Annotationen Aufteilung in spezialisierte Teilprojekte Das Teilprojekt \"JUnit Platform\" ist die Grundlage für das JUnit-Framework. Es bietet u.a. einen Console-Launcher, um Testsuiten manuell in der Konsole zu starten oder über Builder wie Ant oder Gradle.\nDas Teilprojekt \"JUnit Jupiter\" ist das neue Programmiermodell zum Schreiben von Tests in JUnit 5. Es beinhaltet eine TestEngine zum Ausführen der in Jupiter geschriebenen Tests.\nDas Teilprojekt \"JUnit Vintage\" beinhaltet eine TestEngine zum Ausführen von Tests, die in JUnit 3 oder JUnit 4 geschrieben sind.\nAnmerkung: Wie der Name schon sagt, ist das Framework für Modultests (\"Unit-Tests\") gedacht. Man kann damit aber auch auf anderen Teststufen arbeiten!\nAnmerkung: Im Folgenden besprechen wir JUnit am Beispiel JUnit 4, da diese Version des Frameworks besonders stark verbreitet ist und JUnit 5 (trotz offiziellem Release) immer noch stellenweise unfertig wirkt. Auf Unterschiede zu JUnit 5 wird an geeigneter Stelle hingewiesen (abgesehen von Import-Statements). Mit JUnit 3 sollte nicht mehr aktiv gearbeitet werden, d.h. insbesondere keine neuen Tests mehr erstellt werden, da diese Version nicht mehr weiterentwickelt wird.\nAnlegen und Organisation der Tests mit JUnit Anlegen neuer Tests: Klasse auswählen, Kontextmenü New \u003e JUnit Test Case\nBest Practice: Spiegeln der Paket-Hierarchie\nToplevel-Ordner test (statt src) Package-Strukturen spiegeln Testklassen mit Suffix \"Test\" Vorteile dieses Vorgehens:\nDie Testklassen sind aus Java-Sicht im selben Package wie die Source-Klassen, d.h. Zugriff auf Package-sichtbare Methoden etc. ist gewährleistet Durch die Spiegelung der Packages in einem separaten Testordner erhält man eine gute getrennte Übersicht über jeweils die Tests und die Sourcen Die Wiederverwendung des Klassennamens mit dem Anhang \"Test\" erlaubt die schnelle Erkennung, welche Tests hier vorliegen In der Paketansicht liegen dann die Source- und die Testklassen immer direkt hintereinander (da sie im selben Paket sind und mit dem selben Namen anfangen) =\u003e besserer Überblick!\nAnmerkung: Die (richtige) JUnit-Bibliothek muss im Classpath liegen! Eclipse bringt für JUnit 4 und JUnit 5 die nötigen Jar-Dateien mit und fragt beim erstmaligen Anlegen einer neuen Testklasse, ob die für die ausgewählte Version passenden JUnit-Jars zum Build-Path hinzugefügt werden sollen.\nIntelliJ bringt ebenfalls eine JUnit 4 Bibliothek mit, die zum Projekt als Abhängigkeit hinzugefügt werden muss. Für JUnit 5 bietet IntelliJ an, die Jar-Dateien herunterzuladen und in einem passenden Ordner abzulegen.\nAlternativ lädt man die Bibliotheken entsprechend der Anleitung unter junit.org herunter und bindet sie in das Projekt ein.\nJUnit 4+5: Definition von Tests Annotation @Test vor Testmethode schreiben\nimport org.junit.Test; import static org.junit.Assert.*; public class FactoryBeispielTest4 { @Test public void testGetTicket() { fail(\"not implemented\"); } } Für JUnit 5 muss statt org.junit.Test entsprechend org.junit.jupiter.api.Test importiert werden.\nWährend in JUnit 4 die Testmethoden mit der Sichtbarkeit public versehen sein müssen und keine Parameter haben (dürfen), spielt die Sichtbarkeit in JUnit 5 keine Rolle (und die Testmethoden dürfen Parameter aufweisen =\u003e vgl. Abschnitt \"Dependency Injection for Constructors and Methods\" in der JUnit-Doku).\nJUnit 4: Ergebnis prüfen Klasse org.junit.Assert enthält diverse statische Methoden zum Prüfen:\n// Argument muss true bzw. false sein void assertTrue(boolean); void assertFalse(boolean); // Gleichheit im Sinne von equals() void assertEquals(Object, Object); // Test sofort fehlschlagen lassen void fail(); ... Für JUnit 5 finden sich die Assert-Methoden im Package org.junit.jupiter.api.Assertions.\nAnmerkung zum statischen Import Bei normalem Import der Klasse Assert muss man jeweils den voll qualifizierten Namen einer statischen Methode nutzen: Assert.fail().\nAlternative statischer Import: import static org.junit.Assert.fail; =\u003e Statische Member der importierten Klasse (oder Interface) werden über ihre unqualifizierten Namen zugreifbar. Achtung: Namenskollisionen möglich!\n// nur bestimmtes Member importieren import static packageName.className.staticMemberName; // alle statischen Member importieren import static packageName.className.*; Beispiel normaler Import:\nimport org.junit.Assert; Assert.fail(\"message\"); Beispiel statischer Import:\nimport static org.junit.Assert.fail; fail(\"message\"); Mögliche Testausgänge bei JUnit Error: Fehler im Programm (Test)\nUnbehandelte Exception Abbruch (Timeout) Failure: Testausgang negativ\nAssert fehlgeschlagen Assert.fail() aufgerufen OK\nAnmerkungen zu Assert Pro Testmethode möglichst nur ein Assert verwenden! Anderenfalls: Schlägt ein Assert fehl, wird der Rest nicht mehr überprüft ... Wrap-Up Testen ist genauso wichtig wie Coden\nRichtiges Testen spart Geld, Zeit, ...\nTests auf verschiedenen Abstraktionsstufen\nJUnit als Framework für (Unit-) Tests; hier JUnit 4 (mit Ausblick auf JUnit 5)\nTestmethoden mit Annotation @Test Testergebnis mit assert* prüfen",
    "description": "Software-Fehler und ihre Folgen (Einige) Ursachen für Fehler Zeit- und Kostendruck Mangelhafte Anforderungsanalyse Hohe Komplexität Mangelhafte Kommunikation Keine/schlechte Teststrategie Mangelhafte Beherrschung der Technologie ... Irgendjemand muss mit Deinen Bugs leben! Leider gibt es im Allgemeinen keinen Weg zu zeigen, dass eine Software korrekt ist. Man kann (neben formalen Beweisansätzen) eine Software nur unter möglichst vielen Bedingungen ausprobieren, um zu schauen, wie sie sich verhält, und um die dabei zu Tage tretenden Bugs zu fixen.",
    "tags": [],
    "title": "Einführung Softwaretest",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/testing/testing-intro.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Testing",
    "content": "JUnit: Ergebnis prüfen Klasse org.junit.Assert enthält diverse statische Methoden zum Prüfen:\n// Argument muss true bzw. false sein void assertTrue(boolean); void assertFalse(boolean); // Gleichheit im Sinne von equals() void assertEquals(Object, Object); // Test sofort fehlschlagen lassen void fail(); ... To \"assert\" or to \"assume\"? Mit assert* werden Testergebnisse geprüft\nTest wird ausgeführt Ergebnis: OK, Failure, Error Mit assume* werden Annahmen über den Zustand geprüft\nTest wird abgebrochen, wenn Annahme nicht erfüllt Prüfen von Vorbedingungen: Ist der Test hier ausführbar/anwendbar? Beispiel: junit4.TestAssume Setup und Teardown: Testübergreifende Konfiguration private Studi x; @Before public void setUp() { x = new Studi(); } @Test public void testToString() { // Studi x = new Studi(); assertEquals(x.toString(), \"Heinz (15cps)\"); } @Before wird vor jeder Testmethode aufgerufen @BeforeClass wird einmalig vor allen Tests aufgerufen (static!) @After wird nach jeder Testmethode aufgerufen @AfterClass wird einmalig nach allen Tests aufgerufen (static!) In JUnit 5 wurden die Namen dieser Annotationen leicht geändert:\nJUnit 4 JUnit 5 @Before @BeforeEach @After @AfterEach @BeforeClass @BeforeAll @AfterClass @AfterAll Beispiel für den Einsatz von @Before Annahme: alle/viele Testmethoden brauchen neues Objekt x vom Typ Studi\nprivate Studi x; @Before public void setUp() { x = new Studi(\"Heinz\", 15); } @Test public void testToString() { // Studi x = new Studi(\"Heinz\", 15); assertEquals(x.toString(), \"Name: Heinz, credits: 15\"); } @Test public void testGetName() { // Studi x = new Studi(\"Heinz\", 15); assertEquals(x.getName(), \"Heinz\"); } Ignorieren von Tests Hinzufügen der Annotation @Ignore Alternativ mit Kommentar: @Ignore(\"Erst im nächsten Release\") @Ignore(\"Warum ignoriert\") @Test public void testBsp() { Bsp x = new Bsp(); assertTrue(x.isTrue()); } In JUnit 5 wird statt der Annotation @Ignore die Annotation @Disabled mit der selben Bedeutung verwendet. Auch hier lässt sich als Parameter ein String mit dem Grund für das Ignorieren des Tests hinterlegen.\nVermeidung von Endlosschleifen: Timeout Testfälle werden nacheinander ausgeführt Test mit Endlosschleife würde restliche Tests blockieren Erweitern der @Test-Annotation mit Parameter \"timeout\": =\u003e @Test(timeout=2000) (Zeitangabe in Millisekunden) @Test(timeout = 2000) void testTestDauerlaeufer() { while (true) { ; } } In JUnit 5 hat die Annotation @Test keinen timeout-Parameter mehr. Als Alternative bietet sich der Einsatz von org.junit.jupiter.api.Assertions.assertTimeout an. Dabei benötigt man allerdings Lambda-Ausdrücke (Verweis auf spätere VL):\n@Test void testTestDauerlaeufer() { assertTimeout(ofMillis(2000), () -\u003e { while (true) { ; } }); } (Beispiel von oben mit Hilfe von JUnit 5 formuliert)\nTest von Exceptions: Expected Traditionelles Testen von Exceptions mit try und catch:\n@Test public void testExceptTradit() { try { int i = 0 / 0; fail(\"keine ArithmeticException ausgeloest\"); } catch (ArithmeticException aex) { assertNotNull(aex.getMessage()); } catch (Exception e) { fail(\"falsche Exception geworfen\"); } } Der expected-Parameter für die @Test-Annotation in JUnit 4 macht dies deutlich einfacher: @Test(expected = MyException.class) =\u003e Test scheitert, wenn diese Exception nicht geworfen wird\n@Test(expected = java.lang.ArithmeticException.class) public void testExceptAnnot() { int i = 0 / 0; } In JUnit 5 hat die Annotation @Test keinen expected-Parameter mehr. Als Alternative bietet sich der Einsatz von org.junit.jupiter.api.Assertions.assertThrows an. Dabei benötigt man allerdings Lambda-Ausdrücke (Verweis auf spätere VL):\n@Test public void testExceptAnnot() { assertThrows(java.lang.ArithmeticException.class, () -\u003e { int i = 0 / 0; }); } (Beispiel von oben mit Hilfe von JUnit 5 formuliert)\nParametrisierte Tests Manchmal möchte man den selben Testfall mehrfach mit anderen Werten (Parametern) durchführen.\nclass Sum { public static int sum(int i, int j) { return i + j; } } class SumTest { @Test public void testSum() { Sum s = new Sum(); assertEquals(s.sum(1, 1), 2); } // und mit (2,2, 4), (2,2, 5), ...???? } Prinzipiell könnte man dafür entweder in einem Testfall eine Schleife schreiben, die über die verschiedenen Parameter iteriert. In der Schleife würde dann jeweils der Aufruf der zu testenden Methode und das gewünschte Assert passieren. Alternativ könnte man den Testfall entsprechend oft duplizieren mit jeweils den gewünschten Werten.\nBeide Vorgehensweisen haben Probleme: Im ersten Fall würde die Schleife bei einem Fehler oder unerwarteten Ergebnis abbrechen, ohne dass die restlichen Tests (Werte) noch durchgeführt würden. Im zweiten Fall bekommt man eine unnötig große Anzahl an Testmethoden, die bis auf die jeweiligen Werte identisch sind (Code-Duplizierung).\nParametrisierte Tests mit JUnit 4 JUnit 4 bietet für dieses Problem sogenannte \"parametrisierte Tests\" an. Dafür muss eine Testklasse in JUnit 4 folgende Bedingungen erfüllen:\nDie Testklasse wird mit der Annotation @RunWith(Parameterized.class) ausgezeichnet. Es muss eine öffentliche statische Methode geben mit der Annotation @Parameters. Diese Methode liefert eine Collection zurück, wobei jedes Element dieser Collection ein Array mit den Parametern für einen Durchlauf der Testmethoden ist. Die Parameter müssen gesetzt werden. Dafür gibt es zwei Varianten: (A) Für jeden Parameter gibt es ein öffentliches Attribut. Diese Attribute müssen mit der Annotation @Parameter markiert sein und können in den Testmethoden normal genutzt werden. JUnit sorgt dafür, dass für jeden Eintrag in der Collection aus der statischen @Parameters-Methode diese Felder gesetzt werden und die Testmethoden aufgerufen werden. (B) Alternativ gibt es einen Konstruktor, der diese Werte setzt. Die Anzahl der Parameter im Konstruktor muss dabei exakt der Anzahl (und Reihenfolge) der Werte in jedem Array in der von der statischen @Parameters-Methode gelieferten Collection entsprechen. Der Konstruktor wird für jeden Parametersatz einmal aufgerufen und die Testmethoden einmal durchgeführt. Letztlich wird damit das Kreuzprodukt aus Testmethoden und Testdaten durchgeführt.\n(A) Parametrisierte Tests: Konstruktor (JUnit 4) @RunWith(Parameterized.class) public class SumTestConstructor { private final int s1; private final int s2; private final int erg; public SumTestConstructor(int p1, int p2, int p3) { s1 = p1; s2 = p2; erg = p3; } @Parameters public static Collection\u003cObject[]\u003e values() { return Arrays.asList(new Object[][] { { 1, 1, 2 }, { 2, 2, 4 }, { 2, 2, 5 } }); } @Test public void testSum() { assertEquals(Sum.sum(s1, s2), erg); } } (B) Parametrisierte Tests: Parameter (JUnit 4) @RunWith(Parameterized.class) public class SumTestParameters { @Parameter(0) public int s1; @Parameter(1) public int s2; @Parameter(2) public int erg; @Parameters public static Collection\u003cObject[]\u003e values() { return Arrays.asList(new Object[][] { { 1, 1, 2 }, { 2, 2, 4 }, { 2, 2, 5 } }); } @Test public void testSum() { assertEquals(Sum.sum(s1, s2), erg); } } Beispiel: junit4.SumTestConstructor, junit4.SumTestParameters Parametrisierte Tests mit JUnit 5 In JUnit 5 werden parametrisierte Tests mit der Annotation @ParameterizedTest gekennzeichnet (statt mit @Test).\nMit Hilfe von @ValueSource kann man ein einfaches Array von Werten (Strings oder primitive Datentypen) angeben, mit denen der Test ausgeführt wird. Dazu bekommt die Testmethode einen entsprechenden passenden Parameter:\n@ParameterizedTest @ValueSource(strings = {\"wuppie\", \"fluppie\", \"foo\"}) void testWuppie(String candidate) { assertTrue(candidate.equals(\"wuppie\")); } Alternativ lassen sich als Parameterquelle u.a. Aufzählungen (@EnumSource) oder Methoden (@MethodSource) oder auch Komma-separierte Daten (@CsvSource) angeben.\nDas obige Beispiel aus JUnit 4.x könnte mit Hilfe von @CsvSource so in JUnit 5.x umgesetzt werden:\npublic class SumTest { @ParameterizedTest @CsvSource(textBlock = \"\"\" # s1, s2, s1+s2 0, 0, 0 10, 0, 10 0, 11, 11 -2, 10, 8 \"\"\") public void testSum(int s1, int s2, int erg) { assertEquals(Sum.sum(s1, s2), erg); } } Beispiel: junit5.TestValueSource, junit5.TestMethodSource Testsuiten: Tests gemeinsam ausführen (JUnit 4) Eclipse: New \u003e Other \u003e Java \u003e JUnit \u003e JUnit Test Suite\nimport org.junit.runner.RunWith; import org.junit.runners.Suite; import org.junit.runners.Suite.SuiteClasses; @RunWith(Suite.class) @SuiteClasses({ // Hier kommen alle Testklassen rein PersonTest.class, StudiTest.class }) public class MyTestSuite { // bleibt leer!!! } Testsuiten mit JUnit 5 In JUnit 5 gibt es zwei Möglichkeiten, Testsuiten zu erstellen:\n@SelectPackages: Angabe der Packages, die für die Testsuite zusammengefasst werden sollen @SelectClasses: Angabe der Klassen, die für die Testsuite zusammengefasst werden sollen @RunWith(JUnitPlatform.class) @SelectClasses({StudiTest5.class, WuppieTest5.class}) public class MyTestSuite5 { // bleibt leer!!! } Zusätzlich kann man beispielsweise mit @IncludeTags oder @ExcludeTags Testmethoden mit bestimmten Tags einbinden oder ausschließen. Beispiel: Schließe alle Tests mit Tag \"develop\" aus: @ExcludeTags(\"develop\"). Dabei wird an den Testmethoden zusätzlich das Tag @Tag verwendet, etwas @Tag(\"develop\").\nAchtung: Laut der offiziellen Dokumentation (Abschnitt \"4.4.4. Test Suite\") gilt zumindest bei der Selection über @SelectPackages der Zwang zu einer Namenskonvention: Es werden dabei nur Klassen gefunden, deren Name mit Test beginnt oder endet! Weiterhin werden Testsuites mit der Annotation @RunWith(JUnitPlatform.class) nicht auf der \"JUnit 5\"-Plattform ausgeführt, sondern mit der JUnit 4-Infrastuktur!\nBest Practices Ein Testfall behandelt exakt eine Idee/ein Szenario. Das bedeutet auch, dass man in der Regel nur ein bis wenige assert* pro Testmethode benutzt.\n(Wenn man verschiedene Ideen in eine Testmethode kombiniert, wird der Testfall unübersichtlicher und auch auch schwerer zu warten.\nAußerdem können so leichter versteckte Fehler auftreten: Das erste oder zweite oder dritte assert* schlägt fehl - und alle dahinter kommenden assert* werden nicht mehr ausgewertet!)\nWenn die selbe Testidee mehrfach wiederholt wird, sollte man diese Tests zu einem parametrisierten Test zusammenfassen.\n(Das erhöht die Lesbarkeit drastisch - und man läuft auch nicht in das Problem der Benennung der Testmethoden.)\nEs wird nur das Verhalten der öffentlichen Schnittstelle getestet, nicht die inneren Strukturen einer Klasse oder Methode.\n(Es ist verlockend, auch private Methoden zu testen und in den Tests auch die Datenstrukturen o.ä. im Blick zu behalten und zu testen. Das führt aber zu sehr \"zerbrechlichen\" (brittle) Tests: Sobald sich etwas an der inneren Struktur ändert, ohne dass sich das von außen beobachtbare Verhalten ändert und also die Klasse/Methode immer noch ordnungsgemäß funktioniert, gehen all diese \"internen\" Tests kaputt. Nicht ohne Grund wird in der objektorientierten Programmierung mit Kapselung (Klassen, Methoden, ...) gearbeitet.)\nVon Setup- und Teardown-Methoden sollte eher sparsam Gebrauch gemacht werden.\n(Normalerweise folgen wir in der objektorientierten Programmierung dem DRY-Prinzip (Don't repeat yourself). Entsprechend liegt es nahe, häufig benötigte Elemente in einer Setup-Methode zentral zu initialisieren und ggf. in einer Teardown-Methode wieder freizugeben.\nDas führt aber speziell bei Unit-Tests dazu, dass die einzelnen Testmethoden schwerer lesbar werden: Sie hängen von einer gemeinsamen, zentralen Konfiguration ab, die man üblicherweise nicht gleichzeitig mit dem Code der Testmethode sehen kann (begrenzter Platz auf der Bildschirmseite).\nWenn nun in einem oder vielleicht mehreren Testfällen der Wunsch nach einer leicht anderen Konfiguration auftaucht, muss man die gemeinsame Konfiguration entsprechend anpassen bzw. erweitern. Dabei muss man dann aber alle anderen Testmethoden mit bedenken, die ja ebenfalls von dieser Konfiguration abhängen! Das führt in der Praxis dann häufig dazu, dass die gemeinsame Konfiguration sehr schnell sehr groß und verschachtelt und entsprechend unübersichtlich wird.\nJede Änderung an dieser Konfiguration kann leicht einen oder mehrere Testfälle kaputt machen (man hat ja i.d.R. nie alle Testfälle gleichzeitig im Blick), weshalb man hier unbedingt mit passenden assume* arbeiten muss - aber dann kann man eigentlich auch stattdessen die Konfiguration direkt passend für den jeweiligen Testfall in der jeweiligen Testmethode erledigen!)\nWie immer sollten auch die Namen der Testmethoden klar über ihren Zweck Auskunft geben.\n(Der Präfix \"test\" wird seit JUnit 4.x nicht mehr benötigt, aber dennoch ist es in vielen Projekten Praxis, diesen Präfix beizubehalten - damit kann man in der Package-Ansicht in der IDE leichter zwischen den \"normalen\" und den Testmethoden unterscheiden.)\nDiese Erfahrungen werden ausführlich in [SWEGoogle, pp. 231-256] diskutiert.\nWrap-Up JUnit als Framework für (Unit-) Tests; hier JUnit 4 (mit Ausblick auf JUnit 5)\nTestmethoden mit Annotation @Test assert (Testergebnis) vs. assume (Testvorbedingung) Aufbau der Testumgebung @Before Abbau der Testumgebung @After Steuern von Tests mit @Ignore oder @Test(timout=XXX) Exceptions einfordern mit @Test(expected=package.Exception.class) Tests zusammenfassen zu Testsuiten",
    "description": "JUnit: Ergebnis prüfen Klasse org.junit.Assert enthält diverse statische Methoden zum Prüfen:\n// Argument muss true bzw. false sein void assertTrue(boolean); void assertFalse(boolean); // Gleichheit im Sinne von equals() void assertEquals(Object, Object); // Test sofort fehlschlagen lassen void fail(); ... To \"assert\" or to \"assume\"? Mit assert* werden Testergebnisse geprüft\nTest wird ausgeführt Ergebnis: OK, Failure, Error Mit assume* werden Annahmen über den Zustand geprüft\nTest wird abgebrochen, wenn Annahme nicht erfüllt Prüfen von Vorbedingungen: Ist der Test hier ausführbar/anwendbar? Beispiel: junit4.TestAssume Setup und Teardown: Testübergreifende Konfiguration private Studi x; @Before public void setUp() { x = new Studi(); } @Test public void testToString() { // Studi x = new Studi(); assertEquals(x.toString(), \"Heinz (15cps)\"); } @Before wird vor jeder Testmethode aufgerufen @BeforeClass wird einmalig vor allen Tests aufgerufen (static!) @After wird nach jeder Testmethode aufgerufen @AfterClass wird einmalig nach allen Tests aufgerufen (static!) In JUnit 5 wurden die Namen dieser Annotationen leicht geändert:",
    "tags": [],
    "title": "Testen mit JUnit (JUnit-Basics)",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/testing/junit-basics.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Modern Java",
    "content": "Motivation public class LSF { private Set\u003cStudi\u003e sl; public Studi getBestStudi() { if (sl == null) return null; // Fehler: Es gibt noch keine Sammlung Studi best = null; for (Studi s : sl) { if (best == null) best = s; if (best.credits() \u003c s.credits()) best = s; } return best; } } public static void main(String... args) { LSF lsf = new LSF(); Studi best = lsf.getBestStudi(); if (best != null) { String name = best.name(); if (name != null) { // mach was mit dem Namen ... } } } Problem: null wird an (zu) vielen Stellen genutzt Es gibt keinen Wert (\"not found\") Felder wurden (noch) nicht initialisiert Es ist ein Problem oder etwas Unerwartetes aufgetreten =\u003e Parameter und Rückgabewerte müssen stets auf null geprüft werden (oder Annotationen wie @NotNull eingesetzt werden ...)\nLösung Optional\u003cT\u003e für Rückgabewerte, die \"kein Wert vorhanden\" mit einschließen (statt null bei Abwesenheit von Werten) @NotNull/@Nullable für Parameter einsetzen (oder separate Prüfung) Exceptions werfen in Fällen, wo ein Problem aufgetreten ist Anmerkungen Verwendung von null auf Attribut-Ebene (Klassen-interne Verwendung) ist okay! Optional\u003cT\u003e ist kein Ersatz für null-Checks! null ist kein Ersatz für vernünftiges Error-Handling! Das häufig zu beobachtende \"Irgendwas Unerwartetes ist passiert, hier ist null\" ist ein Anti-Pattern! Beispiel aus der Praxis im PM-Dungeon Schauen Sie sich einmal das Review zu den ecs.components.ai.AITools in https://github.com/Dungeon-CampusMinden/Dungeon/pull/128#pullrequestreview-1254025874 an.\nDie Methode AITools#calculateNewPath soll in der Umgebung einer als Parameter übergebenen Entität nach einem Feld (Tile) suchen, welches für die Entität betretbar ist und einen Pfad von der Position der Entität zu diesem Feld an den Aufrufer zurückliefern.\nZunächst wird in der Entität nach einer PositionComponent und einer VelocityComponent gesucht. Wenn es (eine) diese(r) Components nicht in der Entität gibt, wird der Wert null an den Aufrufer von AITools#calculateNewPath zurückgeliefert. (Anmerkung: Interessanterweise wird in der Methode nicht mit der VelocityComponent gearbeitet.)\nDann wird in der PositionComponent die Position der Entität im aktuellen Level abgerufen. In einer Schleife werden alle Felder im gegebenen Radius in eine Liste gespeichert. (Anmerkung: Da dies über die float-Werte passiert und nicht über die Feld-Indizes wird ein Tile u.U. recht oft in der Liste abgelegt. Können Sie sich hier einfache Verbesserungen überlegen?)\nDa level.getTileAt() offenbar als Antwort auch null zurückliefern kann, werden nun zunächst per tiles.removeIf(Objects::isNull); all diese null-Werte wieder aus der Liste entfernt. Danach erfolgt die Prüfung, ob die verbleibenden Felder betretbar sind und nicht-betretbare Felder werden entfernt.\nAus den verbleibenden (betretbaren) Feldern in der Liste wird nun eines zufällig ausgewählt und per level.findPath() ein Pfad von der Position der Entität zu diesem Feld berechnet und zurückgeliefert. (Anmerkung: Hier wird ein zufälliges Tile in der Liste der umgebenden Felder gewählt, von diesem die Koordinaten bestimmt, und dann noch einmal aus dem Level das dazugehörige Feld geholt - dabei hatte man die Referenz auf das Feld bereits in der Liste. Können Sie sich hier eine einfache Verbesserung überlegen?)\nZusammengefasst:\nDie als Parameter entity übergebene Referenz darf offenbar nicht null sein. Die ersten beiden Statements in der Methode rufen auf dieser Referenz Methoden auf, was bei einer null-Referenz zu einer NullPointer-Exception führen würde. Hier wäre null ein Fehlerzustand. entity.getComponent() kann offenbar null zurückliefern, wenn die gesuchte Component nicht vorhanden ist. Hier wird null als \"kein Wert vorhanden\" genutzt, was dann nachfolgende null-Checks notwendig macht. Wenn es die gewünschten Components nicht gibt, wird dem Aufrufer der Methode null zurückgeliefert. Hier ist nicht ganz klar, ob das einfach nur \"kein Wert vorhanden\" ist oder eigentlich ein Fehlerzustand? level.getTileAt() kann offenbar null zurückliefern, wenn kein Feld an der Position vorhanden ist. Hier wird null wieder als \"kein Wert vorhanden\" genutzt, was dann nachfolgende null-Checks notwendig macht (Entfernen aller null-Referenzen aus der Liste). level.findPath() kann auch wieder null zurückliefern, wenn kein Pfad berechnet werden konnte. Hier ist wieder nicht ganz klar, ob das einfach nur \"kein Wert vorhanden\" ist oder eigentlich ein Fehlerzustand? Man könnte beispielsweise in diesem Fall ein anderes Feld probieren? Der Aufrufer bekommt also eine NullPointer-Exception, wenn der übergebene Parameter entity nicht vorhanden ist oder den Wert null, wenn in der Methode etwas schief lief oder schlicht kein Pfad berechnet werden konnte oder tatsächlich einen Pfad. Damit wird der Aufrufer gezwungen, den Rückgabewert vor der Verwendung zu untersuchen.\nAllein in dieser einen kurzen Methode macht null so viele extra Prüfungen notwendig und den Code dadurch schwerer lesbar und fehleranfälliger! null wird als (unvollständige) Initialisierung und als Rückgabewert und für den Fehlerfall genutzt, zusätzlich ist die Semantik von null nicht immer klar. (Anmerkung: Der Gebrauch von null hat nicht wirklich etwas mit \"der Natur eines ECS\" zu tun. Die Methode wurde mittlerweile komplett überarbeitet und ist in der hier gezeigten Form glücklicherweise nicht mehr zu finden.)\nEntsprechend hat sich in diesem Review die nachfolgende Diskussion ergeben:\nErzeugen von Optional-Objekten Konstruktor ist private ...\n\"Kein Wert\": Optional.empty()\nVerpacken eines non-null Elements: Optional.of() (NullPointerException wenn Argument null!)\nVerpacken eines \"unsicheren\"/beliebigen Elements: Optional.ofNullable()\nLiefert verpacktes Element, oder Optional.empty(), falls Element null war Es sollte in der Praxis eigentlich nur wenige Fälle geben, wo ein Aufruf von Optional.of() sinnvoll ist. Ebenso ist Optional.empty() nur selten sinnvoll.\nStattdessen sollte stets Optional.ofNullable() verwendet werden.\nnull kann nicht nicht in Optional\u003cT\u003e verpackt werden! (Das wäre dann eben Optional.empty().)\nLSF liefert jetzt Optional zurück public class LSF { private Set\u003cStudi\u003e sl; public Optional\u003cStudi\u003e getBestStudi() throws NullPointerException { // Fehler: Es gibt noch keine Sammlung if (sl == null) throw new NullPointerException(\"There ain't any collection\"); Studi best = null; for (Studi s : sl) { if (best == null) best = s; if (best.credits() \u003c s.credits()) best = s; } // Entweder Optional.empty() (wenn best==null) oder Optional.of(best) sonst return Optional.ofNullable(best); } } Das Beispiel soll verdeutlichen, dass man im Fehlerfall nicht einfach null oder Optional.empty() zurückliefern soll, sondern eine passende Exception werfen soll.\nWenn die Liste aber leer ist, stellt dies keinen Fehler dar! Es handelt sich um den Fall \"kein Wert vorhanden\". In diesem Fall wird statt null nun ein Optional.empty() zurückgeliefert, also ein Objekt, auf dem der Aufrufer die üblichen Methoden aufrufen kann.\nZugriff auf Optional-Objekte In der funktionalen Programmierung gibt es schon lange das Konzept von Optional, in Haskell ist dies beispielsweise die Monade Maybe. Allerdings ist die Einbettung in die Sprache von vornherein mit berücksichtigt worden, insbesondere kann man hier sehr gut mit Pattern Matching in der Funktionsdefinition auf den verpackten Inhalt reagieren.\nIn Java gibt es die Methode Optional#isEmpty(), die einen Boolean zurückliefert und prüft, ob es sich um ein leeres Optional handelt oder ob hier ein Wert \"verpackt\" ist.\nFür den direkten Zugriff auf die Werte gibt es die Methoden Optional#orElseThrow() und Optional#orElse(). Damit kann man auf den verpackten Wert zugreifen, oder es wird eine Exception geworfen bzw. ein Ersatzwert geliefert.\nZusätzlich gibt es Optional#isPresent(), die als Parameter ein java.util.function.Consumer erwartet, also ein funktionales Interface mit einer Methode void accept(T), die das Objekt verarbeitet.\nStudi best; // Testen und dann verwenden if (!lsf.getBestStudi().isEmpty()) { best = lsf.getBestStudi().get(); // mach was mit dem Studi ... } // Arbeite mit Consumer lsf.getBestStudi().ifPresent(studi -\u003e { // mach was mit dem Studi ... }); // Studi oder Alternative (wenn Optional.empty()) best = lsf.getBestStudi().orElse(anne); // Studi oder NoSuchElementException (wenn Optional.empty()) best = lsf.getBestStudi().orElseThrow(); Es gibt noch eine Methode get(), die so verhält wie orElseThrow(). Da man diese Methode vom Namen her schnell mit einem Getter verwechselt, ist sie mittlerweile deprecated.\nAnmerkung: Da getBestStudi() eine NullPointerException werfen kann, sollte der Aufruf möglicherweise in ein try/catch verpackt werden. Dito für orElseThrow().\nBeispiel: optional.traditional.Demo Einsatz mit Stream-API public class LSF { ... public Optional\u003cStudi\u003e getBestStudi() throws NullPointerException { if (sl == null) throw new NullPointerException(\"There ain't any collection\"); return sl.stream() .sorted((s1, s2) -\u003e s2.credits() - s1.credits()) .findFirst(); } } public static void main(String... args) { ... String name = lsf.getBestStudi() .map(Studi::name) .orElseThrow(); } Beispiel: optional.streams.Demo Im Beispiel wird in getBestStudi() die Sammlung als Stream betrachtet, über die Methode sorted() und den Lamda-Ausdruck für den Comparator sortiert (\"falsch\" herum: absteigend in den Credits der Studis in der Sammlung), und findFirst() ist die terminale Operation auf dem Stream, die ein Optional\u003cStudi\u003e zurückliefert: entweder den Studi mit den meisten Credits (verpackt in Optional\u003cStudi\u003e) oder Optional.empty(), wenn es überhaupt keine Studis in der Sammlung gab.\nIn main() wird dieses Optional\u003cStudi\u003e mit den Stream-Methoden von Optional\u003cT\u003e bearbeitet, zunächst mit Optional#map(). Man braucht nicht selbst prüfen, ob das von getBestStudi() erhaltene Objekt leer ist oder nicht, da dies von Optional#map() erledigt wird: Es wendet die Methodenreferenz auf den verpackten Wert an (sofern dieser vorhanden ist) und liefert damit den Namen des Studis als Optional\u003cString\u003e verpackt zurück. Wenn es keinen Wert, also nur Optional.empty() von getBestStudi() gab, dann ist der Rückgabewert von Optional#map() ein Optional.empty(). Wenn der Name, also der Rückgabewert von Studi::name, null war, dann wird ebenfalls ein Optional.empty() zurückgeliefert. Dadurch wirft orElseThrow() dann eine NoSuchElementException. Man kann also direkt mit dem String name weiterarbeiten ohne extra null-Prüfung - allerdings will man noch ein Exception-Handling einbauen (dies fehlt im obigen Beispiel aus Gründen der Übersicht) ...\nWeitere Optionals Für die drei primitiven Datentypen int, long und double gibt es passende Wrapper-Klassen von Optional\u003cT\u003e: OptionalInt, OptionalLong und OptionalDouble.\nDiese verhalten sich analog zu Optional\u003cT\u003e, haben aber keine Methode ofNullable(), da dies hier keinen Sinn ergeben würde: Die drei primitiven Datentypen repräsentieren Werte - diese können nicht null sein.\nRegeln für Optional Nutze Optional nur als Rückgabe für \"kein Wert vorhanden\"\nOptional ist nicht als Ersatz für eine null-Prüfung o.ä. gedacht, sondern als Repräsentation, um auch ein \"kein Wert vorhanden\" zurückliefern zu können.\nNutze nie null für eine Optional-Variable oder einen Optional-Rückgabewert\nWenn man ein Optional als Rückgabe bekommt, sollte das niemals selbst eine null-Referenz sein. Das macht das gesamte Konzept kaputt!\nNutzen Sie stattdessen Optional.empty().\nNutze Optional.ofNullable() zum Erzeugen eines Optional\nDiese Methode verhält sich \"freundlich\" und erzeugt automatisch ein Optional.empty(), wenn das Argument null ist. Es gibt also keinen Grund, dies mit einer Fallunterscheidung selbst erledigen zu wollen.\nBevorzugen Sie Optional.ofNullable() vor einer manuellen Fallunterscheidung und dem entsprechenden Einsatz von Optional.of() und Optional.empty().\nErzeuge keine Optional als Ersatz für die Prüfung auf null\nWenn Sie auf null prüfen müssen, müssen Sie auf null prüfen. Der ersatzweise Einsatz von Optional macht es nur komplexer - prüfen müssen Sie hinterher ja immer noch.\nNutze Optional nicht in Attributen, Methoden-Parametern und Sammlungen\nNutzen Sie Optional vor allem für Rückgabewerte.\nAttribute sollten immer direkt einen Wert haben oder null, analog Parameter von Methoden o.ä. ... Hier hilft Optional nicht, Sie müssten ja trotzdem eine null-Prüfung machen, nur eben dann über den Optional, wodurch dies komplexer und schlechter lesbar wird.\nAus einem ähnlichen Grund sollten Sie auch in Sammlungen keine Optional speichern!\nVermeide den direkten Zugriff (ifPresent(), orElseThrow() ...)\nDer direkte Zugriff auf ein Optional entspricht dem Prüfen auf null und dann dem Auspacken. Dies ist nicht nur Overhead, sondern auch schlechter lesbar.\nVermeiden Sie den direkten Zugriff und nutzen Sie Optional mit den Stream-Methoden. So ist dies von den Designern gedacht.\nInteressante Links \"Using Optionals\" \"What You Might Not Know About Optional\" \"Experienced Developers Use These 7 Java Optional Tips to Remove Code Clutter\" \"Code Smells: Null\" \"Class Optional\" Wrap-Up Optional als Rückgabe für \"kein Wert vorhanden\"\nOptional.ofNullable(): Erzeugen eines Optional\nEntweder Objekt \"verpackt\" (Argument != null) Oder Optional.empty() (Argument == null) Prüfen mit isEmpty() und ifPresent()\nDirekter Zugriff mit ifPresent(), orElse() und orElseThrow()\nStream-API: map(), filter(), flatMap(), ...\nAttribute, Parameter und Sammlungen: nicht Optional nutzen\nKein Ersatz für null-Prüfung!\nSchöne Doku: \"Using Optionals\".",
    "description": "Motivation public class LSF { private Set\u003cStudi\u003e sl; public Studi getBestStudi() { if (sl == null) return null; // Fehler: Es gibt noch keine Sammlung Studi best = null; for (Studi s : sl) { if (best == null) best = s; if (best.credits() \u003c s.credits()) best = s; } return best; } } public static void main(String... args) { LSF lsf = new LSF(); Studi best = lsf.getBestStudi(); if (best != null) { String name = best.name(); if (name != null) { // mach was mit dem Namen ... } } } Problem: null wird an (zu) vielen Stellen genutzt Es gibt keinen Wert (\"not found\") Felder wurden (noch) nicht initialisiert Es ist ein Problem oder etwas Unerwartetes aufgetreten =\u003e Parameter und Rückgabewerte müssen stets auf null geprüft werden (oder Annotationen wie @NotNull eingesetzt werden ...)",
    "tags": [],
    "title": "Optional",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/modern-java/optional.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024)",
    "content": "Visitor-Pattern Observer-Pattern Template-Method-Pattern Command-Pattern",
    "description": "Visitor-Pattern Observer-Pattern Template-Method-Pattern Command-Pattern",
    "tags": [],
    "title": "Entwurfsmuster",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/pattern.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Pattern",
    "content": "Motivation: Parsen von \"5*4+3\" Zum Parsen von Ausdrücken (Expressions) könnte man diese einfache Grammatik einsetzen. Ein Ausdruck ist dabei entweder ein einfacher Integer oder eine Addition oder Multiplikation zweier Ausdrücke.\nexpr : e1=expr '*' e2=expr # MUL | e1=expr '+' e2=expr # ADD | INT # NUM ; Beim Parsen von \"5*4+3\" würde dabei der folgende Parsetree entstehen:\nStrukturen für den Parsetree Der Parsetree für diese einfache Grammatik ist ein Binärbaum. Die Regeln werden auf Knoten im Baum zurückgeführt. Es gibt Knoten mit zwei Kindknoten, und es gibt Knoten ohne Kindknoten (\"Blätter\").\nEntsprechend kann man sich einfache Klassen definieren, die die verschiedenen Knoten in diesem Parsetree repräsentieren. Als Obertyp könnte es ein (noch leeres) Interface Expr geben.\npublic interface Expr {} public class NumExpr implements Expr { private final int d; public NumExpr(int d) { this.d = d; } } public class MulExpr implements Expr { private final Expr e1; private final Expr e2; public MulExpr(Expr e1, Expr e2) { this.e1 = e1; this.e2 = e2; } } public class AddExpr implements Expr { private final Expr e1; private final Expr e2; public AddExpr(Expr e1, Expr e2) { this.e1 = e1; this.e2 = e2; } } public class DemoExpr { public static void main(final String... args) { // 5*4+3 Expr e = new AddExpr(new MulExpr(new NumExpr(5), new NumExpr(4)), new NumExpr(3)); } } Ergänzung I: Ausrechnen des Ausdrucks Es wäre nun schön, wenn man mit dem Parsetree etwas anfangen könnte. Vielleicht möchte man den Ausdruck ausrechnen?\nZum Ausrechnen des Ausdrucks könnte man dem Interface eine eval()-Methode spendieren. Jeder Knoten kann für sich entscheiden, wie die entsprechende Operation ausgewertet werden soll: Bei einer NumExpr ist dies einfach der gespeicherte Wert, bei Addition oder Multiplikation entsprechend die Addition oder Multiplikation der Auswertungsergebnisse der beiden Kindknoten.\npublic interface Expr { int eval(); } public class NumExpr implements Expr { private final int d; public NumExpr(int d) { this.d = d; } public int eval() { return d; } } public class MulExpr implements Expr { private final Expr e1; private final Expr e2; public MulExpr(Expr e1, Expr e2) { this.e1 = e1; this.e2 = e2; } public int eval() { return e1.eval() * e2.eval(); } } public class AddExpr implements Expr { private final Expr e1; private final Expr e2; public AddExpr(Expr e1, Expr e2) { this.e1 = e1; this.e2 = e2; } public int eval() { return e1.eval() + e2.eval(); } } public class DemoExpr { public static void main(final String... args) { // 5*4+3 Expr e = new AddExpr(new MulExpr(new NumExpr(5), new NumExpr(4)), new NumExpr(3)); int erg = e.eval(); } } Ergänzung II: Pretty-Print des Ausdrucks Nachdem das Ausrechnen so gut geklappt hat, will der Chef nun noch flink eine Funktion, mit der man den Ausdruck hübsch ausgeben kann:\nDas fängt an, sich zu wiederholen. Wir implementieren immer wieder ähnliche Strukturen, mit denen wir diesen Parsetree traversieren ... Und wir müssen für jede Erweiterung immer alle Expression-Klassen anpassen!\nBeispiel: direct.DemoExpr Das geht besser.\nVisitor-Pattern (Besucher-Entwurfsmuster) Das Entwurfsmuster \"Besucher\" (Visitor Pattern) lagert die Aktion beim Besuchen eines Knotens in eine separate Klasse aus.\nDazu bekommt jeder Knoten im Baum eine neue Methode, die einen Besucher akzeptiert. Dieser Besucher kümmert sich dann um die entsprechende Verarbeitung des Knotens, also um das Auswerten oder Ausgeben im obigen Beispiel.\nDie Besucher haben eine Methode, die für jeden zu bearbeitenden Knoten überladen wird. In dieser Methode findet dann die eigentliche Verarbeitung statt: Auswerten des Knotens oder Ausgeben des Knotens ...\npublic interface Expr { void accept(ExprVisitor v); } public class NumExpr implements Expr { private final int d; public NumExpr(int d) { this.d = d; } public int getValue() { return d; } public void accept(ExprVisitor v) { v.visit(this); } } public class MulExpr implements Expr { private final Expr e1; private final Expr e2; public MulExpr(Expr e1, Expr e2) { this.e1 = e1; this.e2 = e2; } public Expr getE1() { return e1; } public Expr getE2() { return e2; } public void accept(ExprVisitor v) { v.visit(this); } } public class AddExpr implements Expr { private final Expr e1; private final Expr e2; public AddExpr(Expr e1, Expr e2) { this.e1 = e1; this.e2 = e2; } public Expr getE1() { return e1; } public Expr getE2() { return e2; } public void accept(ExprVisitor v) { v.visit(this); } } public interface ExprVisitor { void visit(NumExpr e); void visit(MulExpr e); void visit(AddExpr e); } public class EvalVisitor implements ExprVisitor { private final Stack\u003cInteger\u003e erg = new Stack\u003c\u003e(); public void visit(NumExpr e) { erg.push(e.getValue()); } public void visit(MulExpr e) { e.getE1().accept(this); e.getE1().accept(this); erg.push(erg.pop() * erg.pop()); } public void visit(AddExpr e) { e.getE1().accept(this); e.getE1().accept(this); erg.push(erg.pop() + erg.pop()); } public int getResult() { return erg.peek(); } } public class PrintVisitor implements ExprVisitor { private final Stack\u003cString\u003e erg = new Stack\u003c\u003e(); public void visit(NumExpr e) { erg.push(\"NumExpr(\" + e.getValue() + \")\"); } public void visit(MulExpr e) { e.getE1().accept(this); e.getE1().accept(this); erg.push(\"MulExpr(\" + erg.pop() + \", \" + erg.pop() + \")\"); } public void visit(AddExpr e) { e.getE1().accept(this); e.getE1().accept(this); erg.push(\"AddExpr(\" + erg.pop() + \", \" + erg.pop() + \")\"); } public String getResult() { return erg.peek(); } } public class DemoExpr { public static void main(final String... args) { // 5*4+3 Expr e = new AddExpr(new MulExpr(new NumExpr(5), new NumExpr(4)), new NumExpr(3)); EvalVisitor v1 = new EvalVisitor(); e.accept(v1); int erg = v1.getResult(); PrintVisitor v2 = new PrintVisitor(); e.accept(v2); String s = v2.getResult(); } } Implementierungsdetail In den beiden Klasse AddExpr und MulExpr müssen auch die beiden Kindknoten besucht werden, d.h. hier muss der Baum weiter traversiert werden.\nMan kann sich überlegen, diese Traversierung in den Klassen AddExpr und MulExpr selbst anzustoßen.\nAlternativ könnte auch der Visitor die Traversierung vornehmen. Gerade bei der Traversierung von Datenstrukturen ist diese Variante oft von Vorteil, da man hier unterschiedliche Traversierungsarten haben möchte (Breitensuche vs. Tiefensuche, Pre-Order vs. Inorder vs. Post-Order, ...) und diese elegant in den Visitor verlagern kann.\nBeispiel Traversierung intern (in den Knotenklassen): visitor.visit.intrav.DemoExpr Beispiel Traversierung extern (im Visitor): visitor.visit.extrav.DemoExpr (Double-) Dispatch Zur Laufzeit wird in accept() der Typ des Visitors aufgelöst und dann in visit() der Typ der zu besuchenden Klasse. Dies nennt man auch \"Double-Dispatch\".\nHinweis I Man könnte versucht sein, die accept()-Methode aus den Knotenklassen in die gemeinsame Basisklasse zu verlagern: Statt\npublic void accept(ExprVisitor v) { v.visit(this); } in jeder Knotenklasse einzeln zu definieren, könnte man das doch einmalig in der Basisklasse definieren:\npublic abstract class Expr { /** Akzeptiere einen Visitor für die Verarbeitung */ public void accept(ExprVisitor v) { v.visit(this); } } Dies wäre tatsächlich schön, weil man so Code-Duplizierung vermeiden könnte. Aber es funktioniert in Java leider nicht. (Warum?)\nHinweis II Während die accept()-Methode nicht in die Basisklasse der besuchten Typen (im Bild oben die Klasse Elem bzw. im Beispiel oben die Klasse Expr) verlagert werden kann, kann man aber die visit()-Methoden im Interface Visitor durchaus als Default-Methoden im Interface implementieren.\nAusrechnen des Ausdrucks mit einem Visitor Demo: visitor.visit.extrav.DemoExpr Wrap-Up Visitor-Pattern: Auslagern der Traversierung in eigene Klassenstruktur\nKlassen der Datenstruktur\nbekommen eine accept()-Methode für einen Visitor rufen den Visitor mit sich selbst als Argument auf Visitor\nhat für jede Klasse eine Überladung der visit()-Methode Rückgabewerte schwierig: Intern halten oder per return (dann aber unterschiedliche visit()-Methoden für die verschiedenen Rückgabetypen!) (Double-) Dispatch: Zur Laufzeit wird in accept() der Typ des Visitors und in visit() der Typ der zu besuchenden Klasse aufgelöst",
    "description": "Motivation: Parsen von \"5*4+3\" Zum Parsen von Ausdrücken (Expressions) könnte man diese einfache Grammatik einsetzen. Ein Ausdruck ist dabei entweder ein einfacher Integer oder eine Addition oder Multiplikation zweier Ausdrücke.\nexpr : e1=expr '*' e2=expr # MUL | e1=expr '+' e2=expr # ADD | INT # NUM ; Beim Parsen von \"5*4+3\" würde dabei der folgende Parsetree entstehen:",
    "tags": [],
    "title": "Visitor-Pattern",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/pattern/visitor.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Praktikum",
    "content": "A06.1: Git: Pull-Requests (und Code-Formatierung und -Dokumentation) (20%) Forken Sie das \"Stream-API\"-Repo und erzeugen Sie eine lokale Arbeitskopie von Ihrem Fork.\nSie finden die Vorgaben für jede Teilaufgabe in einem eigenen Branch. Checken Sie diese Branches lokal als Tracking-Branches aus und bearbeiten Sie die Teilaufgaben jeweils in ihrem eigenen Branch. Pushen Sie Ihre Änderungen in Ihren Fork zurück und erstellen Sie dort je einen Pull-Request auf Ihren eigenen master-Branch.\nBitte lassen Sie die Pull-Requests bis zur Vorstellung im Praktikum offen.\nAchten Sie darauf, alle Schritte nachvollziehbar in Ihrer Arbeitskopie per Git-Commit festzuhalten. Demonstrieren Sie im Praktikum, wie Sie mit den Pull-Requests arbeiten.\nIhr Code soll einheitlich formatiert und dokumentiert sein. Sie können beides prüfen: ./gradlew spotlessCheck für die Formatierung und ./gradlew checkstyleMain für die Dokumentation1 mit Javadoc.2 Während Sie die Dokumentation bei Fehlern manuell anpassen müssen (siehe Lektion “Javadoc”), können Sie mit ./gradlew spotlessApply den Code automatisch formatieren lassen - tun Sie das am besten vor jedem Commit.\nStream-API A06.2: Stream-API: Task I (10%) Betrachten Sie den Branch task_i. Sie finden im Package streamapi einige Hilfsklassen sowie in der Datei Main.java einen Starter für diese erste Teilaufgabe.\nIn der Funktion Main#students wird für eine Liste von Student-Objekten die Summe der gesammelten ECTS berechnet.\nSchreiben Sie den Body dieser Methode so um, dass die selbe Funktionalität unter Nutzung der Java-Stream-API erreicht wird. Bevorzugen Sie dabei nach Möglichkeit Methoden-Referenzen vor Lambda-Ausdrücken.\nA06.3: Stream-API: Task II (10%) Betrachten Sie nun den Branch task_ii. Sie finden wieder im Package streamapi einige Hilfsklassen sowie in der Datei Main.java einen Starter für diese zweite Teilaufgabe.\nIn der Funktion Main#ifmCps wird für eine Liste von Student-Objekten die Menge der gesammelten ECTS bestimmt. Dabei werden nur Studierende des Informatik-Studiengangs berücksichtigt.\nWas bedeutet \"die Menge der gesammelten ECTS\", was ist die Mengen-Eigenschaft?\nSchreiben Sie den Body dieser Methode so um, dass die selbe Funktionalität unter Nutzung der Java-Stream-API erreicht wird. Bevorzugen Sie dabei nach Möglichkeit Methoden-Referenzen vor Lambda-Ausdrücken.\nA06.4: Stream-API: Task III (20%) Betrachten Sie nun den Branch task_iii. Sie finden wieder im Package streamapi einige Hilfsklassen sowie in der Datei Main.java einen Starter für diese dritte Teilaufgabe.\nIn der Funktion Main#random werden zunächst zehn zufällige Integerwerte im Bereich zwischen 0 (inklusive) und 10 (exklusive) berechnet. Anschließend werden diese Zahlen weiter verarbeitet und das Ergebnis zurückgeliefert.\nSchreiben Sie den Body dieser Methode so um, dass die selbe Funktionalität unter Nutzung der Java-Stream-API erreicht wird. Bevorzugen Sie dabei nach Möglichkeit Methoden-Referenzen vor Lambda-Ausdrücken.\nA06.5: Stream-API: Task IV+V (40%) (Verteilung: 20%, 20%)\nBetrachten Sie nun den Branch task_iv_v. Sie finden wieder im Package streamapi einige Hilfsklassen sowie in der Datei Main.java einen Starter für diese vierte Teilaufgabe.\nRessourcen in Java\nIn der Funktion Main#getResourceAsStream soll eine Textdatei als InputStream zum Einlesen geöffnet werden. Die Datei soll dabei im Ressourcen-Ordner des Projekts gesucht werden.\nInformieren Sie sich im Web über den Umgang in Java mit Ressourcen. Welcher Ordner wurde in der vorgegebenen Gradle-Konfiguration als Ressourcen-Ordner für das Projekt definiert?\nSchreiben Sie den Body dieser Methode so um, dass die zu dem übergebenen Dateinamen passende Ressource im Kontext der aktuellen Klasse als InputStream geöffnet wird und geben Sie diesen als Ergebnis zurück.\nHinweis: Diese Teilaufgabe ist die Voraussetzung für die Bearbeitung der nächsten Teilaufgabe. Wenn Sie diese Aufgabe nicht hinbekommen sollten, dann definieren Sie sich ersatzweise einen Text Block (Multi-line String) mit dem Inhalt der Textdatei und erzeugen daraus einen InputStream. Das zählt dann aber nicht als \"bearbeitet\".\nEinlesen von Textdateien\nIn der Funktion Main#resources wird eine Textdatei im Ressourcen-Ordner über eine interne Hilfsfunktion (siehe vorige Teilaufgabe) als InputStream zum Einlesen geöffnet. Über einen BufferedReader werden alle Zeilen eingelesen und anschließend alle Zeilen, die mit dem Buchstaben \"a\" beginnen und mindestens zwei Zeichen lang sind, wieder zusammen gefügt (mit einem Zeilenumbruch \\n als Trenner).\nSchreiben Sie den Body dieser Methode so um, dass die selbe Funktionalität unter Nutzung der Java-Stream-API erreicht wird. Bevorzugen Sie dabei nach Möglichkeit Methoden-Referenzen vor Lambda-Ausdrücken.\nA06.6: Bonus-Aufgaben (+5%) Machen Sie aus der Klasse streamapi.Student eine Record-Klasse.\nzumindest für den syntaktischen Aspekt ... ↩︎\nSie können auch beides zusammen per ./gradlew check prüfen lassen. ↩︎",
    "description": "A06.1: Git: Pull-Requests (und Code-Formatierung und -Dokumentation) (20%) Forken Sie das \"Stream-API\"-Repo und erzeugen Sie eine lokale Arbeitskopie von Ihrem Fork.\nSie finden die Vorgaben für jede Teilaufgabe in einem eigenen Branch. Checken Sie diese Branches lokal als Tracking-Branches aus und bearbeiten Sie die Teilaufgaben jeweils in ihrem eigenen Branch. Pushen Sie Ihre Änderungen in Ihren Fork zurück und erstellen Sie dort je einen Pull-Request auf Ihren eigenen master-Branch.\nBitte lassen Sie die Pull-Requests bis zur Vorstellung im Praktikum offen.",
    "tags": [],
    "title": "Blatt 06: Stream-API (Git Remote, Streams)",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/homework/b06.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Testing",
    "content": "Hands-On (10 Minuten): Wieviel und was muss man testen? public class Studi { private int credits = 0; public void addToCredits(int credits) { if (credits \u003c 0) { throw new IllegalArgumentException(\"Negative Credits!\"); } if (this.credits + credits \u003e 210) { throw new IllegalArgumentException(\"Mehr als 210 Credits!\"); } this.credits += credits; } } JEDE Methode mindestens testen mit/auf: Positive Tests: Gutfall (Normalfall) =\u003e \"gültige ÄK/GW\" Negativ-Tests (Fehlbedienung, ungültige Werte) =\u003e \"ungültige ÄK/GW\" Rand- bzw. Extremwerte =\u003e GW Exceptions =\u003e Anforderungen abgedeckt (Black-Box)?\n=\u003e Wichtige Pfade im Code abgedeckt (White-Box)?\nPraxis Je kritischer eine Klasse/Methode/Artefakt ist, um so intensiver testen! Suche nach Kompromissen: Testkosten vs. Kosten von Folgefehlern; beispielsweise kein Test generierter Methoden =\u003e \"Erzeugen\" der Testfälle über die Äquivalenzklassenbildung und Grenzwertanalyse (siehe nächste Folien). Mehr dann später im Wahlfach \"Softwarequalität\" ...\nÄquivalenzklassenbildung Beispiel: Zu testende Methode mit Eingabewert x, der zw. 10 und 100 liegen soll\nZerlegung der Definitionsbereiche in Äquivalenzklassen (ÄK):\nDisjunkte Teilmengen, wobei Werte einer ÄK führen zu gleichartigem Verhalten Annahme: Eingabeparameter sind untereinander unabhängig\nUnterscheidung gültige und ungültige ÄK\nBemerkungen Hintergrund: Da die Werte einer ÄK zu gleichartigem Verhalten führen, ist es egal, welchen Wert man aus einer ÄK für den Test nimmt.\nFormal hat man eine ungültige ÄK (d.h. die Menge aller ungültigen Werte). In der Programmierpraxis macht es aber einen Unterschied, ob es sich um Werte unterhalb oder oberhalb des erlaubten Wertebereichs handelt (Fallunterscheidung). Beispiel: Eine Funktion soll Werte zwischen 10 und 100 verarbeiten. Dann sind alle Werte kleiner 10 oder größer 100 mathematisch gesehen in der selben ÄK \"ungültig\". Praktisch macht es aber Sinn, eine ungültige ÄK für \"kleiner 10\" und eine weitere ungültige ÄK für \"größer 100\" zu betrachten ...\nTraditionell betrachtet man nur die Eingabeparameter. Es kann aber Sinn machen, auch die Ausgabeseite zu berücksichtigen (ist aber u.U. nur schwierig zu realisieren).\nFaustregeln bei der Bildung von ÄK Falls eine Beschränkung einen Wertebereich spezifiziert: Aufteilung in eine gültige und zwei ungültige ÄK\nBeispiel: Eingabewert x soll zw. 10 und 100 liegen\nGültige ÄK: $[10, 100]$ Ungültige ÄKs: $x \u003c 10$ und $100 \u003c x$ Falls eine Beschränkung eine minimale und maximale Anzahl von Werten spezifiziert: Aufteilung in eine gültige und zwei ungültige ÄK\nBeispiel: Jeder Studi muss pro Semester an mindestens einer LV teilnehmen, maximal sind 5 LVs erlaubt.\nGültige ÄK: $1 \\le x \\le 5$ Ungültige ÄKs: $x = 0$ (keine Teilnahme) und $5 \u003c x$ (mehr als 5 Kurse) Falls eine Beschränkung eine Menge von Werten spezifiziert, die möglicherweise unterschiedlich behandelt werden: Für jeden Wert dieser Menge eine eigene gültige ÄK erstellen und zusätzlich insgesamt eine ungültige ÄK\nBeispiel: Das Hotel am Urlaubsort ermöglicht verschiedene Freizeitaktivitäten: Segway-fahren, Tauchen, Tennis, Golf\nGültige ÄKs: Segway-fahren Tauchen Tennis Golf Ungültige ÄK: \"alles andere\" Falls eine Beschränkung eine Situation spezifiziert, die zwingend erfüllt sein muss: Aufteilung in eine gültige und eine ungültige ÄK\nHinweis: Werden Werte einer ÄK vermutlich nicht gleichwertig behandelt, dann erfolgt die Aufspaltung der ÄK in kleinere ÄKs. Das ist im Grunde die analoge Überlegung zu mehreren ungültigen ÄKs.\nÄKs sollten für die weitere Arbeit einheitlich und eindeutig benannt werden. Typisches Namensschema: \"gÄKn\" und \"uÄKn\" für gültige bzw. ungültige ÄKs mit der laufenden Nummer $n$.\nÄK: Erstellung der Testfälle Jede ÄK durch mindestens einen TF abdecken\nDabei pro Testfall\nmehrere gültige ÄKs kombinieren, oder genau eine ungültige ÄK untersuchen (restl. Werte aus gültigen ÄK auffüllen; diese gelten dann aber nicht als getestet!) Im Prinzip muss man zur Erstellung der Testfälle (TF) eine paarweise vollständige Kombination über die ÄK bilden, d.h. jede ÄK kommt mit jeder anderen ÄK in einem TF zur Ausführung.\nErinnerung: Annahme: Eingabeparameter sind untereinander unabhängig! =\u003e Es reicht, wenn jede gültige ÄK einmal in einem TF zur Ausführung kommt. =\u003e Kombination verschiedener gültiger ÄK in einem TF.\nAchtung: Dies gilt nur für die gültigen ÄK! Bei den ungültigen ÄKs dürfen diese nicht miteinander in einem TF kombiniert werden! Bei gleichzeitiger Behandlung verschiedener ungültiger ÄK bleiben u.U. Fehler unentdeckt, da sich die Wirkungen der ungültigen ÄK überlagern!\nFür jeden Testfall (TF) wird aus den zu kombinierenden ÄK ein zufälliger Repräsentant ausgewählt.\nÄK: Beispiel: Eingabewert x soll zw. 10 und 100 liegen Äquivalenzklassen Eingabe gültige ÄK ungültige ÄK x gÄK1: $[10, 100]$ uÄK2: $x \u003c 10$ uÄK3: $100 \u003c x$ Tests Testnummer 1 2 3 geprüfte ÄK gÄK1 uÄK2 uÄK3 x 42 7 120 Erwartetes Ergebnis OK Exception Exception Grenzwertanalyse Beobachtung: Grenzen in Verzweigungen/Schleifen kritisch\nGrenzen der ÄK (kleinste und größte Werte) zusätzlich testen \"gültige Grenzwerte\" (gGW): Grenzwerte von gültigen ÄK \"ungültige Grenzwerte\" (uGW): Grenzwerte von ungültigen ÄK Zusätzlich sinnvoll: Weitere grenznahe Werte, d.h. weitere Werte \"rechts\" und \"links\" der Grenze nutzen.\nBildung der Testfälle:\nJeder GW muss in mind. einem TF vorkommen Pro TF darf ein GW (gültig oder ungültig) verwendet werden, die restlichen Parameter werden (mit zufälligen Werten) aus gültigen ÄK aufgefüllt, um mögliche Grenzwertprobleme nicht zu überlagern.\nGW: Beispiel: Eingabewert x soll zw. 10 und 100 liegen Äquivalenzklassen Eingabe gültige ÄK ungültige ÄK x gÄK1: $[10, 100]$ uÄK2: $x \u003c 10$ uÄK3: $100 \u003c x$ Grenzwertanalyse Zusätzliche Testdaten: 9 (uÄK2o) und 10 (gÄK1u) sowie 100 (gÄK1o) und 101 (uÄK3u)\nTests Testnummer 4 5 6 7 geprüfter GW gÄK1u gÄK1o uÄK2o uÄK3u x 10 100 9 101 Erwartetes Ergebnis OK OK Exception Exception Hinweis: Die Ergebnisse der GW-Analyse werden zusätzlich zu den Werten aus der ÄK-Analyse eingesetzt. Für das obige Beispiel würde man also folgende Tests aus der kombinierten ÄK- und GW-Analyse erhalten:\nTestnummer 1 2 3 4 5 6 7 geprüfte(r) ÄK/GW gÄK1 uÄK2 uÄK3 gÄK1u gÄK1o uÄK2o uÄK3u x 42 7 120 10 100 9 101 Erwartetes Ergebnis OK Exception Exception OK OK Exception Exception Anmerkung: Analyse abhängiger Parameter Wenn das Ergebnis von der Kombination der Eingabewerte abhängt, dann sollte man dies bei der Äquivalenzklassenbildung berücksichtigen: Die ÄK sind in diesem Fall in Bezug auf die Kombinationen zu bilden!\nSchauen Sie sich dazu das Beispiel im [Kleuker2019], Abschnitt \"4.3 Analyse abhängiger Parameter\" an.\nDie einfache ÄK-Bildung würde in diesem Fall versagen, da die Eingabewerte nicht unabhängig sind. Leider ist die Betrachtung der möglichen Kombinationen u.U. eine sehr komplexe Aufgabe ...\nAnaloge Überlegungen gelten auch für die ÄK-Bildung im Zusammenhang mit objektorientierter Programmierung. Die Eingabewerte und der Objektzustand müssen dann gemeinsam bei der ÄK-Bildung betrachtet werden!\nVergleiche [Kleuker2019], Abschnitt \"4.4 Äquivalenzklassen und Objektorientierung\".\nWrap-Up Gründliches Testen ist ebenso viel Aufwand wie Coden Äquivalenzklassenbildung und Grenzwertanalyse",
    "description": "Hands-On (10 Minuten): Wieviel und was muss man testen? public class Studi { private int credits = 0; public void addToCredits(int credits) { if (credits \u003c 0) { throw new IllegalArgumentException(\"Negative Credits!\"); } if (this.credits + credits \u003e 210) { throw new IllegalArgumentException(\"Mehr als 210 Credits!\"); } this.credits += credits; } } JEDE Methode mindestens testen mit/auf: Positive Tests: Gutfall (Normalfall) =\u003e \"gültige ÄK/GW\" Negativ-Tests (Fehlbedienung, ungültige Werte) =\u003e \"ungültige ÄK/GW\" Rand- bzw. Extremwerte =\u003e GW Exceptions =\u003e Anforderungen abgedeckt (Black-Box)?",
    "tags": [],
    "title": "Testfallermittlung: Wie viel und was muss man testen?",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/testing/testcases.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Testing",
    "content": "Motivation: Entwicklung einer Studi-/Prüfungsverwaltung Szenario Zwei Teams entwickeln eine neue Studi-/Prüfungsverwaltung für die Hochschule. Ein Team modelliert dabei die Studierenden, ein anderes Team modelliert die Prüfungsverwaltung LSF.\nTeam A:\npublic class Studi { String name; LSF lsf; public Studi(String name, LSF lsf) { this.name = name; this.lsf = lsf; } public boolean anmelden(String modul) { return lsf.anmelden(name, modul); } public boolean einsicht(String modul) { return lsf.ergebnis(name, modul) \u003e 50; } } Team B:\npublic class LSF { public boolean anmelden(String name, String modul) { throw new UnsupportedOperationException(); } public int ergebnis(String name, String modul) { throw new UnsupportedOperationException(); } } Team B kommt nicht so recht vorwärts, Team A ist fertig und will schon testen.\nWie kann Team A seinen Code testen?\nOptionen:\nGar nicht testen?! Das LSF selbst implementieren? Wer pflegt das dann? =\u003e manuell implementierte Stubs Das LSF durch einen Mock ersetzen =\u003e Einsatz der Bibliothek \"mockito\" Motivation Mocking und Mockito Mockito ist ein Mocking-Framework für JUnit. Es simuliert das Verhalten eines realen Objektes oder einer realen Methode.\nWofür brauchen wir denn jetzt so ein Mocking-Framework überhaupt?\nWir wollen die Funktionalität einer Klasse isoliert vom Rest testen können. Dabei stören uns aber bisher so ein paar Dinge:\nArbeiten mit den echten Objekten ist langsam (zum Beispiel aufgrund von Datenbankenzugriffen) Objekte beinhalten oft komplexe Abhängigkeiten, die in Tests schwer abzudecken sind Manchmal existiert der zu testende Teil einer Applikation auch noch gar nicht, sondern es gibt nur die Interfaces. Oder es gibt unschöne Seiteneffekte beim Arbeiten mit den realen Objekten. Zum Beispiel könnte es sein, das immer eine E-Mail versendet wird, wenn wir mit einem Objekt interagieren. In solchen Situationen wollen wir eine Möglichkeit haben, das Verhalten eines realen Objektes bzw. der Methoden zu simulieren, ohne dabei die originalen Methoden aufrufen zu müssen. (Manchmal möchte man das dennoch, aber dazu später mehr...)\nUnd genau hier kommt Mockito ins Spiel. Mockito hilft uns dabei, uns von den externen Abhängigkeiten zu lösen, indem es sogenannte Mocks, Stubs oder Spies anbietet, mit denen sich das Verhalten der realen Objekte simulieren/überwachen und testen lässt.\nAber was genau ist denn jetzt eigentlich Mocking? Ein Mock-Objekt (\"etwas vortäuschen\") ist im Software-Test ein Objekt, das als Platzhalter (Attrappe) für das echte Objekt verwendet wird.\nMocks sind in JUnit-Tests immer dann nützlich, wenn man externe Abhängigkeiten hat, auf die der eigene Code zugreift. Das können zum Beispiel externe APIs sein oder Datenbanken etc. ... Mocks helfen einem beim Testen nun dabei, sich von diesen externen Abhängigkeiten zu lösen und seine Softwarefunktionalität dennoch schnell und effizient testen zu können ohne evtl. auftretende Verbindungsfehler oder andere mögliche Seiteneffekte der externen Abhängigkeiten auszulösen.\nDabei simulieren Mocks die Funktionalität der externen APIs oder Datenbankzugriffe. Auf diese Weise ist es möglich Softwaretests zu schreiben, die scheinbar die gleichen Methoden aufrufen, die sie auch im regulären Softwarebetrieb nutzen würden, allerdings werden diese wie oben erwähnt allerdings für die Tests nur simuliert.\nMocking ist also eine Technik, die in Softwaretests verwendet wird, in denen die gemockten Objekte anstatt der realen Objekte zu Testzwecken genutzt werden. Die gemockten Objekte liefern dabei bei einem vom Programmierer bestimmten (Dummy-) Input, einen dazu passenden gelieferten (Dummy-) Output, der durch seine vorhersagbare Funktionalität dann in den eigentlichen Testobjekten gut für den Test nutzbar ist.\nDabei ist es von Vorteil die drei Grundbegriffe \"Mock\", \"Stub\" oder \"Spy\", auf die wir in der Vorlesung noch häufiger treffen werden, voneinander abgrenzen und unterscheiden zu können.\nDabei bezeichnet ein Stub: Ein Stub ist ein Objekt, dessen Methoden nur mit einer minimalen Logik für den Test implementiert wurden. Häufig werden dabei einfach feste (konstante) Werte zurückgeliefert, d.h. beim Aufruf einer Methode wird unabhängig von der konkreten Eingabe immer die selbe Ausgabe zurückgeliefert. Mock: Ein Mock ist ein Objekt, welches im Gegensatz zum Stub bei vorher definierten Funktionsaufrufen mit vorher definierten Argumente eine definierte Rückgabe liefert. Spy: Ein Spy ist ein Objekt, welches Aufrufe und übergebene Werte protokolliert und abfragbar macht. Es ist also eine Art Wrapper um einen Stub oder einen Mock. Mockito Setup Gradle: build.gradle\ndependencies { implementation 'junit:junit:4.13.2' implementation 'org.mockito:mockito-core:4.5.1' } Maven: pom.xml\n\u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.13.2\u003c/version\u003e \u003c/dependency\u003e \u003cgroupId\u003eorg.mockito\u003c/groupId\u003e \u003cartifactId\u003emockito-core\u003c/artifactId\u003e \u003cversion\u003e4.5.1\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e Manuell Stubs implementieren Team A könnte manuell das LSF rudimentär implementieren (nur für die Tests, einfach mit festen Rückgabewerten): Stubs\npublic class StudiStubTest { Studi studi; LSF lsf; @Before public void setUp() { lsf = new LsfStub(); studi = new Studi(\"Harald\", lsf); } @Test public void testAnmelden() { assertTrue(studi.anmelden(\"PM-Dungeon\")); } @Test public void testEinsicht() { assertTrue(studi.einsicht(\"PM-Dungeon\")); } // Stub für das noch nicht fertige LSF class LsfStub extends LSF { public boolean anmelden(String name, String modul) { return true; } public int ergebnis(String name, String modul) { return 80; } } } Problem: Wartung der Tests (wenn das richtige LSF fertig ist) und Wartung der Stubs (wenn sich die Schnittstelle des LSF ändert, muss auch der Stub nachgezogen werden).\nProblem: Der Stub hat nur eine Art minimale Default-Logik (sonst könnte man ja das LSF gleich selbst implementieren). Wenn man im Test andere Antworten braucht, müsste man einen weiteren Stub anlegen ...\nDemo hsbi.StudiStubTest Mockito: Mocking von ganzen Klassen Lösung: Mocking der Klasse LSF mit Mockito für den Test von Studi: mock().\npublic class StudiMockTest { Studi studi; LSF lsf; @Before public void setUp() { lsf = mock(LSF.class); studi = new Studi(\"Harald\", lsf); } @Test public void testAnmelden() { when(lsf.anmelden(anyString(), anyString())).thenReturn(true); assertTrue(studi.anmelden(\"PM-Dungeon\")); } @Test public void testEinsichtI() { when(lsf.ergebnis(\"Harald\", \"PM-Dungeon\")).thenReturn(80); assertTrue(studi.einsicht(\"PM-Dungeon\")); } @Test public void testEinsichtII() { when(lsf.ergebnis(\"Harald\", \"PM-Dungeon\")).thenReturn(40); assertFalse(studi.einsicht(\"PM-Dungeon\")); } } Der Aufruf mock(LSF.class) erzeugt einen Mock der Klasse (oder des Interfaces) LSF. Dabei wird ein Objekt vom Typ LSF erzeugt, mit dem man dann wie mit einem normalen Objekt weiter arbeiten kann. Die Methoden sind allerdings nicht implementiert ...\nMit Hilfe von when().thenReturn() kann man definieren, was genau beim Aufruf einer bestimmten Methode auf dem Mock passieren soll, d.h. welcher Rückgabewert entsprechend zurückgegeben werden soll. Hier kann man dann für bestimmte Argumentwerte andere Rückgabewerte definieren. when(lsf.ergebnis(\"Harald\", \"PM-Dungeon\")).thenReturn(80) gibt also für den Aufruf von ergebnis mit den Argumenten \"Harald\" und \"PM-Dungeon\" auf dem Mock lsf den Wert 80 zurück.\nDies kann man in weiten Grenzen flexibel anpassen.\nMit Hilfe der Argument-Matcher anyString() wird jedes String-Argument akzeptiert.\nDemo hsbi.StudiMockTest Mockito: Spy = Wrapper um ein Objekt Team B hat das LSF nun implementiert und Team A kann es endlich für die Tests benutzen. Aber das LSF hat eine Zufallskomponente (ergebnis()). Wie kann man nun die Reaktion des Studis testen (einsicht())?\nLösung: Mockito-Spy als partieller Mock einer Klasse (Wrapper um ein Objekt): spy().\npublic class StudiSpyTest { Studi studi; LSF lsf; @Before public void setUp() { lsf = spy(LSF.class); studi = new Studi(\"Harald\", lsf); } @Test public void testAnmelden() { assertTrue(studi.anmelden(\"PM-Dungeon\")); } @Test public void testEinsichtI() { doReturn(80).when(lsf).ergebnis(\"Harald\", \"PM-Dungeon\"); assertTrue(studi.einsicht(\"PM-Dungeon\")); } @Test public void testEinsichtII() { doReturn(40).when(lsf).ergebnis(\"Harald\", \"PM-Dungeon\"); assertFalse(studi.einsicht(\"PM-Dungeon\")); } } Der Aufruf spy(LSF.class) erzeugt einen Spy um ein Objekt der Klasse LSF. Dabei bleiben zunächst die Methoden in LSF erhalten und können aufgerufen werden, sie können aber auch mit einem (partiellen) Mock überlagert werden. Der Spy zeichnet wie der Mock die Interaktion mit dem Objekt auf.\nMit Hilfe von doReturn().when() kann man definieren, was genau beim Aufruf einer bestimmten Methode auf dem Spy passieren soll, d.h. welcher Rückgabewert entsprechend zurückgegeben werden soll. Hier kann man analog zum Mock für bestimmte Argumentwerte andere Rückgabewerte definieren. doReturn(40).when(lsf).ergebnis(\"Harald\", \"PM-Dungeon\") gibt also für den Aufruf von ergebnis mit den Argumenten \"Harald\" und \"PM-Dungeon\" auf dem Spy lsf den Wert 40 zurück.\nWenn man die Methoden nicht mit einem partiellen Mock überschreibt, dann wird einfach die originale Methode aufgerufen (Beispiel: In studi.anmelden(\"PM-Dungeon\") wird lsf.anmelden(\"Harald\", \"PM-Dungeon\") aufgerufen.).\nAuch hier können Argument-Matcher wie anyString() eingesetzt werden.\nDemo hsbi.StudiSpyTest Wurde eine Methode aufgerufen? public class VerifyTest { @Test public void testAnmelden() { LSF lsf = mock(LSF.class); Studi studi = new Studi(\"Harald\", lsf); when(lsf.anmelden(\"Harald\", \"PM-Dungeon\")).thenReturn(true); assertTrue(studi.anmelden(\"PM-Dungeon\")); verify(lsf).anmelden(\"Harald\", \"PM-Dungeon\"); verify(lsf, times(1)).anmelden(\"Harald\", \"PM-Dungeon\"); verify(lsf, atLeast(1)).anmelden(\"Harald\", \"PM-Dungeon\"); verify(lsf, atMost(1)).anmelden(\"Harald\", \"PM-Dungeon\"); verify(lsf, never()).ergebnis(\"Harald\", \"PM-Dungeon\"); verifyNoMoreInteractions(lsf); } } Mit der Methode verify() kann auf einem Mock oder Spy überprüft werden, ob und wie oft und in welcher Reihenfolge Methoden aufgerufen wurden und mit welchen Argumenten. Auch hier lassen sich wieder Argument-Matcher wie anyString() einsetzen.\nEin einfaches verify(mock) prüft dabei, ob die entsprechende Methode exakt einmal vorher aufgerufen wurde. Dies ist äquivalent zu verify(mock, times(1)). Analog kann man mit den Parametern atLeast() oder atMost bestimmte Unter- oder Obergrenzen für die Aufrufe angeben und mit never() prüfen, ob es gar keinen Aufruf vorher gab.\nverifyNoMoreInteractions(lsf) ist interessant: Es ist genau dann true, wenn es außer den vorher abgefragten Interaktionen keinerlei sonstigen Interaktionen mit dem Mock oder Spy gab.\nLSF lsf = mock(LSF.class); Studi studi = new Studi(\"Harald\", lsf); when(lsf.anmelden(\"Harald\", \"PM-Dungeon\")).thenReturn(true); InOrder inOrder = inOrder(lsf); assertTrue(studi.anmelden(\"PM-Dungeon\")); studi.anmelden(\"Wuppie\"); inOrder.verify(lsf).anmelden(\"Harald\", \"Wuppie\"); inOrder.verify(lsf).anmelden(\"Harald\", \"PM-Dungeon\"); Mit InOrder lassen sich Aufrufe auf einem Mock/Spy oder auch auf verschiedenen Mocks/Spies in eine zeitliche Reihenfolge bringen und so überprüfen.\nDemo hsbi.VerifyTest Fangen von Argumenten public class MatcherTest { @Test public void testAnmelden() { LSF lsf = mock(LSF.class); Studi studi = new Studi(\"Harald\", lsf); when(lsf.anmelden(anyString(), anyString())).thenReturn(false); when(lsf.anmelden(\"Harald\", \"PM-Dungeon\")).thenReturn(true); assertTrue(studi.anmelden(\"PM-Dungeon\")); assertFalse(studi.anmelden(\"Wuppie?\")); verify(lsf, times(1)).anmelden(\"Harald\", \"PM-Dungeon\"); verify(lsf, times(1)).anmelden(\"Harald\", \"Wuppie?\"); verify(lsf, times(2)).anmelden(anyString(), anyString()); verify(lsf, times(1)).anmelden(eq(\"Harald\"), eq(\"Wuppie?\")); verify(lsf, times(2)).anmelden(argThat(new MyHaraldMatcher()), anyString()); } class MyHaraldMatcher implements ArgumentMatcher\u003cString\u003e { public boolean matches(String s) { return s.equals(\"Harald\"); } } } Sie können die konkreten Argumente angeben, für die der Aufruf gelten soll. Alternativ können Sie mit vordefinierten ArgumentMatchers wie anyString() beispielsweise auf beliebige Strings reagieren oder selbst einen eigenen ArgumentMatcher\u003cT\u003e für Ihren Typ T erstellen und nutzen.\nWichtig: Wenn Sie für einen Parameter einen ArgumentMatcher einsetzen, müssen Sie für die restlichen Parameter der Methode dies ebenfalls tun. Sie können keine konkreten Argumente mit ArgumentMatcher mischen.\nSie finden viele weitere vordefinierte Matcher in der Klasse ArgumentMatchers. Mit der Klasse ArgumentCaptor\u003cT\u003e finden Sie eine alternative Möglichkeit, auf Argumente in gemockten Methoden zu reagieren. Schauen Sie sich dazu die Javadoc von Mockito an.\nDemo hsbi.MatcherTest Ausblick: PowerMock Mockito sehr mächtig, aber unterstützt (u.a.) keine\nKonstruktoren private Methoden final Methoden static Methoden (ab Version 3.4.0 scheint auch Mockito statische Methoden zu unterstützen) =\u003e Lösung: PowerMock\nAusführlicheres Beispiel: WuppiWarenlager Credits: Der Dank für die Erstellung des nachfolgenden Beispiels und Textes geht an @jedi101.\nDemo: WuppiWarenlager (wuppie.stub) Bei dem gezeigten Beispiel unseres WuppiStores sieht man, dass dieser normalerweise von einem fertigen Warenlager die Wuppis beziehen möchte. Da dieses Lager aber noch nicht existiert, haben wir uns kurzerhand einfach einen Stub von unserem IWuppiWarenlager-Interface erstellt, in dem wir zu Testzwecken händisch ein Paar Wuppis ins Lager geräumt haben.\nDas funktioniert in diesem Mini-Testbeispiel ganz gut aber, wenn unsere Stores erst einmal so richtig Fahrt aufnehmen und wir irgendwann weltweit Wuppis verkaufen, wird der Code des IWuppiWarenlagers wahrscheinlich sehr schnell viel komplexer werden, was unweigerlich dann zu Maintenance-Problemen unserer händisch angelegten Tests führt. Wenn wir zum Beispiel einmal eine Methode hinzufügen wollen, die es uns ermöglicht, nicht immer alle Wuppis aus dem Lager zu ordern oder vielleicht noch andere Methoden, die Fluppis orderbar machen, hinzufügen, müssen wir immer dafür sorgen, dass wir die getätigten Änderungen händisch in den Stub des Warenlagers einpflegen.\nDas will eigentlich niemand...\nEinsatz von Mockito Aber es gibt da einen Ausweg. Wenn es komplexer wird, verwenden wir Mocks.\nBislang haben wir noch keinen Gebrauch von Mockito gemacht. Das ändern wir nun.\nDemo: WuppiWarenlager (wuppie.mock) Wie in diesem Beispiel gezeigt, müssen wir nun keinen Stub mehr von Hand erstellen, sondern überlassen dies Mockito.\nIWuppiWarenlager lager = mock(IWuppiWarenlager.class); Anschließend können wir, ohne die Methode getAllWuppis() implementiert zu haben, dennoch so tun als, ob die Methode eine Funktionalität hätte.\n// Erstellen eines imaginären Lagerbestands. List\u003cString\u003e wuppisImLager = Arrays.asList(\"GruenerWuppi\",\"RoterWuppi\"); when(lager.getAlleWuppis()).thenReturn(wuppisImLager); Wann immer nun die Methode getAlleWuppis() des gemockten Lagers aufgerufen wird, wird dieser Aufruf von Mockito abgefangen und wie oben definiert verändert. Das Ergebnis können wir abschließend einfach in unserem Test testen:\n// Erzeugen des WuppiStores. WuppiStore wuppiStore = new WuppiStore(lager); // Bestelle alle Wuppis aus dem gemockten Lager List\u003cString\u003e bestellteWuppis = wuppiStore.bestelleAlleWuppis(lager); // Hat die Bestellung geklappt? assertEquals(2,bestellteWuppis.size()); Mockito Spies Manchmal möchten wir allerdings nicht immer gleich ein ganzes Objekt mocken, aber dennoch Einfluss auf die aufgerufenen Methoden eines Objekts haben, um diese testen zu können. Vielleicht gibt es dabei ja sogar eine Möglichkeit unsere JUnit-Tests, mit denen wir normalerweise nur Rückgabewerte von Methoden testen können, zusätzlich auch das Verhalten also die Interaktionen mit einem Objekt beobachtbar zu machen. Somit wären diese Interaktionen auch testbar.\nUnd genau dafür bietet Mockito eine Funktion: der sogenannte \"Spy\".\nDieser Spion erlaubt es uns nun zusätzlich das Verhalten zu testen. Das geht in die Richtung von BDD - Behavior Driven Development.\nDemo: WuppiWarenlager (wuppie.spy) // Spion erstellen, der unser wuppiWarenlager überwacht. this.wuppiWarenlager = spy(WuppiWarenlager.class); Hier hatten wir uns einen Spion erzeugt, mit dem sich anschließend das Verhalten verändern lässt:\nwhen(wuppiWarenlager.getAlleWuppis()).thenReturn(Arrays.asList(new Wuppi(\"Wuppi007\"))); Aber auch der Zugriff lässt sich kontrollieren/testen:\nverify(wuppiWarenlager).addWuppi(normalerWuppi); verifyNoMoreInteractions(wuppiWarenlager); Die normalen Testmöglichkeiten von JUnit runden unseren Test zudem ab.\nassertEquals(1,wuppiWarenlager.lager.size()); Mockito und Annotationen In Mockito können Sie wie oben gezeigt mit mock() und spy() neue Mocks bzw. Spies erzeugen und mit verify() die Interaktion überprüfen und mit ArgumentMatcher\u003cT\u003e bzw. den vordefinierten ArgumentMatchers auf Argumente zuzugreifen bzw. darauf zu reagieren.\nZusätzlich/alternativ gibt es in Mockito zahlreiche Annotationen, die ersatzweise statt der genannten Methoden genutzt werden können. Hier ein kleiner Überblick über die wichtigsten in Mockito verwendeten Annotation:\n@Mock wird zum Markieren des zu mockenden Objekts verwendet.\n@Mock WuppiWarenlager lager; @RunWith(MockitoJUnitRunner.class) ist der entsprechende JUnit-Runner, wenn Sie Mocks mit @Mock anlegen.\n@RunWith(MockitoJUnitRunner.class) public class ToDoBusinessMock {...} @Spy erlaubt das Erstellen von partiell gemockten Objekten. Dabei wird eine Art Wrapper um das zu mockende Objekt gewickelt, der dafür sorgt, dass alle Methodenaufrufe des Objekts an den Spy delegiert werden. Diese können über den Spion dann abgefangen/verändert oder ausgewertet werden.\n@Spy ArrayList\u003cWuppi\u003e arrayListenSpion; @InjectMocks erlaubt es, Parameter zu markieren, in denen Mocks und/oder Spies injiziert werden. Mockito versucht dann (in dieser Reihenfolge) per Konstruktorinjektion, Setterinjektion oder Propertyinjektion die Mocks zu injizieren. Weitere Informationen darüber findet man hier: Mockito Dokumentation\nAnmerkung: Es ist aber nicht ratsam \"Field- oder Setterinjection\" zu nutzen, da man nur bei der Verwendung von \"Constructorinjection\" sicherstellen kann, das eine Klasse nicht ohne die eigentlich notwendigen Parameter instanziiert wurde.\n@InjectMocks Wuppi fluppi; @Captor erlaubt es, die Argumente einer Methode abzufangen/auszuwerten. Im Zusammenspiel mit Mockitos verify()-Methode kann man somit auch die einer Methode übergebenen Argumente verifizieren.\n@Captor ArgumentCaptor\u003cString\u003e argumentCaptor; @ExtendWith(MockitoExtension.class) wird in JUnit5 verwendet, um die Initialisierung von Mocks zu vereinfachen. Damit entfällt zum Beispiel die noch unter JUnit4 nötige Initialisierung der Mocks durch einen Aufruf der Methode MockitoAnnotations.openMocks() im Setup des Tests (@Before bzw. @BeforeEach).\nPrüfen der Interaktion mit verify() Mit Hilfe der umfangreichen verify()-Methoden, die uns Mockito mitliefert, können wir unseren Code unter anderem auf unerwünschte Seiteneffekte testen. So ist es mit verify zum Beispiel möglich abzufragen, ob mit einem gemockten Objekt interagiert wurde, wie damit interagiert wurde, welche Argumente dabei übergeben worden sind und in welcher Reihenfolge die Interaktionen damit erfolgt sind.\nHier nur eine kurze Übersicht über das Testen des Codes mit Hilfe von Mockitos verify()-Methoden.\n@Test public void testVerify_DasKeineInteraktionMitDerListeStattgefundenHat() { // Testet, ob die spezifizierte Interaktion mit der Liste nie stattgefunden hat. verify(fluppisListe, never()).clear(); } @Test public void testVerify_ReihenfolgeDerInteraktionenMitDerFluppisListe() { // Testet, ob die Reihenfolge der spezifizierten Interaktionen mit der Liste eingehalten wurde. fluppisListe.clear(); InOrder reihenfolge = inOrder(fluppisListe); reihenfolge.verify(fluppisListe).add(\"Fluppi001\"); reihenfolge.verify(fluppisListe).clear(); } @Test public void testVerify_FlexibleArgumenteBeimZugriffAufFluppisListe() { // Testet, ob schon jemals etwas zu der Liste hinzugefügt wurde. // Dabei ist es egal welcher String eingegeben wurde. verify(fluppisListe).add(anyString()); } @Test public void testVerify_InteraktionenMitHilfeDesArgumentCaptor() { // Testet, welches Argument beim Methodenaufruf übergeben wurde. fluppisListe.addAll(Arrays.asList(\"BobDerBaumeister\")); ArgumentCaptor\u003cList\u003e argumentMagnet = ArgumentCaptor.forClass(FluppisListe.class); verify(fluppisListe).addAll(argumentMagnet.capture()); List\u003cString\u003e argumente = argumentMagnet.getValue(); assertEquals(\"BobDerBaumeister\", argumente.get(0)); } Demo: WuppiWarenlager (wuppie.verify) Wrap-Up Gründliches Testen ist ebenso viel Aufwand wie Coden!\nMockito ergänzt JUnit:\nMocken ganzer Klassen (mock(), when().thenReturn()) Wrappen von Objekten (spy(), doReturn().when()) Auswerten, wie häufig Methoden aufgerufen wurden (verify()) Auswerten, mit welchen Argumenten Methoden aufgerufen wurden (anyString)",
    "description": "Motivation: Entwicklung einer Studi-/Prüfungsverwaltung Szenario Zwei Teams entwickeln eine neue Studi-/Prüfungsverwaltung für die Hochschule. Ein Team modelliert dabei die Studierenden, ein anderes Team modelliert die Prüfungsverwaltung LSF.\nTeam A:\npublic class Studi { String name; LSF lsf; public Studi(String name, LSF lsf) { this.name = name; this.lsf = lsf; } public boolean anmelden(String modul) { return lsf.anmelden(name, modul); } public boolean einsicht(String modul) { return lsf.ergebnis(name, modul) \u003e 50; } } Team B:\npublic class LSF { public boolean anmelden(String name, String modul) { throw new UnsupportedOperationException(); } public int ergebnis(String name, String modul) { throw new UnsupportedOperationException(); } } Team B kommt nicht so recht vorwärts, Team A ist fertig und will schon testen.",
    "tags": [],
    "title": "Mocking mit Mockito",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/testing/mockito.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Modern Java",
    "content": "Problem: Etablierte API (Interfaces) erweitern interface Klausur { void anmelden(Studi s); void abmelden(Studi s); } =\u003e Nachträglich noch void schreiben(Studi s); ergänzen?\nWenn ein Interface nachträglich erweitert wird, müssen alle Kunden (also alle Klassen, die das Interface implementieren) auf die neuen Signaturen angepasst werden. Dies kann viel Aufwand verursachen und API-Änderungen damit unmöglich machen.\nDefault-Methoden: Interfaces mit Implementierung Seit Java8 können Interfaces auch Methoden implementieren. Es gibt zwei Varianten: Default-Methoden und statische Methoden.\ninterface Klausur { void anmelden(Studi s); void abmelden(Studi s); default void schreiben(Studi s) { ... // Default-Implementierung } default void wuppie() { throw new java.lang.UnsupportedOperationException(); } } Methoden können in Interfaces seit Java8 implementiert werden. Für Default-Methoden muss das Schlüsselwort default vor die Signatur gesetzt werden. Klassen, die das Interface implementieren, können diese Default-Implementierung erben oder selbst neu implementieren (überschreiben). Alternativ kann die Klasse eine Default-Methode neu deklarieren und wird damit zur abstrakten Klasse.\nDies ähnelt abstrakten Klassen. Allerdings kann in abstrakten Klassen neben dem Verhalten (implementierten Methoden) auch Zustand über die Attribute gespeichert werden.\nProblem: Mehrfachvererbung Drei Regeln zum Auflösen bei Konflikten:\nKlassen gewinnen: Methoden aus Klasse oder Superklasse haben höhere Priorität als Default-Methoden Sub-Interfaces gewinnen: Methode aus am meisten spezialisiertem Interface mit Default-Methode wird gewählt Beispiel: Wenn B extends A dann ist B spezialisierter als A Sonst: Klasse muss Methode explizit auswählen: Methode überschreiben und gewünschte (geerbte) Variante aufrufen: X.super.m(...) (X ist das gewünschte Interface) Auf den folgenden Folien wird dies anhand kleiner Beispiele verdeutlicht.\nAuflösung Mehrfachvererbung: 1. Klassen gewinnen interface A { default String hello() { return \"A\"; } } class C { public String hello() { return \"C\"; } } class E extends C implements A {} /** Mehrfachvererbung: 1. Klassen gewinnen */ public class DefaultTest1 { public static void main(String... args) { String e = new E().hello(); } } Demo: defaultmethods.rule1.DefaultTest1 Die Klasse E erbt sowohl von Klasse C als auch vom Interface A die Methode hello() (Mehrfachvererbung). In diesem Fall \"gewinnt\" die Implementierung aus Klasse C.\n1. Regel: Klassen gewinnen immer. Deklarationen einer Methode in einer Klasse oder einer Oberklasse haben Vorrang von allen Default-Methoden.\nAuflösung Mehrfachvererbung: 2. Sub-Interfaces gewinnen interface A { default String hello() { return \"A\"; } } interface B extends A { @Override default String hello() { return \"B\"; } } class D implements A, B {} /** Mehrfachvererbung: 2. Sub-Interfaces gewinnen */ public class DefaultTest2 { public static void main(String... args) { String e = new D().hello(); } } Demo: defaultmethods.rule2.DefaultTest2 Die Klasse D erbt sowohl vom Interface A als auch vom Interface B die Methode hello() (Mehrfachvererbung). In diesem Fall \"gewinnt\" die Implementierung aus Klasse B: Interface B ist spezialisierter als A.\n2. Regel: Falls Regel 1 nicht zutrifft, gewinnt die Default-Methode, die am meisten spezialisiert ist.\nAuflösung Mehrfachvererbung: 3. Methode explizit auswählen interface A { default String hello() { return \"A\"; } } interface B { default String hello() { return \"B\"; } } class D implements A, B { @Override public String hello() { return A.super.hello(); } } /** Mehrfachvererbung: 3. Methode explizit auswählen */ public class DefaultTest3 { public static void main(String... args) { String e = new D().hello(); } } Demo: defaultmethods.rule3.DefaultTest3 Die Klasse D erbt sowohl vom Interface A als auch vom Interface B die Methode hello() (Mehrfachvererbung). In diesem Fall muss zur Auflösung die Methode in D neu implementiert werden und die gewünschte geerbte Methode explizit aufgerufen werden. (Wenn dies unterlassen wird, führt das selbst bei Nicht-Nutzung der Methode hello() zu einem Compiler-Fehler!)\nAchtung: Der Aufruf der Default-Methode aus Interface A erfolgt mit A.super.hello(); (nicht einfach durch A.hello();)!\n3. Regel: Falls weder Regel 1 noch 2 zutreffen bzw. die Auflösung noch uneindeutig ist, muss man manuell durch die explizite Angabe der gewünschten Methode auflösen.\nQuiz: Was kommt hier raus? interface A { default String hello() { return \"A\"; } } interface B extends A { @Override default String hello() { return \"B\"; } } class C implements B { @Override public String hello() { return \"C\"; } } class D extends C implements A, B {} /** Quiz Mehrfachvererbung */ public class DefaultTest { public static void main(String... args) { String e = new D().hello(); // ??? } } Die Klasse D erbt sowohl von Klasse C als auch von den Interfaces A und B die Methode hello() (Mehrfachvererbung). In diesem Fall \"gewinnt\" die Implementierung aus Klasse C: Klassen gewinnen immer (Regel 1).\nBeispiel: defaultmethods.quiz.DefaultTest Statische Methoden in Interfaces public interface Collection\u003cE\u003e extends Iterable\u003cE\u003e { boolean add(E e); ... } public class Collections { private Collections() { } public static \u003cT\u003e boolean addAll(Collection\u003c? super T\u003e c, T... elements) {...} ... } Typisches Pattern in Java: Interface plus Utility-Klasse (Companion-Klasse) mit statischen Hilfsmethoden zum einfacheren Umgang mit Instanzen des Interfaces (mit Objekten, deren Klasse das Interface implementiert). Beispiel: Collections ist eine Hilfs-Klasse zum Umgang mit Collection-Objekten.\nSeit Java8 können in Interfaces neben Default-Methoden auch statische Methoden implementiert werden.\nDie Hilfsmethoden können jetzt ins Interface wandern =\u003e Utility-Klassen werden obsolet ... Aus Kompatibilitätsgründen würde man die bisherige Companion-Klasse weiterhin anbieten, wobei die Implementierungen auf die statischen Methoden im Interface verweisen (SKIZZE, nicht real!):\npublic interface CollectionX\u003cE\u003e extends Iterable\u003cE\u003e { boolean add(E e); static \u003cT\u003e boolean addAll(CollectionX\u003c? super T\u003e c, T... elements) { ... } ... } public class CollectionsX { public static \u003cT\u003e boolean addAll(CollectionX\u003c? super T\u003e c, T... elements) { return CollectionX.addAll(c, elements); // Verweis auf Interface } ... } Interfaces vs. Abstrakte Klassen Abstrakte Klassen: Schnittstelle und Verhalten und Zustand\nInterfaces:\nvor Java 8 nur Schnittstelle ab Java 8 Schnittstelle und Verhalten Unterschied zu abstrakten Klassen: Kein Zustand, d.h. keine Attribute\nDesign:\nInterfaces sind beinahe wie abstrakte Klassen, nur ohne Zustand Klassen können nur von einer (abstrakten) Klasse erben, aber viele Interfaces implementieren Wrap-Up Seit Java8: Interfaces mit Implementierung: Default-Methoden\nMethoden mit dem Schlüsselwort default können Implementierung im Interface haben Die Implementierung wird vererbt und kann bei Bedarf überschrieben werden Auflösung von Mehrfachvererbung: Regel 1: Klassen gewinnen Regel 2: Sub-Interfaces gewinnen Regel 3: Methode explizit auswählen Unterschied zu abstrakten Klassen: Kein Zustand",
    "description": "Problem: Etablierte API (Interfaces) erweitern interface Klausur { void anmelden(Studi s); void abmelden(Studi s); } =\u003e Nachträglich noch void schreiben(Studi s); ergänzen?\nWenn ein Interface nachträglich erweitert wird, müssen alle Kunden (also alle Klassen, die das Interface implementieren) auf die neuen Signaturen angepasst werden. Dies kann viel Aufwand verursachen und API-Änderungen damit unmöglich machen.\nDefault-Methoden: Interfaces mit Implementierung Seit Java8 können Interfaces auch Methoden implementieren. Es gibt zwei Varianten: Default-Methoden und statische Methoden.",
    "tags": [],
    "title": "Interfaces: Default-Methoden",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/modern-java/defaultmethods.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Pattern",
    "content": "Verteilung der Prüfungsergebnisse Die Studierenden möchten nach einer Prüfung wissen, ob für einen bestimmten Kurs die/ihre Prüfungsergebnisse im LSF bereit stehen.\nDazu modelliert man eine Klasse LSF und implementiert eine Abfragemethode, die dann alle Objekte regelmäßig aufrufen können. Dies sieht dann praktisch etwa so aus:\nfinal Person[] persons = { new Lecturer(\"Frau Holle\"), new Student(\"Heinz\"), new Student(\"Karla\"), new Tutor(\"Kolja\"), new Student(\"Wuppie\") }; final LSF lsf = new LSF(); for (Person p : persons) { lsf.getGradings(p, \"My Module\"); // ???! } Elegantere Lösung: Observer-Entwurfsmuster Sie erstellen im LSF eine Methode register(), mit der sich interessierte Objekte beim LSF registrieren können.\nZur Benachrichtigung der registrierten Objekte brauchen diese eine geeignete Methode, die traditionell update() genannt wird.\nDemo: observer Observer-Pattern verallgemeinert Im vorigen Beispiel wurde die Methode update() einfach der gemeinsamen Basisklasse Person hinzugefügt. Normalerweise möchte man die Aspekte Person und Observer aber sauber trennen und definiert sich dazu ein separates Interface Observer mit der Methode update(), die dann alle \"interessierten\" Klassen (zusätzlich zur bestehenden Vererbungshierarchie) implementieren.\nDie Klasse für das zu beobachtende Objekt benötigt dann eine Methode register(), mit der sich Observer registrieren können. Die Objektreferenzen werden dabei einfach einer internen Sammlung hinzugefügt.\nHäufig findet sich dann noch eine Methode unregister(), mit der sich bereits registrierte Beobachter wieder abmelden können. Weiterhin findet man häufig eine Methode notifyObservers(), die man von außen auf dem beobachteten Objekt aufrufen kann und die dann auf allen registrierten Beobachtern deren Methoden update() aufruft. (Dieser Vorgang kann aber auch durch eine sonstige Zustandsänderung im beobachteten Objekt durchgeführt werden.)\nIn der Standarddefinition des Observer-Patterns nach [Gamma2011] werden beim Aufruf der Methode update() keine Werte an die Beobachter mitgegeben. Der Beobachter muss sich entsprechend eine eigene Referenz auf das beobachtete Objekt halten, um dort dann weitere Informationen erhalten zu können. Dies kann vereinfacht werden, indem das beobachtete Objekt beim Aufruf der update()-Methode die Informationen als Parameter mitgibt, beispielsweise eine Referenz auf sich selbst o.ä. ... Dies muss dann natürlich im Observer-Interface nachgezogen werden.\nHinweis: Es gibt in Swing bereits die Interfaces Observer und Observable, die aber als \"deprecated\" gekennzeichnet sind. Sinnvollerweise nutzen Sie nicht diese Interfaces aus Swing, sondern implementieren Ihre eigenen Interfaces, wenn Sie das Observer-Pattern einsetzen wollen!\nWrap-Up Observer-Pattern: Benachrichtige registrierte Objekte über Statusänderungen\nInterface Observer mit Methode update() Interessierte Objekte implementieren das Interface Observer registrieren sich beim zu beobachtenden Objekt (Observable) Beobachtetes Objekt ruft auf allen registrierten Objekten update() auf update() kann auch Parameter haben",
    "description": "Verteilung der Prüfungsergebnisse Die Studierenden möchten nach einer Prüfung wissen, ob für einen bestimmten Kurs die/ihre Prüfungsergebnisse im LSF bereit stehen.\nDazu modelliert man eine Klasse LSF und implementiert eine Abfragemethode, die dann alle Objekte regelmäßig aufrufen können. Dies sieht dann praktisch etwa so aus:\nfinal Person[] persons = { new Lecturer(\"Frau Holle\"), new Student(\"Heinz\"), new Student(\"Karla\"), new Tutor(\"Kolja\"), new Student(\"Wuppie\") }; final LSF lsf = new LSF(); for (Person p : persons) { lsf.getGradings(p, \"My Module\"); // ???! } Elegantere Lösung: Observer-Entwurfsmuster",
    "tags": [],
    "title": "Observer-Pattern",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/pattern/observer.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024)",
    "content": "Serialisierung von Objekten und Zuständen Reguläre Ausdrücke Aufzählungen (Enumerations) Konfiguration eines Programms",
    "description": "Serialisierung von Objekten und Zuständen Reguläre Ausdrücke Aufzählungen (Enumerations) Konfiguration eines Programms",
    "tags": [],
    "title": "Fortgeschrittene Java-Themen und Umgang mit JVM",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/java-jvm.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Java / JVM",
    "content": "Motivation: Persistierung von Objekten und Spielzuständen public class Studi { private final int credits = 42; private String name = \"Hilde\"; ... } Wie kann ich Objekte speichern und wieder laden?\nIch möchte ein Spiel (einen Lauf) im Dungeon abspeichern, um es später fortsetzen zu können. Wie kann ich den aktuellen Zustand (also Level, Monster, Held, Inventar, XP/Health/...) so speichern, dass ich später das Spiel nach einem Neustart einfach fortsetzen kann?\nSerialisierung von Objekten Klassen müssen Marker-Interface Serializable implementieren\n\"Marker-Interface\": Interface ohne Methoden. Ändert das Verhalten des Compilers, wenn eine Klasse dieses Interface implementiert: Weitere Funktionen werden \"freigeschaltet\", beispielsweise die Fähigkeit, Klone zu erstellen (Cloneable) oder bei Serializable Objekte serialisierbar zu machen.\nDas ist in meinen Augen eine \"Design-Sünde\" in Java (neben der Einführung von null): Normalerweise definieren Interfaces eine Schnittstelle, die eine das Interface implementierende Klasse dann erfüllen muss. Damit agiert das Interface wie ein Typ. Hier ist das Interface aber leer, es wird also keine Schnittstelle definiert. Aber es werden damit stattdessen Tooling-Optionen aktiviert, was Interfaces vom Konzept her eigentlich nicht machen sollten/dürften - dazu gibt es Annotationen!\nSchreiben von Objekten (samt Zustand) in Streams\nObjectOutputStream: void writeObject(Object) Die Serialisierung erfolgt dabei für alle Attribute (außer static und transient, s.u.) rekursiv.\nDabei werden auch Zirkelreferenzen automatisch aufgelöst/unterbrochen.\nLesen und \"Wiedererwecken\" der Objekte aus Streams\nObjectInputStream: Object readObject() Dabei erfolgt KEIN Konstruktor-Aufruf!\nEinfaches Beispiel public class Studi implements Serializable { private final int credits = 42; private String name = \"Hilde\"; public static void writeObject(Studi studi, String filename) { try (FileOutputStream fos = new FileOutputStream(filename); ObjectOutputStream oos = new ObjectOutputStream(fos)) { oos.writeObject(studi); oos.close(); } catch (IOException ex) {} } public static Studi readObject(String filename) { Studi studi = null; try (FileInputStream fis = new FileInputStream(filename); ObjectInputStream ois = new ObjectInputStream(fis)) { studi = (Studi) ois.readObject(); ois.close(); } catch (IOException | ClassNotFoundException ex) {} return studi; } } Bedingungen für Objekt-Serialisierung Klassen implementieren Marker-Interface Serializable Alle Attribute müssen ebenfalls serialisierbar sein (oder Deklaration \"transient\") Alle primitiven Typen sind per Default serialisierbar Es wird automatisch rekursiv serialisiert, aber jedes Objekt nur einmal (bei Mehrfachreferenzierung) Serialisierbarkeit vererbt sich Ausnahmen Als static deklarierte Attribute werden nicht serialisiert Als transient deklarierte Attribute werden nicht serialisiert Nicht serialisierbare Attribut-Typen führen zu NotSerializableException Version-UID static final long serialVersionUID = 42L; Dient zum Vergleich der serialisierten Version und der aktuellen Klasse Über IDE generieren oder manuell vergeben Wenn das Attribut fehlt, wird eine Art Checksumme von der Runtime-Umgebung berechnet (basierend auf diversen Eigenschaften der Klasse) Dieser Wert wird beim Einlesen verglichen: Das Objekt wird nur dann wieder de-serialisiert, wenn die serialVersionUID mit der einzulesenden Klasse übereinstimmt!\nBei automatischer Berechnung der serialVersionUID durch die JVM kann jede kleine Änderung an der Klasse (beispielsweise Refactoring: Änderung der Methodennamen) eine neue serialVersionUID zur Folge haben. Das würde bedeuten, dass bereits serialisierte Objekte nicht mehr eingelesen werden können, auch wenn sich nur Methoden o.ä. verändert haben und die Attribute noch so vorhanden sind. Deshalb bietet es sich an, hier selbst eine serialVersionUID zu definieren - dann muss man aber auch selbst darauf achten, diese zu verändern, wenn sich wesentliche strukturelle Änderungen an der Klasse ergeben!\nBemerkungen Es existieren diverse weitere Fallstricke und Probleme, siehe [Bloch2018] Kapitel 11 \"Serialization\".\nMan kann in den ObjectOutputStream nicht nur ein Objekt schreiben, sondern mehrere Objekte und Variablen schreiben lassen. In dieser Reihenfolge muss man diese dann aber auch wieder aus dem Stream herauslesen (vgl. Object Streams).\nMan kann die zu serialisierenden Attribute mit der Annotation @Serial markieren. Dies ist in der Wirkung ähnlich zu @Override: Der Compiler prüft dann, ob die markierten Attribute wirklich serialisierbar sind und würde sonst zur Compile-Zeit einen Fehler werfen.\nWeitere Links:\nTutorials: https://docs.oracle.com/en/java/javase/17/docs/specs/serialization/input.html https://www.baeldung.com/java-serialization API: https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/ObjectOutputStream.html https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/ObjectInputStream.html https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Serializable.html Demo: serial.SerializableStudi Wrap-Up Markerinterface Serializable schaltet Serialisierbarkeit frei\nObjekte schreiben: ObjectOutputStream: void writeObject(Object)\nObjekte lesen: ObjectInputStream: Object readObject()\nWichtigste Eigenschaften:\nAttribute müssen serialisierbar sein transient und static Attribute werden nicht serialisiert De-Serialisierung: KEIN Konstruktor-Aufruf! Serialisierbarkeit vererbt sich Objekt-Referenz-Graph wird automatisch beachtet",
    "description": "Motivation: Persistierung von Objekten und Spielzuständen public class Studi { private final int credits = 42; private String name = \"Hilde\"; ... } Wie kann ich Objekte speichern und wieder laden?\nIch möchte ein Spiel (einen Lauf) im Dungeon abspeichern, um es später fortsetzen zu können. Wie kann ich den aktuellen Zustand (also Level, Monster, Held, Inventar, XP/Health/...) so speichern, dass ich später das Spiel nach einem Neustart einfach fortsetzen kann?\nSerialisierung von Objekten Klassen müssen Marker-Interface Serializable implementieren",
    "tags": [],
    "title": "Serialisierung von Objekten und Zuständen",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/java-jvm/serialisation.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Praktikum",
    "content": "A07.1: DevDungeon: Fackeln im Sturm (Streams, Optional) (30%) Klonen Sie das Projekt DevDungeon und laden Sie es in Ihrer IDE als Gradle-Projekt. Betrachten Sie das Sub-Projekt \"devDungeon\". Dies ist ein von einem Studierenden (@Flamtky) erstelltes Spiel mit mehreren Leveln, in denen Sie spielerisch verschiedene Aufgaben in-game und ex-game lösen müssen.\nStarten Sie den DevDungeon mit ./gradlew devDungeon:runDevDungeon. Spielen Sie sich für diese Aufgabe durch das zweite Level (\"Torch Riddle\")1.\nSie befinden sich in einem Raum mit Fackeln, welche Sie per Interaktion an- und ausschalten können. Neben jeder Fackel ist ein Briefkasten, der der Fackel einen Zahlenwert zuordnet. Irgendwo führt eine Tür zu einem zunächst versteckten Raum mit einer Belohnung - aber diese Tür geht erst auf, wenn Sie (a) die richtigen Fackeln an- bzw. ausgeschaltet haben, und wenn Sie (b) die defekte Methode TorchRiddleRiddleHandler#getSumOfLitTorches (im Package level.devlevel.riddleHandler) korrekt implementiert haben. Beachten Sie die entsprechenden Hinweise im Javadoc der Methode.\nDas Tor zum nächsten Level geht unabhängig davon erst auf, wenn Sie den Boss-Gegner2 in diesem Level besiegt haben ... Hierzu ist keine Programmierung notwendig, lediglich geschicktes Spielen und gegebenenfalls rechtzeitiges Trinken von (dann hoffentlich vorhandenen) Heil-Tränken.\nHinweis: Aktuell ist das Projekt DevDungeon an einigen Stellen noch Work-in-Progress, beispielsweise fehlt häufig noch die Javadoc. Alle Gradle-Tasks, die von Checkstyle-Tasks abhängen (checkstyleMain, check, build, ...) werden deshalb fehlschlagen. Sie können den DevDungeon aber wie oben beschrieben mit ./gradlew devDungeon:runDevDungeon (bzw. über den Task devDungeon:runDevDungeon aus der IDE heraus) starten.\nWICHTIG: Achten Sie bitte darauf, dass im Projektpfad keine Leerzeichen und keine Sonderzeichen (Umlaute o.ä.) vorkommen! Dies kann zu seltsamen Fehler führen. Bitte auch darauf achten, dass Sie als JDK ein Java SE 21 (LTS) verwenden.\nKatzen-Café Forken Sie das \"Cat-Cafe\"-Repo und erzeugen Sie sich eine lokale Arbeitskopie von Ihrem Fork.\nBearbeiten Sie die folgenden Teilaufgaben jeweils in einem eigenen Branch. Pushen Sie Ihre Änderungen in Ihren Fork zurück und erstellen Sie dort je einen Pull-Request auf Ihren eigenen master-Branch.\nBitte lassen Sie die Pull-Requests bis zur Vorstellung im Praktikum offen.\nAchten Sie darauf, alle Schritte nachvollziehbar in Ihrer Arbeitskopie per Git-Commit festzuhalten. Demonstrieren Sie im Praktikum, wie Sie mit den Pull-Requests arbeiten.\nIhr Code soll einheitlich formatiert und dokumentiert sein. Sie können beides prüfen: ./gradlew spotlessCheck für die Formatierung und ./gradlew checkstyleMain für die Dokumentation3 mit Javadoc.4 Während Sie die Dokumentation bei Fehlern manuell anpassen müssen (siehe Lektion “Javadoc”), können Sie mit ./gradlew spotlessApply den Code automatisch formatieren lassen - tun Sie das am besten vor jedem Commit.\nA07.2: Code-Analyse (10%) Analysieren Sie die Modellierung des Binärbaums (Tree, Empty, Node) und erklären Sie die Funktionsweise:\nWas sind Vorteile, was sind Nachteile dieser Modellierung? Was musste getan werden, um die selbst implementierten Bäume in Schleifen (Tree\u003cX\u003e mytree; for (Tree\u003cX\u003e t: mytree) {...}) und in Streams Tree\u003cX\u003e mytree; mytree.stream(). ... nutzen zu können? Wie funktioniert der TreeIterator? A07.3: Optional (10%) Bauen Sie die beiden Methoden CatCafe#getCatByName und CatCafe#getCatByWeight so um, dass ein passendes Optional zurückgeliefert wird. Passen Sie die entsprechenden Methodenaufrufe in Main#main entsprechend an.\nIn der Klasse CatCafe in der Vorgabe fehlen die Javadoc-Kommentare. Korrigieren Sie dies und ergänzen Sie hier die fehlenden Javadoc-Kommentare.\nTipp: Stellen Sie in den beiden Methoden auf die Java-Stream-API um, dann ergibt sich die Nutzung von Optional fast von selbst.\nA07.4: JUnit (30%) Erstellen Sie mit JUnit 4 oder 5 mindestens 10 unterschiedliche Testfälle für die Klasse CatCafe. Dokumentieren Sie Ihre Testfälle mit Javadoc.\nTipp: In der Gradle-Konfiguration der Vorgabe ist bereits JUnit5 konfiguriert, d.h. die entsprechenden Abhängigkeiten werden durch Gradle aufgelöst. Wenn Sie die Vorgaben als Gradle-Projekt in Ihrer IDE öffnen, dann steht Ihnen dort auch die JUnit5-Bibliothek automatisch zur Verfügung. Wenn Sie JUnit4 nutzen möchten, müssten Sie bitte die Gradle-Konfiguration entsprechend anpassen. Mit ./gradlew test können Sie entsprechende Testfälle ausführen.\nA07.5: Visitor-Pattern (20%) Die Klasse CatCafe hat eine Methode CatCafe#accept, die einen Visitor mit dem parametrischen Typ TreeVisitor an das intern genutzte Feld Tree\u003cFelineOverLord\u003e clowder weiterleitet.\nImplementieren Sie das Visitor-Pattern für den Baum (Tree), indem Sie das Interface TreeVisitor implementieren:\nErstellen Sie einen konkreten Visitor InOrderVisitor, der den Baum inorder traversiert. Erstellen Sie einen weiteren konkreten Visitor PostOrderVisitor, der den Baum postorder traversiert. Beim Besuch eines Knotens soll jeweils die Methode toString() für den Datenanteil aufgerufen werden und passend mit den Ergebnissen der Traversierung der linken und rechten Teilbäume konkateniert werden und der resultierende String zurückgeben werden.\nFügen Sie passende Aufrufe der beiden Visitoren in Main#main hinzu.\nDas zweite richtige Level, also das zweite Level nach dem Demo-Level. Oder eben das dritte Level, wenn man das Demo-Level mitzählt :-) ↩︎\n... sieht aus wie eine wandelnde Kerze ... ↩︎\nzumindest für den syntaktischen Aspekt ... ↩︎\nSie können auch beides zusammen per ./gradlew check prüfen lassen. ↩︎",
    "description": "A07.1: DevDungeon: Fackeln im Sturm (Streams, Optional) (30%) Klonen Sie das Projekt DevDungeon und laden Sie es in Ihrer IDE als Gradle-Projekt. Betrachten Sie das Sub-Projekt \"devDungeon\". Dies ist ein von einem Studierenden (@Flamtky) erstelltes Spiel mit mehreren Leveln, in denen Sie spielerisch verschiedene Aufgaben in-game und ex-game lösen müssen.\nStarten Sie den DevDungeon mit ./gradlew devDungeon:runDevDungeon. Spielen Sie sich für diese Aufgabe durch das zweite Level (\"Torch Riddle\")1.\nSie befinden sich in einem Raum mit Fackeln, welche Sie per Interaktion an- und ausschalten können. Neben jeder Fackel ist ein Briefkasten, der der Fackel einen Zahlenwert zuordnet. Irgendwo führt eine Tür zu einem zunächst versteckten Raum mit einer Belohnung - aber diese Tür geht erst auf, wenn Sie (a) die richtigen Fackeln an- bzw. ausgeschaltet haben, und wenn Sie (b) die defekte Methode TorchRiddleRiddleHandler#getSumOfLitTorches (im Package level.devlevel.riddleHandler) korrekt implementiert haben. Beachten Sie die entsprechenden Hinweise im Javadoc der Methode.",
    "tags": [],
    "title": "Blatt 07: Torch-Riddle und Katzen-Café (Streams, JUnit, Optional, Visitor)",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/homework/b07.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Coding",
    "content": "Code Smells: Ist das Code oder kann das weg? class checker { static public void CheckANDDO(DATA1 inp, int c, FH.Studi CustD, int x, int y, int in, int out,int c1, int c2, int c3 = 4) { public int i; // neues i for(i=0;i\u003c10;i++) // fuer alle i { inp.kurs[0] = 10; inp.kurs[i] = CustD.cred[i]/c; } SetDataToPlan( CustD ); public double myI = in*2.5; // myI=in*2.5 if (c1) out = myI; //OK else if( c3 == 4 ) { myI = c2 * myI; if (c3 != 4 || true ) { // unbedingt beachten! //System.out.println(\"x:\"+(x++)); System.out.println(\"x:\"+(x++)); // x++ System.out.println(\"out: \"+out); } }} } Der Code im obigen Beispiel lässt sich möglicherweise kompilieren. Und möglicherweise tut er sogar das, was er tun soll.\nDennoch: Der Code \"stinkt\" (zeigt Code Smells):\nNichtbeachtung üblicher Konventionen (Coding Rules) Schlechte Kommentare Auskommentierter Code Fehlende Datenkapselung Zweifelhafte Namen Duplizierter Code \"Langer\" Code: Lange Methoden, Klassen, Parameterlisten, tief verschachtelte if/then-Bedingungen, ... Feature Neid switch/case oder if/else statt Polymorphie Globale Variablen, lokale Variablen als Attribut Magic Numbers Diese Liste enthält die häufigsten \"Smells\" und ließe sich noch beliebig fortsetzen. Schauen Sie mal in die unten angegebene Literatur :-)\nStinkender Code führt zu möglichen (späteren) Problemen.\nWas ist guter (\"sauberer\") Code (\"Clean Code\")? Im Grunde bezeichnet \"sauberer Code\" (\"Clean Code\") die Abwesenheit von Smells. D.h. man könnte Code als \"sauberen\" Code bezeichnen, wenn die folgenden Eigenschaften erfüllt sind (keine vollständige Aufzählung!):\nGut (\"angenehm\") lesbar Schnell verständlich: Geeignete Abstraktionen Konzentriert sich auf eine Aufgabe So einfach und direkt wie möglich Ist gut getestet In [Martin2009] lässt der Autor Robert Martin verschiedene Ikonen der SW-Entwicklung zu diesem Thema zu Wort kommen - eine sehr lesenswerte Lektüre!\n=\u003e Jemand kümmert sich um den Code; solides Handwerk\nWarum ist guter (\"sauberer\") Code so wichtig? Any fool can write code that a computer can understand. Good programmers write code that humans can understand.\nQuelle: [Fowler2011, p. 15]\nAuch wenn das zunächst seltsam klingt, aber Code muss auch von Menschen gelesen und verstanden werden können. Klar, der Code muss inhaltlich korrekt sein und die jeweilige Aufgabe erfüllen, er muss kompilieren etc. ... aber er muss auch von anderen Personen weiter entwickelt werden und dazu gelesen und verstanden werden. Guter Code ist nicht einfach nur inhaltlich korrekt, sondern kann auch einfach verstanden werden.\nCode, der nicht einfach lesbar ist oder nur schwer verständlich ist, wird oft in der Praxis später nicht gut gepflegt: Andere Entwickler haben (die berechtigte) Angst, etwas kaputt zu machen und arbeiten \"um den Code herum\". Nur leider wird das Konstrukt dann nur noch schwerer verständlich ...\nCode Smells Verstöße gegen die Prinzipien von Clean Code nennt man auch Code Smells: Der Code \"stinkt\" gewissermaßen. Dies bedeutet nicht unbedingt, dass der Code nicht funktioniert (d.h. er kann dennoch compilieren und die Anforderungen erfüllen). Er ist nur nicht sauber formuliert, schwer verständlich, enthält Doppelungen etc., was im Laufe der Zeit die Chance für tatsächliche Probleme deutlich erhöht.\nUnd weil es so wichtig ist, hier gleich noch einmal:\nStinkender Code führt zu möglichen (späteren) Problemen.\n\"Broken Windows\" Phänomen Wenn ein Gebäude leer steht, wird es eine gewisse Zeit lang nur relativ langsam verfallen: Die Fenster werden nicht mehr geputzt, es sammelt sich Graffiti, Gras wächst in der Dachrinne, Putz blättert ab ...\nIrgendwann wird dann eine Scheibe eingeworfen. Wenn dieser Punkt überschritten ist, beschleunigt sich der Verfall rasant: Über Nacht werden alle erreichbaren Scheiben eingeworfen, Türen werden zerstört, es werden sogar Brände gelegt ...\nDas passiert auch bei Software! Wenn man als Entwickler das Gefühl bekommt, die Software ist nicht gepflegt, wird man selbst auch nur relativ schlechte Arbeit abliefern. Sei es, weil man nicht versteht, was der Code macht und sich nicht an die Überarbeitung der richtigen Stellen traut und stattdessen die Änderungen als weiteren \"Erker\" einfach dran pappt. Seit es, weil man keine Lust hat, Zeit in ordentliche Arbeit zu investieren, weil der Code ja eh schon schlecht ist ... Das wird mit der Zeit nicht besser ...\n\"Broken Windows\" Phänomen Maßeinheit für Code-Qualität ;-) Es gibt eine \"praxisnahe\" (und nicht ganz ernst gemeinte) Maßeinheit für Code-Qualität: Die \"WTF/m\" (What the Fuck per minute): Thom Holwerda: www.osnews.com/story/19266/WTFs_.\nWenn beim Code-Review durch Kollegen viele \"WTF\" kommen, ist der Code offenbar nicht in Ordnung ...\nCode Smells: Nichtbeachtung von Coding Conventions Richtlinien für einheitliches Aussehen =\u003e Andere Programmierer sollen Code schnell lesen können\nNamen, Schreibweisen Kommentare (Ort, Form, Inhalt) Einrückungen und Spaces vs. Tabs Zeilenlängen, Leerzeilen Klammern Beispiele: Sun Code Conventions, Google Java Style\nHinweis: Betrifft vor allem die (äußere) Form!\nCode Smells: Schlechte Kommentare I Ratlose Kommentare\n/* k.A. was das bedeutet, aber wenn man es raus nimmt, geht's nicht mehr */ /* TODO: was passiert hier, und warum? */ Der Programmierer hat selbst nicht verstanden (und macht sich auch nicht die Mühe zu verstehen), was er da tut! Fehler sind vorprogrammiert!\nRedundante Kommentare: Erklären Sie, was der Code inhaltlich tun sollte (und warum)!\npublic int i; // neues i for(i=0;i\u003c10;i++) // fuer alle i Was würden Sie Ihrem Kollegen erklären (müssen), wenn Sie ihm/ihr den Code vorstellen?\nWiederholen Sie nicht, was der Code tut (das kann ich ja selbst lesen), sondern beschreiben Sie, was der Code tun sollte und warum.\nBeschreiben Sie dabei auch das Konzept hinter einem Codebaustein.\nCode Smells: Schlechte Kommentare II Veraltete Kommentare\nHinweis auf unsauberes Arbeiten: Oft wird im Zuge der Überarbeitung von Code-Stellen vergessen, auch den Kommentar anzupassen! Sollte beim Lesen extrem misstrauisch machen.\nAuskommentierter Code\nDa ist jemand seiner Sache unsicher bzw. hat eine Überarbeitung nicht abgeschlossen. Die Chance, dass sich der restliche Code im Laufe der Zeit so verändert, dass der auskommentierte Code nicht mehr (richtig) läuft, ist groß! Auskommentierter Code ist gefährlich und dank Versionskontrolle absolut überflüssig!\nKommentare erscheinen zwingend nötig\nHäufig ein Hinweis auf ungeeignete Wahl der Namen (Klassen, Methoden, Attribute) und/oder auf ein ungeeignetes Abstraktionsniveau (beispielsweise Nichtbeachtung des Prinzips der \"Single Responsibility\")!\nDer Code soll im Normalfall für sich selbst sprechen: WAS wird gemacht. Der Kommentar erklärt im Normalfall, WARUM der Code das machen soll.\nUnangemessene Information, z.B. Änderungshistorien\nHinweise wie \"wer hat wann was geändert\" gehören in das Versionskontroll- oder ins Issue-Tracking-System. Die Änderung ist im Code sowieso nicht mehr sichtbar/nachvollziehbar!\nCode Smells: Schlechte Namen und fehlende Kapselung public class Studi extends Person { public String n; public int c; public void prtIf() { ... } } Nach drei Wochen fragen Sie sich, was n oder c oder Studi#prtIf() wohl sein könnte! (Ein anderer Programmierer fragt sich das schon beim ersten Lesen.) Klassen und Methoden sollten sich erwartungsgemäß verhalten.\nWenn Dinge öffentlich angeboten werden, muss man damit rechnen, dass andere darauf zugreifen. D.h. man kann nicht mehr so einfach Dinge wie die interne Repräsentation oder die Art der Berechnung austauschen! Öffentliche Dinge gehören zur Schnittstelle und damit Teil des \"Vertrags\" mit den Nutzern!\nProgrammierprinzip \"Prinzip der minimalen Verwunderung\"\nKlassen und Methoden sollten sich erwartungsgemäß verhalten Gute Namen ersparen das Lesen der Dokumentation Programmierprinzip \"Kapselung/Information Hiding\"\nMöglichst schlanke öffentliche Schnittstelle =\u003e \"Vertrag\" mit Nutzern der Klasse! Code Smells: Duplizierter Code public class Studi { public String getName() { return name; } public String getAddress() { return strasse+\", \"+plz+\" \"+stadt; } public String getStudiAsString() { return name+\" (\"+strasse+\", \"+plz+\" \"+stadt+\")\"; } } Programmierprinzip \"DRY\" =\u003e \"Don't repeat yourself!\" Im Beispiel wird das Formatieren der Adresse mehrfach identisch implementiert, d.h. duplizierter Code. Auslagern in eigene Methode und aufrufen!\nKopierter/duplizierter Code ist problematisch:\nSpätere Änderungen müssen an mehreren Stellen vorgenommen werden Lesbarkeit/Orientierung im Code wird erschwert (Analogie: Reihenhaussiedlung) Verpasste Gelegenheit für sinnvolle Abstraktion! Code Smells: Langer Code Lange Klassen\nFaustregel: 5 Bildschirmseiten sind viel Lange Methoden\nFaustregel: 1 Bildschirmseite [Martin2009]: deutlich weniger als 20 Zeilen Lange Parameterlisten\nFaustregel: max. 3 ... 5 Parameter [Martin2009]: 0 Parameter ideal, ab 3 Parameter gute Begründung nötig Tief verschachtelte if/then-Bedingungen\nFaustregel: 2 ... 3 Einrückungsebenen sind viel Programmierprinzip \"Single Responsibility\"\nJede Klasse ist für genau einen Aspekt des Gesamtsystems verantwortlich\nLesbarkeit und Übersichtlichkeit leiden Der Mensch kann sich nur begrenzt viele Dinge im Kurzzeitgedächtnis merken Klassen, die länger als 5 Bildschirmseiten sind, erfordern viel Hin- und Her-Scrollen, dito für lange Methoden Lange Methoden sind schwer verständlich (erledigen viele Dinge?) Mehr als 3 Parameter kann sich kaum jemand merken, vor allem beim Aufruf von Methoden Die Testbarkeit wird bei zu komplexen Methoden/Klassen und vielen Parametern sehr erschwert Große Dateien verleiten (auch mangels Übersichtlichkeit) dazu, neuen Code ebenfalls schluderig zu gliedern Langer Code deutet auch auf eine Verletzung des Prinzips der Single Responsibility hin Klassen fassen evtl. nicht zusammengehörende Dinge zusammen\npublic class Student { private String name; private String phoneAreaCode; private String phoneNumber; public void printStudentInfo() { System.out.println(\"name: \" + name); System.out.println(\"contact: \" + phoneAreaCode + \"/\" + phoneNumber); } } Warum sollte sich die Klasse Student um die Einzelheiten des Aufbaus einer Telefonnummer kümmern? Das Prinzip der \"Single Responsibility\" wird hier verletzt!\nMethoden erledigen vermutlich mehr als nur eine Aufgabe\npublic void credits() { for (Student s : students) { if (s.hasSemesterFinished()) { ECTS c = calculateEcts(s); s.setEctsSum(c); } } } // Diese Methode erledigt 4 Dinge: Iteration, Abfrage, Berechnung, Setzen ... =\u003e Erklären Sie die Methode jemandem. Wenn dabei das Wort \"und\" vorkommt, macht die Methode höchstwahrscheinlich zu viel!\nViele Parameter bedeuten oft fehlende Datenabstraktion\nCircle makeCircle(int x, int y, int radius); Circle makeCircle(Point center, int radius); // besser! Code Smells: Feature Neid public class CreditsCalculator { public ECTS calculateEcts(Student s) { int semester = s.getSemester(); int workload = s.getCurrentWorkload(); int nrModuls = s.getNumberOfModuls(); int total = Math.min(30, workload); int extra = Math.max(0, total - 30); if (semester \u003c 5) { extra = extra * nrModuls; } return new ECTS(total + extra); } } Zugriff auf (viele) Interna der anderen Klasse! =\u003e Hohe Kopplung der Klassen! Methode CreditsCalculator#calculateEcts() \"möchte\" eigentlich in Student sein ... Weiterführende Links \"Foundations: Clean Code\" (The Odin Project) \"Documentation Best Practices\" (Google Styleguide) Wrap-Up Code entsteht nicht zum Selbstzweck =\u003e Lesbarkeit ist wichtig\nCode Smells: Code führt zu möglichen (späteren) Problemen\nRichtiges Kommentieren und Dokumentieren\nIn dieser Sitzung haben wir vor allem auf Kommentare geschaut. Zum Thema Dokumentieren siehe die Einheit zu “Javadoc”.\nEinhalten von Coding Conventions\nRegeln zu Schreibweisen und Layout Leerzeichen, Einrückung, Klammern Zeilenlänge, Umbrüche Kommentare Einhalten von Prinzipien des objektorientierten Programmierens\nJede Klasse ist für genau einen Aspekt des Systems verantwortlich. (Single Responsibility) Keine Code-Duplizierung! (DRY - Don't repeat yourself) Klassen und Methoden sollten sich erwartungsgemäß verhalten Kapselung: Möglichst wenig öffentlich zugänglich machen",
    "description": "Code Smells: Ist das Code oder kann das weg? class checker { static public void CheckANDDO(DATA1 inp, int c, FH.Studi CustD, int x, int y, int in, int out,int c1, int c2, int c3 = 4) { public int i; // neues i for(i=0;i\u003c10;i++) // fuer alle i { inp.kurs[0] = 10; inp.kurs[i] = CustD.cred[i]/c; } SetDataToPlan( CustD ); public double myI = in*2.5; // myI=in*2.5 if (c1) out = myI; //OK else if( c3 == 4 ) { myI = c2 * myI; if (c3 != 4 || true ) { // unbedingt beachten! //System.out.println(\"x:\"+(x++)); System.out.println(\"x:\"+(x++)); // x++ System.out.println(\"out: \"+out); } }} } Der Code im obigen Beispiel lässt sich möglicherweise kompilieren. Und möglicherweise tut er sogar das, was er tun soll.",
    "tags": [],
    "title": "Code Smells",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/coding/smells.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Coding",
    "content": "Coding Conventions: Richtlinien für einheitliches Aussehen von Code =\u003e Ziel: Andere Programmierer sollen Code schnell lesen können\nNamen, Schreibweisen: UpperCamelCase vs. lowerCamelCase vs. UPPER_SNAKE_CASE Kommentare (Ort, Form, Inhalt): Javadoc an allen public und protected Elementen Einrückungen und Spaces vs. Tabs: 4 Spaces Zeilenlängen: 100 Zeichen Leerzeilen: Leerzeilen für Gliederung Klammern: Auf selber Zeile wie Code Beispiele: Sun Code Conventions, Google Java Style, AOSP Java Code Style for Contributors\nBeispiel nach Google Java Style/AOSP formatiert package wuppie.deeplearning.strategy; /** * Demonstriert den Einsatz von AOSP/Google Java Style ................. Umbruch nach 100 Zeichen | */ public class MyWuppieStudi implements Comparable\u003cMyWuppieStudi\u003e { private static String lastName; private static MyWuppieStudi studi; private MyWuppieStudi() {} /** Erzeugt ein neues Exemplar der MyWuppieStudi-Spezies (max. 40 Zeilen) */ public static MyWuppieStudi getMyWuppieStudi(String name) { if (studi == null) { studi = new MyWuppieStudi(); } if (lastName == null) lastName = name; return studi; } @Override public int compareTo(MyWuppieStudi o) { return lastName.compareTo(lastName); } } Dieses Beispiel wurde nach Google Java Style/AOSP formatiert.\nDie Zeilenlänge beträgt max. 100 Zeichen. Pro Methode werden max. 40 Zeilen genutzt. Zwischen Attributen, Methoden und Importen wird jeweils eine Leerzeile eingesetzt (zwischen den einzelnen Attributen muss aber keine Leerzeile genutzt werden). Zur logischen Gliederung können innerhalb von Methoden weitere Leerzeilen eingesetzt werden, aber immer nur eine.\nKlassennamen sind UpperCamelCase, Attribute und Methoden und Parameter lowerCamelCase, Konstanten (im Beispiel nicht vorhanden) UPPER_SNAKE_CASE. Klassen sind Substantive, Methoden Verben.\nAlle public und protected Elemente werden mit einem Javadoc-Kommentar versehen. Überschriebene Methoden müssen nicht mit Javadoc kommentiert werden, müssen aber mit @Override markiert werden.\nGeschweifte Klammern starten immer auf der selben Codezeile. Wenn bei einem if nur ein Statement vorhanden ist und dieses auf die selbe Zeile passt, kann auf die umschließenden geschweiften Klammern ausnahmsweise verzichtet werden.\nEs wird mit Leerzeichen eingerückt. Google Java Style arbeitet mit 2 Leerzeichen, während AOSP hier 4 Leerzeichen vorschreibt. Im Beispiel wurde nach AOSP eingerückt.\nDarüber hinaus gibt es vielfältige weitere Regeln für das Aussehen des Codes. Lesen Sie dazu entsprechend auf Google Java Style und auch auf AOSP nach.\nFormatieren Sie Ihren Code (mit der IDE) Sie können den Code manuell formatieren, oder aber (sinnvollerweise) über Tools formatieren lassen. Hier einige Möglichkeiten:\nIDE: Code-Style einstellen und zum Formatieren nutzen\ngoogle-java-format: java -jar google-java-format.jar --replace *.java (auch als IDE-Plugin)\nSpotless in Gradle:\nplugins { id \"java\" id \"com.diffplug.spotless\" version \"6.5.0\" } spotless { java { // googleJavaFormat() googleJavaFormat().aosp() // indent w/ 4 spaces } } Prüfen mit ./gradlew spotlessCheck (Teil von ./gradlew check) und Formatieren mit ./gradlew spotlessApply\nEinstellungen der IDE's Eclipse: Project \u003e Properties \u003e Java Code Style \u003e Formatter: Coding-Style einstellen/einrichten Code markieren, Source \u003e Format Komplettes Aufräumen: Source \u003e Clean Up (Formatierung, Importe, Annotationen, ...) Kann auch so eingestellt werden, dass ein \"Clean Up\" immer beim Speichern ausgeführt wird! IntelliJ verfügt über ähnliche Fähigkeiten: Einstellen über Preferences \u003e Editor \u003e Code Style \u003e Java Formatieren mit Code \u003e Reformat Code oder Code \u003e Reformat File Die Details kann/muss man einzeln einstellen. Für die \"bekannten\" Styles (Google Java Style) bringen die IDE's oft aber schon eine Gesamtkonfiguration mit.\nAchtung: Zumindest in Eclipse gibt es mehrere Stellen, wo ein Code-Style eingestellt werden kann (\"Clean Up\", \"Formatter\", ...). Diese sollten dann jeweils auf den selben Style eingestellt werden, sonst gibt es unter Umständen lustige Effekte, da beim Speichern ein anderer Style angewendet wird als beim \"Clean Up\" oder beim \"Format Source\" ...\nAnalog sollte man bei der Verwendung von Checkstyle auch in der IDE im Formatter die entsprechenden Checkstyle-Regeln (s.u.) passend einstellen, sonst bekommt man durch Checkstyle Warnungen angezeigt, die man durch ein automatisches Formatieren nicht beheben kann.\nGoogle Java Style und google-java-format Wer direkt den Google Java Style nutzt, kann auch den dazu passenden Formatter von Google einsetzen: google-java-format. Diesen kann man entweder als Plugin für IntelliJ/Eclipse einsetzen oder als Stand-alone-Tool (Kommandozeile oder Build-Skripte) aufrufen. Wenn man sich noch einen entsprechenden Git-Hook definiert, wird vor jedem Commit der Code entsprechend den Richtlinien formatiert :)\nSpotless und google-java-format in Gradle Hinweis: Bei Spotless in Gradle müssen je nach den Versionen von Spotless/google-java-format bzw. des JDK noch Optionen in der Datei gradle.properties eingestellt werden (siehe Demo und Spotless \u003e google-java-format (Web)).\nTipp: Die Formatierung über die IDE ist angenehm, aber in der Praxis leider oft etwas hakelig: Man muss alle Regeln selbst einstellen (und es gibt einige dieser Einstellungen), und gerade IntelliJ \"greift\" manchmal nicht alle Code-Stellen beim Formatieren. Nutzen Sie Spotless und bauen Sie die Konfiguration in Ihr Build-Skript ein und konfigurieren Sie über den Build-Prozess.\nDemo: Konfiguration Formatter (IDE), Spotless/Gradle Metriken: Kennzahlen für verschiedene Aspekte zum Code Metriken messen verschiedene Aspekte zum Code und liefern eine Zahl zurück. Mit Metriken kann man beispielsweise die Einhaltung der Coding Rules (Formate, ...) prüfen, aber auch die Einhaltung verschiedener Regeln des objektorientierten Programmierens.\nBeispiele für wichtige Metriken (jeweils Max-Werte für PM) Die folgenden Metriken und deren Maximal-Werte sind gute Erfahrungswerte aus der Praxis und helfen, den Code Smell \"Langer Code\" (vgl. “Code Smells”) zu erkennen und damit zu vermeiden. Über die Metriken BEC, McCabe und DAC wird auch die Einhaltung elementarer Programmierregeln gemessen.\nNCSS (Non Commenting Source Statements) Zeilen pro Methode: 40; pro Klasse: 250; pro Datei: 300 Annahme: Eine Anweisung je Zeile ... Anzahl der Methoden pro Klasse: 10 Parameter pro Methode: 3 BEC (Boolean Expression Complexity) Anzahl boolescher Ausdrücke in if etc.: 3 McCabe (Cyclomatic Complexity) Anzahl der möglichen Verzweigungen (Pfade) pro Methode + 1 1-4 gut, 5-7 noch OK DAC (Class Data Abstraction Coupling) Anzahl der genutzten (instantiierten) \"Fremdklassen\" Werte kleiner 7 werden i.A. als normal betrachtet Die obigen Grenzwerte sind typische Standardwerte, die sich in der Praxis allgemein bewährt haben (vergleiche u.a. [Martin2009] oder auch in AOSP: Write short methods und AOSP: Limit line length).\nDennoch sind das keine absoluten Werte an sich. Ein Übertreten der Grenzen ist ein Hinweis darauf, dass höchstwahrscheinlich etwas nicht stimmt, muss aber im konkreten Fall hinterfragt und diskutiert und begründet werden!\nMetriken im Beispiel von oben private static String lastName; private static MyWuppieStudi studi; public static MyWuppieStudi getMyWuppieStudi(String name) { if (studi == null) { studi = new MyWuppieStudi(); } if (lastName == null) lastName = name; return studi; } BEC: 1 (nur ein boolescher Ausdruck im if) McCabe: 3 (es gibt zwei mögliche Verzweigungen in der Methode plus die Methode selbst) DAC: 1 (eine \"Fremdklasse\": String) Anmerkung: In Checkstyle werden für einige häufig verwendete Standard-Klassen Ausnahmen definiert, d.h. String würde im obigen Beispiel nicht bei DAC mitgezählt/angezeigt.\n=\u003e Verweis auf LV Softwareengineering\nTool-Support: Checkstyle Metriken und die Einhaltung von Coding-Conventions werden sinnvollerweise nicht manuell, sondern durch diverse Tools erfasst, etwa im Java-Bereich mit Hilfe von Checkstyle.\nDas Tool lässt sich Standalone über CLI nutzen oder als Plugin für IDE's (Eclipse oder IntelliJ) einsetzen. Gradle bringt ein eigenes Plugin mit.\nIDE: diverse Plugins: Eclipse-CS, CheckStyle-IDEA\nCLI: java -jar checkstyle-10.2-all.jar -c google_checks.xml *.java\nPlugin \"checkstyle\" in Gradle:\nplugins { id \"java\" id \"checkstyle\" } checkstyle { configFile file('checkstyle.xml') toolVersion '10.19.0' } Aufruf: Prüfen mit ./gradlew checkstyleMain (Teil von ./gradlew check) Konfiguration: \u003cprojectDir\u003e/config/checkstyle/checkstyle.xml (Default) bzw. mit der obigen Konfiguration direkt im Projektordner Report: \u003cprojectDir\u003e/build/reports/checkstyle/main.html Demo: IntelliJ, Checkstyle/Gradle Checkstyle: Konfiguration Die auszuführenden Checks lassen sich über eine XML-Datei konfigurieren. In Eclipse-CS kann man die Konfiguration auch in einer GUI bearbeiten.\nDas Checkstyle-Projekt stellt eine passende Konfiguration für den Google Java Style bereit. Diese ist auch in den entsprechenden Plugins oft bereits enthalten und kann direkt ausgewählt oder als Startpunkt für eigene Konfigurationen genutzt werden.\nDer Startpunkt für die Konfigurationsdatei ist immer das Modul \"Checker\". Darin können sich \"FileSetChecks\" (Module, die auf einer Menge von Dateien Checks ausführen), \"Filters\" (Module, die Events bei der Prüfung von Regeln filtern) und \"AuditListeners\" (Module, die akzeptierte Events in einen Report überführen) befinden. Der \"TreeWalker\" ist mit der wichtigste Vertreter der FileSetChecks-Module und transformiert die zu prüfenden Java-Sourcen in einen Abstract Syntax Tree, also eine Baumstruktur, die dem jeweiligen Code unter der Java-Grammatik entspricht. Darauf können dann wiederum die meisten Low-Level-Module arbeiten.\nEine Reihe von Standard-Checks sind bereits in Checkstyle implementiert und benötigen keine weitere externe Abhängigkeiten. Man kann aber zusätzliche Regeln aus anderen Projekten beziehen (etwa via Gradle/Maven) oder sich eigene zusätzliche Regeln in Java schreiben. Die einzelnen Checks werden in der Regel als \"Modul\" dem \"TreeWalker\" hinzugefügt und über die jeweiligen Properties näher konfiguriert.\nSie finden in der Doku zu jedem Check das entsprechende Modul, das Eltern-Modul (also wo müssen Sie das Modul im XML-Baum einfügen) und auch die möglichen Properties und deren Default-Einstellungen.\n\u003cmodule name=\"Checker\"\u003e \u003cmodule name=\"LineLength\"\u003e \u003cproperty name=\"max\" value=\"100\"/\u003e \u003c/module\u003e \u003cmodule name=\"TreeWalker\"\u003e \u003cmodule name=\"AvoidStarImport\"/\u003e \u003cmodule name=\"MethodCount\"\u003e \u003cproperty name=\"maxPublic\" value=\"10\"/\u003e \u003cproperty name=\"maxTotal\" value=\"40\"/\u003e \u003c/module\u003e \u003c/module\u003e \u003c/module\u003e Alternativen/Ergänzungen: beispielsweise MetricsReloaded.\nDemo: Konfiguration mit Eclipse-CS, Hinweis auf Formatter SpotBugs: Finde Anti-Pattern und potentielle Bugs (Linter) SpotBugs sucht nach über 400 potentiellen Bugs im Code\nAnti-Pattern (schlechte Praxis, \"dodgy\" Code) Sicherheitsprobleme Korrektheit CLI: java -jar spotbugs.jar options ...\nIDE: IntelliJ SpotBugs plugin, SpotBugs Eclipse plugin\nGradle: SpotBugs Gradle Plugin\nplugins { id \"java\" id \"com.github.spotbugs\" version \"5.0.6\" } spotbugs { ignoreFailures = true showStackTraces = false } Prüfen mit ./gradlew spotbugsMain (in ./gradlew check)\nDemo: SpotBugs/Gradle Konfiguration für das PM-Praktikum (Format, Metriken, Checkstyle, SpotBugs) Im PM-Praktikum beachten wir die obigen Coding Conventions und Metriken mit den dort definierten Grenzwerten. Diese sind bereits in der bereit gestellten Minimal-Konfiguration für Checkstyle (s.u.) konfiguriert.\nFormatierung Google Java Style/AOSP: Spotless Zusätzlich wenden wir den Google Java Style an. Statt der dort vorgeschriebenen Einrückung mit 2 Leerzeichen (und 4+ Leerzeichen bei Zeilenumbruch in einem Statement) können Sie auch mit 4 Leerzeichen einrücken (8 Leerzeichen bei Zeilenumbruch) (AOSP). Halten Sie sich in Ihrem Team an eine einheitliche Einrückung (Google Java Style oder AOSP).\nFormatieren Sie Ihren Code vor den Commits mit Spotless (über Gradle) oder stellen Sie den Formatter Ihrer IDE entsprechend ein.\nCheckstyle Minimal-Konfiguration für Checkstyle (Coding Conventions, Metriken) Nutzen Sie die folgende Minimal-Konfiguration für Checkstyle für Ihre Praktikumsaufgaben. Diese beinhaltet die Prüfung der wichtigsten Formate nach Google Java Style/AOSP sowie der obigen Metriken. Halten Sie diese Regeln ein.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE module PUBLIC \"-//Checkstyle//DTD Checkstyle Configuration 1.3//EN\" \"https://checkstyle.org/dtds/configuration_1_3.dtd\"\u003e \u003cmodule name=\"Checker\"\u003e \u003cproperty name=\"severity\" value=\"warning\"/\u003e \u003cmodule name=\"TreeWalker\"\u003e \u003cmodule name=\"JavaNCSS\"\u003e \u003cproperty name=\"methodMaximum\" value=\"40\"/\u003e \u003cproperty name=\"classMaximum\" value=\"250\"/\u003e \u003cproperty name=\"fileMaximum\" value=\"300\"/\u003e \u003c/module\u003e \u003cmodule name=\"BooleanExpressionComplexity\"/\u003e \u003cmodule name=\"CyclomaticComplexity\"\u003e \u003cproperty name=\"max\" value=\"7\"/\u003e \u003c/module\u003e \u003cmodule name=\"ClassDataAbstractionCoupling\"\u003e \u003cproperty name=\"max\" value=\"6\"/\u003e \u003c/module\u003e \u003cmodule name=\"MethodCount\"\u003e \u003cproperty name=\"maxTotal\" value=\"10\"/\u003e \u003cproperty name=\"maxPrivate\" value=\"10\"/\u003e \u003cproperty name=\"maxPackage\" value=\"10\"/\u003e \u003cproperty name=\"maxProtected\" value=\"10\"/\u003e \u003cproperty name=\"maxPublic\" value=\"10\"/\u003e \u003c/module\u003e \u003cmodule name=\"ParameterNumber\"\u003e \u003cproperty name=\"max\" value=\"3\"/\u003e \u003c/module\u003e \u003cmodule name=\"MethodLength\"\u003e \u003cproperty name=\"max\" value=\"40\"/\u003e \u003c/module\u003e \u003cmodule name=\"Indentation\"\u003e \u003cproperty name=\"basicOffset\" value=\"4\"/\u003e \u003cproperty name=\"lineWrappingIndentation\" value=\"8\"/\u003e \u003cproperty name=\"caseIndent\" value=\"4\"/\u003e \u003cproperty name=\"throwsIndent\" value=\"4\"/\u003e \u003cproperty name=\"arrayInitIndent\" value=\"4\"/\u003e \u003c/module\u003e \u003cmodule name=\"TypeName\"/\u003e \u003cmodule name=\"MethodName\"/\u003e \u003cmodule name=\"MemberName\"/\u003e \u003cmodule name=\"ParameterName\"/\u003e \u003cmodule name=\"ConstantName\"/\u003e \u003cmodule name=\"OneStatementPerLine\"/\u003e \u003cmodule name=\"MultipleVariableDeclarations\"/\u003e \u003cmodule name=\"MissingOverride\"/\u003e \u003cmodule name=\"MissingJavadocMethod\"/\u003e \u003cmodule name=\"AvoidStarImport\"/\u003e \u003c/module\u003e \u003cmodule name=\"LineLength\"\u003e \u003cproperty name=\"max\" value=\"100\"/\u003e \u003c/module\u003e \u003cmodule name=\"FileTabCharacter\"\u003e \u003cproperty name=\"eachLine\" value=\"true\"/\u003e \u003c/module\u003e \u003cmodule name=\"NewlineAtEndOfFile\"/\u003e \u003c/module\u003e Sie können diese Basis-Einstellungen auch aus dem Programmiermethoden-CampusMinden/Prog2-Lecture-Repo direkt herunterladen: checkstyle.xml.\nSie können zusätzlich gern noch die weiteren (und strengeren) Regeln aus der vom Checkstyle-Projekt bereitgestellten Konfigurationsdatei für den Google Java Style nutzen. Hinweis: Einige der dort konfigurierten Checkstyle-Regeln gehen allerdings über den Google Java Style hinaus.\nLinter: SpotBugs Vermeiden von Anti-Pattern mit SpotBugs Setzen Sie zusätzlich SpotBugs mit ein. Ihre Lösungen dürfen keine Warnungen oder Fehler beinhalten, die SpotBugs melden würde.\nWrap-Up Code entsteht nicht zum Selbstzweck =\u003e Regeln nötig!\nCoding Conventions\nRegeln zu Schreibweisen und Layout Leerzeichen, Einrückung, Klammern Zeilenlänge, Umbrüche Kommentare Formatieren mit Spotless\nPrinzipien des objektorientierten Programmierens (vgl. “Code Smells”)\nJede Klasse ist für genau einen Aspekt des Systems verantwortlich. (Single Responsibility) Keine Code-Duplizierung! (DRY - Don't repeat yourself) Klassen und Methoden sollten sich erwartungsgemäß verhalten Kapselung: Möglichst wenig öffentlich zugänglich machen Metriken: Einhaltung von Regeln in Zahlen ausdrücken\nPrüfung manuell durch Code Reviews oder durch Tools wie Checkstyle oder SpotBugs\nDefinition des \"PM-Styles\" (siehe Folie \"Konfiguration für das PM-Praktikum\")",
    "description": "Coding Conventions: Richtlinien für einheitliches Aussehen von Code =\u003e Ziel: Andere Programmierer sollen Code schnell lesen können\nNamen, Schreibweisen: UpperCamelCase vs. lowerCamelCase vs. UPPER_SNAKE_CASE Kommentare (Ort, Form, Inhalt): Javadoc an allen public und protected Elementen Einrückungen und Spaces vs. Tabs: 4 Spaces Zeilenlängen: 100 Zeichen Leerzeilen: Leerzeilen für Gliederung Klammern: Auf selber Zeile wie Code Beispiele: Sun Code Conventions, Google Java Style, AOSP Java Code Style for Contributors\nBeispiel nach Google Java Style/AOSP formatiert package wuppie.deeplearning.strategy; /** * Demonstriert den Einsatz von AOSP/Google Java Style ................. Umbruch nach 100 Zeichen | */ public class MyWuppieStudi implements Comparable\u003cMyWuppieStudi\u003e { private static String lastName; private static MyWuppieStudi studi; private MyWuppieStudi() {} /** Erzeugt ein neues Exemplar der MyWuppieStudi-Spezies (max. 40 Zeilen) */ public static MyWuppieStudi getMyWuppieStudi(String name) { if (studi == null) { studi = new MyWuppieStudi(); } if (lastName == null) lastName = name; return studi; } @Override public int compareTo(MyWuppieStudi o) { return lastName.compareTo(lastName); } } Dieses Beispiel wurde nach Google Java Style/AOSP formatiert.",
    "tags": [],
    "title": "Coding Conventions und Metriken",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/coding/codingrules.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Coding",
    "content": "Was ist Refactoring? Refactoring ist, wenn einem auffällt, daß der Funktionsname foobar ziemlich bescheuert ist, und man die Funktion in sinus umbenennt.\nQuelle: \"356: Refactoring\" by Andreas Bogk on Lutz Donnerhacke: \"Fachbegriffe der Informatik\"\nRefactoring (noun): a change made to the internal structure of software to make it easier to understand and cheaper to modify without changing its observable behaviour.\nQuelle: [Fowler2011, p. 53]\nRefactoring: Änderungen an der inneren Struktur einer Software\nBeobachtbares (äußeres) Verhalten ändert sich dabei nicht Keine neuen Features einführen Keine Bugs fixen Keine öffentliche Schnittstelle ändern (Anmerkung: Bis auf Umbenennungen oder Verschiebungen von Elementen innerhalb der Software) Ziel: Verbesserung von Verständlichkeit und Änderbarkeit Anzeichen, dass Refactoring jetzt eine gute Idee wäre Code \"stinkt\" (zeigt/enthält Code Smells)\nCode Smells sind strukturelle Probleme, die im Laufe der Zeit zu Problemen führen können. Refactoring ändert die innere Struktur des Codes und kann entsprechend genutzt werden, um die Smells zu beheben.\nSchwer erklärbarer Code\nKönnten Sie Ihren Code ohne Vorbereitung in der Abgabe erklären? In einer Minute? In fünf Minuten? In zehn? Gar nicht?\nIn den letzten beiden Fällen sollten Sie definitiv über eine Vereinfachung der Strukturen nachdenken.\nVerständnisprobleme, Erweiterungen\nSie grübeln in der Abgabe, was Ihr Code machen sollte?\nSie überlegen, was Ihr Code bedeutet, um herauszufinden, wo Sie die neue Funktionalität anbauen können?\nSie suchen nach Codeteilen, finden diese aber nicht, da die sich in anderen (falschen?) Stellen/Klassen befinden?\nNutzen Sie die (neuen) Erkenntnisse, um den Code leichter verständlich zu gestalten.\n\"Three strikes and you refactor.\"\nQuelle: [Fowler2011, p. 58]: \"The Rule of Three\"\nWenn Sie sich zum dritten Mal über eine suboptimale Lösung ärgern, dann werden Sie sich vermutlich noch öfter darüber ärgern. Jetzt ist der Zeitpunkt für eine Verbesserung.\nSchauen Sie sich die entsprechenden Kapitel in [Passig2013] und [Fowler2011] an, dort finden Sie noch viele weitere Anhaltspunkte, ob und wann Refactoring sinnvoll ist.\nBevor Sie loslegen ... Unit Tests schreiben\nNormale und ungültige Eingaben Rand- und Spezialfälle Coding Conventions einhalten\nSourcecode formatieren (lassen) Haben Sie die fragliche Codestelle auch wirklich verstanden?!\nVorgehen beim Refactoring Überblick über die Methoden des Refactorings Die Refactoring-Methoden sind nicht einheitlich definiert, es existiert ein großer und uneinheitlicher \"Katalog\" an möglichen Schritten. Teilweise benennt jede IDE die Schritte etwas anders, teilweise werden unterschiedliche Möglichkeiten angeboten.\nZu den am häufigsten genutzten Methoden zählen\nRename Method/Class/Field Encapsulate Field Extract Method/Class Move Method Pull Up, Push Down (Field, Method) Best Practice Eine Best Practice (oder nennen Sie es einfach eine wichtige Erfahrung) ist, beim Refactoring langsam und gründlich vorzugehen. Sie ändern die Struktur der Software und können dabei leicht Fehler oder echte Probleme einbauen. Gehen Sie also langsam und sorgsam vor, machen Sie einen Schritt nach dem anderen und sichern Sie sich durch eine gute Testsuite ab, die Sie nach jedem Schritt erneut ausführen: Das Verhalten der Software soll sich ja nicht ändern, d.h. die Tests müssen nach jedem einzelnen Refactoring-Schritt immer grün sein (oder Sie haben einen Fehler gemacht).\nKleine Schritte: immer nur eine Änderung zu einer Zeit\nNach jedem Refactoring-Schritt Testsuite laufen lassen\n=\u003e Nächster Refactoring-Schritt erst, wenn alle Tests wieder \"grün\"\nVersionskontrolle nutzen: Jeden Schritt einzeln committen\nRefactoring-Methode: Rename Method/Class/Field Motivation Name einer Methode/Klasse/Attributs erklärt nicht ihren Zweck.\nDurchführung Name selektieren, \"Refactor \u003e Rename\"\nAnschließend ggf. prüfen Aufrufer? Superklassen?\nBeispiel Vorher\npublic String getTeN() {} Nachher\npublic String getTelefonNummer() {} Refactoring-Methode: Encapsulate Field Motivation Sichtbarkeit von Attributen reduzieren.\nDurchführung Attribut selektieren, \"Refactor \u003e Encapsulate Field\"\nAnschließend ggf. prüfen Superklassen? Referenzen? (Neue) JUnit-Tests?\nBeispiel Vorher\nint cps; public void printDetails() { System.out.println(\"Credits: \" + cps); } Nachher\nprivate int cps; int getCps() { return cps; } void setCps(int cps) { this.cps = cps; } public void printDetails() { System.out.println(\"credits: \" + getCps()); } Refactoring-Methode: Extract Method/Class Motivation Codefragment stellt eigenständige Methode dar \"Überschriften-Code\" Code-Duplizierung Code ist zu \"groß\" Klasse oder Methode erfüllt unterschiedliche Aufgaben Durchführung Codefragment selektieren, \"Refactor \u003e Extract Method\" bzw. \"Refactor \u003e Extract Class\"\nAnschließend ggf. prüfen Aufruf der neuen Methode? Nutzung der neuen Klasse? Neue JUnit-Tests nötig? Veränderung bestehender Tests nötig? Speziell bei Methoden: Nutzung lokaler Variablen: Übergabe als Parameter! Veränderung lokaler Variablen: Rückgabewert in neuer Methode und Zuweisung bei Aufruf; evtl. neue Typen nötig! Beispiel Vorher\npublic void printInfos() { printHeader(); // Details ausgeben System.out.println(\"name: \" + name); System.out.println(\"credits: \" + cps); } Nachher\npublic void printInfos() { printHeader(); printDetails(); } private void printDetails() { System.out.println(\"name: \" + name); System.out.println(\"credits: \" + cps); } Refactoring-Methode: Move Method Motivation Methode nutzt (oder wird genutzt von) mehr Eigenschaften einer fremden Klasse als der eigenen Klasse.\nDurchführung Methode selektieren, \"Refactor \u003e Move\" (ggf. \"Keep original method as delegate to moved method\" aktivieren)\nAnschließend ggf. prüfen Aufruf der neuen Methode (Delegation)? Neue JUnit-Tests nötig? Veränderung bestehender Tests nötig? Nutzung lokaler Variablen: Übergabe als Parameter! Veränderung lokaler Variablen: Rückgabewert in neuer Methode und Zuweisung bei Aufruf; evtl. neue Typen nötig! Beispiel Vorher\npublic class Kurs { int cps; String descr; } public class Studi extends Person { String name; int cps; Kurs kurs; public void printKursInfos() { System.out.println(\"Kurs: \" + kurs.descr); System.out.println(\"Credits: \" + kurs.cps); } } Nachher\npublic class Kurs { int cps; String descr; public void printKursInfos() { System.out.println(\"Kurs: \" + descr); System.out.println(\"Credits: \" + cps); } } public class Studi extends Person { String name; int cps; Kurs kurs; public void printKursInfos() { kurs.printKursInfos(); } } Refactoring-Methode: Pull Up, Push Down (Field, Method) Motivation Attribut/Methode nur für die Oberklasse relevant: Pull Up Subklassen haben identische Attribute/Methoden: Pull Up Attribut/Methode nur für eine Subklasse relevant: Push Down Durchführung Name selektieren, \"Refactor \u003e Pull Up\" oder \"Refactor \u003e Push Down\"\nAnschließend ggf. prüfen Referenzen/Aufrufer? JUnit-Tests?\nBeispiel Vorher\npublic class Person { } public class Studi extends Person { String name; public void printDetails() { System.out.println(\"name: \" + name); } } Nachher\npublic class Person { protected String name; } public class Studi extends Person { public void printDetails() { System.out.println(\"name: \" + name); } } Wrap-Up Behebung von Bad Smells durch Refactoring\n=\u003e Änderung der inneren Struktur ohne Beeinflussung des äußeren Verhaltens\nVerbessert Lesbarkeit, Verständlichkeit, Wartbarkeit Immer nur kleine Schritte machen Nach jedem Schritt Testsuite laufen lassen Katalog von Maßnahmen, beispielsweise Rename, Extract, Move, Push Up/Pull Down, ... Unterstützung durch IDEs wie Eclipse, Idea, ...",
    "description": "Was ist Refactoring? Refactoring ist, wenn einem auffällt, daß der Funktionsname foobar ziemlich bescheuert ist, und man die Funktion in sinus umbenennt.\nQuelle: \"356: Refactoring\" by Andreas Bogk on Lutz Donnerhacke: \"Fachbegriffe der Informatik\"\nRefactoring (noun): a change made to the internal structure of software to make it easier to understand and cheaper to modify without changing its observable behaviour.\nQuelle: [Fowler2011, p. 53]\nRefactoring: Änderungen an der inneren Struktur einer Software\nBeobachtbares (äußeres) Verhalten ändert sich dabei nicht Keine neuen Features einführen Keine Bugs fixen Keine öffentliche Schnittstelle ändern (Anmerkung: Bis auf Umbenennungen oder Verschiebungen von Elementen innerhalb der Software) Ziel: Verbesserung von Verständlichkeit und Änderbarkeit Anzeichen, dass Refactoring jetzt eine gute Idee wäre Code \"stinkt\" (zeigt/enthält Code Smells)",
    "tags": [],
    "title": "Refactoring",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/coding/refactoring.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Building",
    "content": "Motivation: Zusammenarbeit in Teams Szenario Projekt besteht aus diversen Teilprojekten Verschiedene Entwicklungs-Teams arbeiten (getrennt) an verschiedenen Projekten Tester entwickeln Testsuiten für die Teilprojekte Tester entwickeln Testsuiten für das Gesamtprojekt Manuelle Ausführung der Testsuiten reicht nicht Belastet den Entwicklungsprozess Keine (einheitliche) Veröffentlichung der Ergebnisse Keine (einheitliche) Eskalation bei Fehlern Keine regelmäßige Integration in Gesamtprojekt Continuous Integration Regelmäßige, automatische Ausführung: Build und Tests Reporting Weiterführung der Idee: Regelmäßiges Deployment (Continuous Deployment) Continuous Integration (CI) Vorgehen Entwickler und Tester committen ihre Änderungen regelmäßig (Git, SVN, ...) CI-Server arbeitet Build-Skripte ab, getriggert durch Events: Push-Events, Zeit/Datum, ... Typischerweise wird dabei: Das Gesamtprojekt übersetzt (\"gebaut\") Die Unit- und die Integrationstests abgearbeitet Zu festen Zeiten werden zusätzlich Systemtests gefahren Typische weitere Builds: \"Nightly Build\", Release-Build, ... Ergebnisse jeweils auf der Weboberfläche einsehbar (und per E-Mail) Einige Vorteile Tests werden regelmäßig durchgeführt (auch wenn sie lange dauern oder die Maschine stark belasten) Es wird regelmäßig ein Gesamt-Build durchgeführt Alle Teilnehmer sind über aktuellen Projekt(-zu-)stand informiert Beispiele für verbreitete CI-Umgebungen Jenkins GitLab CI/CD GitHub Actions und GitHub CI/CD Bamboo Travis CI GitLab CI/CD Siehe auch \"Get started with Gitlab CI/CD\". (Für den Zugriff wird VPN benötigt!)\nÜbersicht über Pipelines In Spalte \"Status\" sieht man das Ergebnis der einzelnen Pipelines: \"pending\" (die Pipeline läuft gerade), \"cancelled\" (Pipeline wurde manuell abgebrochen), \"passed\" (alle Jobs der Pipeline sind sauber durchgelaufen), \"failed\" (ein Job ist fehlgeschlagen, Pipeline wurde deshalb abgebrochen) In Spalte \"Pipeline\" sind die Pipelines eindeutig benannt aufgeführt, inkl. Trigger (Commit und Branch) In Spalte \"Stages\" sieht man den Zustand der einzelnen Stages Wenn man mit der Maus auf den Status oder die Stages geht, erfährt man mehr bzw. kann auf eine Seite mit mehr Informationen kommen.\nDetailansicht einer Pipeline Wenn man in eine Pipeline in der Übersicht klickt, werden die einzelnen Stages dieser Pipeline genauer dargestellt.\nDetailansicht eines Jobs Wenn man in einen Job einer Stage klickt, bekommt man quasi die Konsolenausgabe dieses Jobs. Hier kann man ggf. Fehler beim Ausführen der einzelnen Skripte oder die Ergebnisse beispielsweise der JUnit-Läufe anschauen.\nGitLab CI/CD: Konfiguration mit YAML-Datei Datei .gitlab-ci.yml im Projekt-Ordner:\nstages: - my.compile - my.test job1: script: - echo \"Hello\" - ./gradlew compileJava - echo \"wuppie!\" stage: my.compile only: - wuppie job2: script: \"./gradlew test\" stage: my.test job3: script: - echo \"Job 3\" stage: my.compile Stages Unter stages werden die einzelnen Stages einer Pipeline definiert. Diese werden in der hier spezifizierten Reihenfolge durchgeführt, d.h. zuerst würde my.compile ausgeführt, und erst wenn alle Jobs in my.compile erfolgreich ausgeführt wurden, würde anschließend my.test ausgeführt.\nDabei gilt: Die Jobs einer Stage werden (potentiell) parallel zueinander ausgeführt, und die Jobs der nächsten Stage werden erst dann gestartet, wenn alle Jobs der aktuellen Stage erfolgreich beendet wurden.\nWenn keine eigenen stages definiert werden, kann man (lt. Doku) auf die Default-Stages build, test und deploy zurückgreifen. Achtung: Sobald man eigene Stages definiert, stehen diese Default-Stages nicht mehr zur Verfügung!\nJobs job1, job2 und job3 definieren jeweils einen Job.\njob1 besteht aus mehreren Befehlen (unter script). Alternativ kann man die bei job2 gezeigte Syntax nutzen, wenn nur ein Befehl zu bearbeiten ist.\nDie Befehle werden von GitLab CI/CD in einer Shell ausgeführt.\nDie Jobs job1 und job2 sind der Stage my.compile zugeordnet (Abschnitt stage). Einer Stage können mehrere Jobs zugeordnet sein, die dann parallel ausgeführt werden.\nWenn ein Job nicht explizit einer Stage zugeordnet ist, wird er (lt. Doku) zur Default-Stage test zugewiesen. (Das geht nur, wenn es diese Stage auch gibt!)\nMit only und except kann man u.a. Branches oder Tags angeben, für die dieser Job ausgeführt (bzw. nicht ausgeführt) werden soll.\nDurch die Kombination von Jobs mit der Zuordnung zu Stages und Events lassen sich unterschiedliche Pipelines für verschiedene Zwecke definieren.\nHinweise zur Konfiguration von GitLab CI/CD Im Browser in den Repo-Einstellungen arbeiten:\nUnter Settings \u003e General \u003e Visibility, project features, permissions das CI/CD aktivieren Prüfen unter Settings \u003e CI/CD \u003e Runners, dass unter Available shared Runners mind. ein shared Runner verfügbar ist (mit grün markiert ist) Unter Settings \u003e CI/CD \u003e General pipelines einstellen: Git strategy: git clone Timeout: 10m Public pipelines: false (nicht angehakt) YAML-File (.gitlab-ci.yml) in Projektwurzel anlegen, Aufbau siehe oben Build-Skript erstellen, lokal lauffähig bekommen, dann in Jobs nutzen Im .gitlab-ci.yml die relevanten Branches einstellen (s.o.) Pushen, und unter CI/CD \u003e Pipelines das Builden beobachten in Status reinklicken und schauen, ob und wo es hakt README.md anlegen in Projektwurzel (neben .gitlab-ci.yml), Markdown-Schnipsel aus Settings \u003e CI/CD \u003e General pipelines \u003e Pipeline status auswählen und einfügen .… Optional:\nGgf. Schedules unter CI/CD \u003e Schedules anlegen Ggf. extra Mails einrichten: Settings \u003e Integrations \u003e Pipeline status emails GitHub Actions Siehe \"GitHub Actions: Automate your workflow from idea to production\" und auch \"GitHub: CI/CD explained\".\nÜbersicht über Workflows Hier sieht man das Ergebnis der letzten Workflows. Dazu sieht man den Commit und den Branch, auf dem der Workflow gelaufen ist sowie wann er gelaufen ist. Über die Spalten kann man beispielsweise nach Status oder Event filtern.\nIn der Abbildung ist ein Workflow mit dem Namen \"GitHub CI\" zu sehen, der aktuell noch läuft.\nDetailansicht eines Workflows Wenn man in einen Workflow in der Übersicht anklickt, werden die einzelnen Jobs dieses Workflows genauer dargestellt. \"job3\" ist erfolgreich gelaufen, \"job1\" läuft gerade, und \"job2\" hängt von \"job1\" ab, d.h. kann erst nach dem erfolgreichen Lauf von \"job2\" starten.\nDetailansicht eines Jobs Wenn man in einen Job anklickt, bekommt man quasi die Konsolenausgabe dieses Jobs. Hier kann man ggf. Fehler beim Ausführen der einzelnen Skripte oder die Ergebnisse beispielsweise der JUnit-Läufe anschauen.\nGitHub Actions: Konfiguration mit YAML-Datei Workflows werden als YAML-Dateien im Ordner .github/workflows/ angelegt.\nname: GitHub CI on: # push on master branch push: branches: [master] # manually triggered workflow_dispatch: jobs: job1: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - uses: actions/setup-java@v3 with: java-version: '17' distribution: 'temurin' - uses: gradle/wrapper-validation-action@v1 - run: echo \"Hello\" - run: ./gradlew compileJava - run: echo \"wuppie!\" job2: needs: job1 runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - uses: actions/setup-java@v3 with: java-version: '17' distribution: 'temurin' - uses: gradle/wrapper-validation-action@v1 - run: ./gradlew test job3: runs-on: ubuntu-latest steps: - run: echo \"Job 3\" Workflowname und Trigger-Events Der Name des Workflows wird mit dem Eintrag name spezifiziert und sollte sich im Dateinamen widerspiegeln, also im Beispiel .github/workflows/github_ci.yml.\nIm Eintrag on können die Events definiert werden, die den Workflow triggern. Im Beispiel ist ein Push-Event auf dem master-Branch definiert sowie mit workflow_dispatch: das manuelle Triggern (auf einem beliebigen Branch) freigeschaltet.\nJobs Die Jobs werden unter dem Eintrag jobs definiert: job1, job2 und job3 definieren jeweils einen Job.\njob1 besteht aus mehreren Befehlen (unter steps), die auf einem aktuellen virtualisierten Ubuntu-Runner ausgeführt werden.\nEs wird zunächst das Repo mit Hilfe der Checkout-Action ausgecheckt (uses: actions/checkout@v4), das JDK eingerichtet/installiert (uses: actions/setup-java@v3) und der im Repo enthaltene Gradle-Wrapper auf Unversehrtheit geprüft (uses: gradle/wrapper-validation-action@v1).\nDie Actions sind vordefinierte Actions und im Github unter github.com/ + Action zu finden, d.h. actions/checkout oder actions/setup-java. Actions können von jedermann definiert und bereitgestellt werden, in diesem Fall handelt es sich um von GitHub selbst im Namespace \"actions\" bereit gestellte direkt nutzbare Actions. Man kann Actions auch selbst im Ordner .github/actions/ für das Repo definieren (Beispiel: plfa.github.io).\nMit run werden Befehle in der Shell auf dem genutzten Runner (hier Ubuntu) ausgeführt.\nDie Jobs job2 ist von job1 abhängig und wird erst gestartet, wenn job1 erfolgreich abgearbeitet ist.\nAnsonsten können die Jobs prinzipiell parallel ausgeführt werden.\nDurch die Kombination von Workflows mit verschiedenen Jobs und Abhängigkeiten zwischen Jobs lassen sich unterschiedliche Pipelines (\"Workflows\") für verschiedene Zwecke definieren.\nEs lassen sich auch andere Runner benutzen, etwa ein virtualisiertes Windows oder macOS. Man kann auch über einen \"Matrix-Build\" den Workflow auf mehreren Betriebssystemen gleichzeitig laufen lassen.\nMan kann auch einen Docker-Container benutzen. Dabei muss man beachten, dass dieser am besten aus einer Registry (etwa von Docker-Hub oder aus der GitHub-Registry) \"gezogen\" wird, weil das Bauen des Docker-Containers aus einem Docker-File in der Action u.U. relativ lange dauert.\nHinweise zur Konfiguration von GitHub Actions Im Browser in den Repo-Einstellungen arbeiten:\nUnter Settings \u003e Actions \u003e General \u003e Actions permissions die Actions aktivieren (Auswahl, welche Actions erlaubt sind)\nUnter Settings \u003e Actions \u003e General \u003e Workflow permissions ggf. bestimmen, ob die Actions das Repo nur lesen dürfen oder auch zusätzlich schreiben dürfen\nUnter Actions \u003e \u003cWORKFLOW\u003e den Workflow ggf. deaktivieren:\nWrap-Up Überblick über Continuous Integration:\nKonfigurierbare Aktionen, die auf dem Gitlab-/GitHub-Server ausgeführt werden Unterschiedliche Trigger: Commit, Merge, ... Aktionen können Branch-spezifisch sein Aktionen können von anderen Aktionen abhängen",
    "description": "Motivation: Zusammenarbeit in Teams Szenario Projekt besteht aus diversen Teilprojekten Verschiedene Entwicklungs-Teams arbeiten (getrennt) an verschiedenen Projekten Tester entwickeln Testsuiten für die Teilprojekte Tester entwickeln Testsuiten für das Gesamtprojekt Manuelle Ausführung der Testsuiten reicht nicht Belastet den Entwicklungsprozess Keine (einheitliche) Veröffentlichung der Ergebnisse Keine (einheitliche) Eskalation bei Fehlern Keine regelmäßige Integration in Gesamtprojekt Continuous Integration Regelmäßige, automatische Ausführung: Build und Tests Reporting Weiterführung der Idee: Regelmäßiges Deployment (Continuous Deployment) Continuous Integration (CI)",
    "tags": [],
    "title": "Continuous Integration (CI)",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/building/ci.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Praktikum",
    "content": "Cycle Chronicles Forken Sie das \"Cycle Chronicles\"-Repo und erzeugen Sie sich eine lokale Arbeitskopie von Ihrem Fork.\nBearbeiten Sie die folgenden Teilaufgaben jeweils in einem eigenen Branch. Pushen Sie Ihre Änderungen in Ihren Fork zurück und erstellen Sie dort je einen Pull-Request auf Ihren eigenen master-Branch.\nBitte lassen Sie die Pull-Requests bis zur Vorstellung im Praktikum offen.\nAchten Sie darauf, alle Schritte nachvollziehbar in Ihrer Arbeitskopie per Git-Commit festzuhalten. Demonstrieren Sie im Praktikum, wie Sie mit den Pull-Requests arbeiten.\nIhr Code soll einheitlich formatiert und dokumentiert sein. Sie können beides prüfen: ./gradlew spotlessCheck für die Formatierung und ./gradlew checkstyleMain für die Dokumentation1 mit Javadoc.2 Während Sie die Dokumentation bei Fehlern manuell anpassen müssen (siehe Lektion “Javadoc”), können Sie mit ./gradlew spotlessApply den Code automatisch formatieren lassen - tun Sie das am besten vor jedem Commit.\nA08.1: Analyse: Äquivalenzklassen \u0026 Grenzwerte (30%) (Verteilung: 20%, 10%)\nDie Methode Shop#accept dient zur Annahme eines neuen Auftrags eines Kunden.\nNeue Aufträge sollen nur unter bestimmten Bedingungen angenommen werden:\nEs darf sich nicht um ein E-Bike handeln. Es darf sich nicht um ein Gravel-Bike handeln. Der Kunde darf nicht noch andere offene Aufträge beim Shop haben (es kann pro Kunden immer nur maximal einen offenen Auftrag in der Warteschlange geben). Es sind aktuell höchstens vier andere offene Aufträge vorhanden (es dürfen zu jeder Zeit maximal fünf offene Aufträge in der Warteschlange sein). Der Rückgabewert der Methode signalisiert, ob der Auftrag angenommen wurde und in die Warteschlange der offenen Aufträge eingereiht wurde (true) oder ob er abgelehnt wurde (false).\nAufgaben:\nErstellen Sie eine Äquivalenzklassen- und Grenzwert-Analyse. Erstellen Sie aus den ermittelten ÄK und GW konkrete Testfälle. (Noch keine Implementierung!) A08.2: Mocking I (20%) Implementieren Sie nun die in der vorigen Aufgabe ermittelten Testfälle für die Methode Shop#accept mit Hilfe von JUnit (Version 4 oder 5).\nLeider gibt es beim Ausführen vieler Ihrer JUnit-Testmethoden eine UnsupportedOperationException-Exception, da die Klasse Order bisher nur unvollständig implementiert ist: Es existieren praktisch nur die Methodensignaturen, der Aufruf der Methoden liefert nur eine UnsupportedOperationException.\nSetzen Sie aktiv Mocking mit Mockito ein, um Ihre JUnit-Tests für Shop#accept ausführbar zu machen. Begründen Sie die Anwendung von Mockito.\nWichtig: Die zu testende Methode Shop#accept soll in der vorliegenden Implementierung im Test genutzt werden, d.h. sie darf nicht \"weg-gemockt\" werden!\nTipp: In der Gradle-Konfiguration der Vorgabe ist bereits JUnit5 und Mockito vorkonfiguriert, d.h. die entsprechenden Abhängigkeiten werden durch Gradle aufgelöst. Wenn Sie die Vorgaben als Gradle-Projekt in Ihrer IDE öffnen, dann steht Ihnen dort auch die JUnit5-Bibliothek automatisch zur Verfügung. Wenn Sie JUnit4 nutzen möchten, müssten Sie bitte die Gradle-Konfiguration entsprechend anpassen. Mit ./gradlew test können Sie Ihre Testfälle ausführen.\nA08.3: Mocking II (20%) Die Methoden Shop#repair und Shop#deliver sind auch noch nicht implementiert. Nutzen Sie geeignetes Mocking, um für diese beiden Methoden Tests in JUnit zu implementieren. Begründen Sie die Anwendung von Mockito.\nHinweis: Sie müssen hier keine ÄK/GW-Analyse machen, können das aber natürlich gern tun.\nA08.4: Record-Klassen (10%) Die Klasse Order ist zwar bisher nur unvollständig implementiert, aber Sie können bereits deutlich erkennen, dass es zwei Attribute geben muss (welche?).\nBauen Sie die Klasse in eine passende Record-Klasse mit den entsprechenden Attributen um. Sie dürfen die beiden Methoden in Order auch geeignet \"implementieren\" und umbenennen - die Umbenennung muss dann aber auch in den Aufrufen in Shop und in Ihren JUnit-Tests passieren!\nA08.5: Logging (10%) Bauen Sie für den Shop ein Logging auf der Basis von java.util.logging ein: Jede Änderung an der Auftrags-Warteschlange pendingOrders und auch an der Menge der fertigen Aufträge completedOrders soll in ein gemeinsames CSV-File geloggt werden. Dabei soll pro Logging-Vorgang eine neue Zeile mit den folgenden Informationen angehängt werden:\nLog-Level, Name der den Log-Vorgang auslösenden Methode, Name der Klasse, in der die den Log-Vorgang auslösenden Methode angesiedelt ist, Log-Meldung, bestehend aus den beiden Details der Order (Fahrradtyp, Name des Kunden), und dem Namen der betroffenen Datenstruktur (\"pendingOrders\" oder \"completedOrders\"). Demonstrieren Sie in der Abgabe, wie Sie im Test oder im Hauptprogramm den Logger steuern können, beispielsweise Änderung der Log-Level oder Abschalten des Loggings.\nTipp: Der Aufruf von Shop#repair ändert sowohl pendingOrders als auch completedOrders - hier müssen also beim Logging zwei neue Zeilen im Logfile angelegt werden.\nHinweis: Da in den Klassen der Vorgabe die meisten Methoden nicht implementiert sind, müssen Sie dies für diese Aufgabe selbst flink erledigen. Es handelt sich um die vier Methoden Shop#repair und Shop#deliver sowie Order#getBicycleType und Order#getBicycleType.3\nA08.6: Dojo-Dungeon: Die Vulkanhöhle (10%) Klonen Sie das Projekt Dungeon und laden Sie es in Ihrer IDE als Gradle-Projekt. Betrachten Sie das Sub-Projekt \"dojo-dungeon\". Dies ist ein von den Tutoren4 erstelltes kleines Spiel mit vier Leveln, in denen Sie spielerisch Aufgaben lösen sollen - auf diesem Aufgabenblatt ist nur das zweite Level (\"Die Vulkanhöhle\") relevant.\nStarten Sie den Dojo-Dungeon mit ./gradlew dojo-dungeon:runDojoDungeon. Spielen Sie sich für diese Aufgabe durch das zweite Level. Sie werden drei Räume finden: Im ersten Raum müssen Sie alle Monster besiegen, bevor sich die Tür zum zweiten Raum öffnet. Dort werden Ihnen Fragen zu verschiedenen Entwurfsmustern gestellt, die Sie bitte beantworten. Im dritten Raum werden Sie gebeten, ein bestimmtes Verhalten zu implementieren, um diese Aufgabe zu lösen. (Danach steht Ihnen das nächste Level offen, aber das brauchen Sie für diese Aufgabe (noch) nicht zu lösen.)\nMachen Sie Screenshots der Fragen und Ihrer Antworten für die Vorstellung im Praktikum. Zeigen und erklären Sie die Korrekturen an der Java-Datei.\nWICHTIG: Achten Sie bitte darauf, dass im Projektpfad keine Leerzeichen und keine Sonderzeichen (Umlaute o.ä.) vorkommen! Dies kann zu seltsamen Fehler führen. Bitte auch darauf achten, dass Sie als JDK ein Java SE 21 (LTS) verwenden.\nzumindest für den syntaktischen Aspekt ... ↩︎\nSie können auch beides zusammen per ./gradlew check prüfen lassen. ↩︎\nDie Methoden Order#getBicycleType und Order#getBicycleType haben Sie sogar schon bei der Umsetzung der Record-Klassen-Aufgaben \"implementiert\" :-) ↩︎\nDer Dank für den \"dojo-dungeon\" geht an @Denniso3, @tgrothe und @JudiTeller. ↩︎",
    "description": "Cycle Chronicles Forken Sie das \"Cycle Chronicles\"-Repo und erzeugen Sie sich eine lokale Arbeitskopie von Ihrem Fork.\nBearbeiten Sie die folgenden Teilaufgaben jeweils in einem eigenen Branch. Pushen Sie Ihre Änderungen in Ihren Fork zurück und erstellen Sie dort je einen Pull-Request auf Ihren eigenen master-Branch.\nBitte lassen Sie die Pull-Requests bis zur Vorstellung im Praktikum offen.\nAchten Sie darauf, alle Schritte nachvollziehbar in Ihrer Arbeitskopie per Git-Commit festzuhalten. Demonstrieren Sie im Praktikum, wie Sie mit den Pull-Requests arbeiten.",
    "tags": [],
    "title": "Blatt 08: Cycle Chronicles (ÄK\u0026GW, Mocking)",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/homework/b08.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Java / JVM",
    "content": "Suchen in Strings Gesucht ist ein Programm zum Extrahieren von Telefonnummern aus E-Mails.\n=\u003e Wie geht das?\nLeider gibt es unzählig viele Varianten, wie man eine Telefonnummer (samt Vorwahl und ggf. Ländervorwahl) aufschreiben kann:\n030 - 123 456 789, 030-123456789, 030/123456789, +49(30)123456-789, +49 (30) 123 456 - 789, ... Definition Regulärer Ausdruck Ein regulärer Ausdruck ist eine Zeichenkette, die zur Beschreibung von Zeichenketten dient.\nAnwendungen Finden von Bestandteilen in Zeichenketten Aufteilen von Strings in Tokens Validierung von textuellen Eingaben =\u003e \"Eine Postleitzahl besteht aus 5 Ziffern\" Compilerbau: Erkennen von Schlüsselwörtern und Strukturen und Syntaxfehlern Einfachste reguläre Ausdrücke Zeichenkette Beschreibt x \"x\" . ein beliebiges Zeichen \\t Tabulator \\n Newline \\r Carriage-return \\\\ Backslash Beispiel abc =\u003e \"abc\" A.B =\u003e \"AAB\" oder \"A2B\" oder ... a\\\\bc =\u003e \"a\\bc\" Anmerkung In Java-Strings leitet der Backslash eine zu interpretierende Befehlssequenz ein. Deshalb muss der Backslash i.d.R. geschützt (\"escaped\") werden. =\u003e Statt \"\\n\" müssen Sie im Java-Code \"\\\\n\" schreiben!\nZeichenklassen Zeichenkette Beschreibt [abc] \"a\" oder \"b\" oder \"c\" [^abc] alles außer \"a\", \"b\" oder \"c\" (Negation) [a-zA-Z] alle Zeichen von \"a\" bis \"z\" und \"A\" bis \"Z\" (Range) [a-z\u0026\u0026[def]] \"d\",\"e\" oder \"f\" (Schnitt) [a-z\u0026\u0026[^bc]] \"a\" bis \"z\", außer \"b\" und \"c\": [ad-z] (Subtraktion) [a-z\u0026\u0026[^m-p]] \"a\" bis \"z\", außer \"m\" bis \"p\": [a-lq-z] (Subtraktion) Beispiel [abc] =\u003e \"a\" oder \"b\" oder \"c\" [a-c] =\u003e \"a\" oder \"b\" oder \"c\" [a-c][a-c] =\u003e \"aa\", \"ab\", \"ac\", \"ba\", \"bb\", \"bc\", \"ca\", \"cb\" oder \"cc\" A[a-c] =\u003e \"Aa\", \"Ab\" oder \"Ac\" Vordefinierte Ausdrücke Zeichenkette Beschreibt ^ Zeilenanfang $ Zeilenende \\d eine Ziffer: [0-9] \\w beliebiges Wortzeichen: [a-zA-Z_0-9] \\s Whitespace (Leerzeichen, Tabulator, Newline) \\D jedes Zeichen außer Ziffern: [^0-9] \\W jedes Zeichen außer Wortzeichen: [^\\w] \\S jedes Zeichen außer Whitespaces: [^\\s] Beispiel \\d\\d\\d\\d\\d =\u003e \"12345\" \\w\\wA =\u003e \"aaA\", \"a0A\", \"a_A\", ... Nutzung in Java java.lang.String:\npublic String[] split(String regex) public boolean matches(String regex) Demo: regexp.StringSplit java.util.regex.Pattern:\npublic static Pattern compile(String regex) public Matcher matcher(CharSequence input) Schritt 1: Ein Pattern compilieren (erzeugen) mit Pattern#compile =\u003e liefert ein Pattern-Objekt für den regulären Ausdruck zurück Schritt 2: Dem Pattern-Objekt den zu untersuchenden Zeichenstrom übergeben mit Pattern#matcher =\u003e liefert ein Matcher-Objekt zurück, darin gebunden: Pattern (regulärer Ausdruck) und die zu untersuchende Zeichenkette java.util.regex.Matcher:\npublic boolean find() public boolean matches() public int groupCount() public String group(int group) Schritt 3: Mit dem Matcher-Objekt kann man die Ergebnisse der Anwendung des regulären Ausdrucks auf eine Zeichenkette auswerten\nBedeutung der unterschiedlichen Methoden siehe folgende Folien\nMatcher#group: Liefert die Sub-Sequenz des Suchstrings zurück, die erfolgreich gematcht wurde (siehe unten \"Fangende Gruppierungen\")\nHinweis:\nIn Java-Strings leitet der Backslash eine zu interpretierende Befehlssequenz ein. Deshalb muss der Backslash i.d.R. extra geschützt (\"escaped\") werden.\n=\u003e Statt \"\\n\" (regulärer Ausdruck) müssen Sie im Java-String \"\\\\n\" schreiben!\n=\u003e Statt \"a\\\\bc\" (regulärer Ausdruck, passt auf die Zeichenkette \"a\\bc\") müssen Sie im Java-String \"a\\\\\\\\bc\" schreiben!\nDemo: regexp.MatchFind Unterschied zw. Finden und Matchen Matcher#find:\nRegulärer Ausdruck muss im Suchstring enthalten sein. =\u003e Suche nach erstem Vorkommen\nMatcher#matches:\nRegulärer Ausdruck muss auf kompletten Suchstring passen.\nBeispiel Regulärer Ausdruck: abc, Suchstring: \"blah blah abc blub\" Matcher#find: erfolgreich Matcher#matches: kein Match - Suchstring entspricht nicht dem Muster Quantifizierung Zeichenkette Beschreibt X? ein oder kein \"X\" X* beliebig viele \"X\" (inkl. kein \"X\") X+ mindestens ein \"X\", ansonsten beliebig viele \"X\" X{n} exakt $n$ Vorkommen von \"X\" X{n,} mindestens $n$ Vorkommen von \"X\" X{n,m} zwischen $n$ und $m$ Vorkommen von \"X\" Beispiel \\d{5} =\u003e \"12345\" -?\\d+\\.\\d* =\u003e ??? Interessante Effekte Pattern p = Pattern.compile(\"A.*A\"); Matcher m = p.matcher(\"A 12 A 45 A\"); if (m.matches()) String result = m.group(); // ??? Demo: regexp.Quantifier Matcher#group liefert die Inputsequenz, auf die der Matcher angesprochen hat. Mit Matcher#start und Matcher#end kann man sich die Indizes des ersten und letzten Zeichens des Matches im Eingabezeichenstrom geben lassen. D.h. für einen Matcher m und eine Eingabezeichenkette s ist m.group() und s.substring(m.start(), m.end()) äquivalent.\nDa bei Matcher#matches das Pattern immer auf den gesamten Suchstring passen muss, verwundert das Ergebnis für Matcher#group nicht. Bei Matcher#find wird im Beispiel allerdings ebenfalls der gesamte Suchstring \"gefunden\" ... Dies liegt am \"greedy\" Verhalten der Quantifizierer.\nNicht gierige Quantifizierung mit \"?\" Zeichenkette Beschreibt X*? non-greedy Variante von X* X+? non-greedy Variante von X+ Beispiel Suchstring \"A 12 A 45 A\": A.*A findet/passt auf \"A 12 A 45 A\"\nnormale greedy Variante\nA.*?A\nfindet \"A 12 A\" passt auf \"A 12 A 45 A\" (!) non-greedy Variante der Quantifizierung; Matcher#matches muss trotzdem auf den gesamten Suchstring passen!\n(Fangende) Gruppierungen Studi{2} passt nicht auf \"StudiStudi\" (!)\nQuantifizierung bezieht sich auf das direkt davor stehende Zeichen. Ggf. Gruppierungen durch Klammern verwenden!\nZeichenkette Beschreibt X|Y X oder Y (C) Gruppierung Beispiel (A)(B(C)) Gruppe 0: ABC Gruppe 1: A Gruppe 2: BC Gruppe 3: C Die Gruppen heißen auch \"fangende\" Gruppen (engl.: \"capturing groups\").\nDamit erreicht man eine Segmentierung des gesamten regulären Ausdrucks, der in seiner Wirkung aber nicht durch die Gruppierungen geändert wird. Durch die Gruppierungen von Teilen des regulären Ausdrucks erhält man die Möglichkeit, auf die entsprechenden Teil-Matches (der Unterausdrücke der einzelnen Gruppen) zuzugreifen:\nMatcher#groupCount: Anzahl der \"fangenden\" Gruppen im regulären Ausdruck\nMatcher#group(i): Liefert die Subsequenz der Eingabezeichenkette zurück, auf die die jeweilige Gruppe gepasst hat. Dabei wird von links nach rechts durchgezählt, beginnend bei 1(!).\nKonvention: Gruppe 0 ist das gesamte Pattern, d.h. m.group(0) == m.group(); ...\nHinweis: Damit der Zugriff auf die Gruppen klappt, muss auch erst ein Match gemacht werden, d.h. das Erzeugen des Matcher-Objekts reicht noch nicht, sondern es muss auch noch ein matcher.find() oder matcher.matches() ausgeführt werden. Danach kann man bei Vorliegen eines Matches auf die Gruppen zugreifen.\n(Studi){2} =\u003e \"StudiStudi\"\nDemo: regexp.Groups Gruppen und Backreferences Matche zwei Ziffern, gefolgt von den selben zwei Ziffern\n(\\d\\d)\\1\nVerweis auf bereits gematchte Gruppen: \\num\nnum Nummer der Gruppe (1 ... 9)\n=\u003e Verweist nicht auf regulären Ausdruck, sondern auf jeweiligen Match!\nAnmerkung: Laut Literatur/Doku nur 1 ... 9, in Praxis geht auch mehr per Backreference ...\nBenennung der Gruppe: (?\u003cname\u003eX)\nX ist regulärer Ausdruck für Gruppe, spitze Klammern wichtig\n=\u003e Backreference: \\k\u003cname\u003e\nDemo: regexp.Backref Beispiel Gruppen und Backreferences Regulärer Ausdruck: Namen einer Person matchen, wenn Vor- und Nachname identisch sind.\nLösung: ([A-Z][a-zA-Z]*)\\s\\1\nUmlaute und reguläre Ausdrücke Keine vordefinierte Abkürzung für Umlaute (wie etwa \\d)\nUmlaute nicht in [a-z] enthalten, aber in [a-ü]\n\"helloüA\".matches(\".*?[ü]A\"); \"azäöüß\".matches(\"[a-ä]\"); \"azäöüß\".matches(\"[a-ö]\"); \"azäöüß\".matches(\"[a-ü]\"); \"azäöüß\".matches(\"[a-ß]\"); Strings sind Unicode-Zeichenketten\n=\u003e Nutzung der passenden Unicode Escape Sequence \\uFFFF\nSystem.out.println(\"\\u0041 :: A\"); System.out.println(\"helloüA\".matches(\".*?A\")); System.out.println(\"helloüA\".matches(\".*?\\u0041\")); System.out.println(\"helloü\\u0041\".matches(\".*?A\")); RegExp vordefinieren und mit Variablen zusammenbauen ala Perl nicht möglich =\u003e Umweg String-Repräsentation\nWrap-Up RegExp: Zeichenketten, die andere Zeichenketten beschreiben java.util.regex.Pattern und java.util.regex.Matcher Unterschied zwischen Matcher#find und Matcher#matches! Quantifizierung ist möglich, aber greedy (Default)",
    "description": "Suchen in Strings Gesucht ist ein Programm zum Extrahieren von Telefonnummern aus E-Mails.\n=\u003e Wie geht das?\nLeider gibt es unzählig viele Varianten, wie man eine Telefonnummer (samt Vorwahl und ggf. Ländervorwahl) aufschreiben kann:\n030 - 123 456 789, 030-123456789, 030/123456789, +49(30)123456-789, +49 (30) 123 456 - 789, ... Definition Regulärer Ausdruck Ein regulärer Ausdruck ist eine Zeichenkette, die zur Beschreibung von Zeichenketten dient.\nAnwendungen Finden von Bestandteilen in Zeichenketten Aufteilen von Strings in Tokens Validierung von textuellen Eingaben =\u003e \"Eine Postleitzahl besteht aus 5 Ziffern\" Compilerbau: Erkennen von Schlüsselwörtern und Strukturen und Syntaxfehlern Einfachste reguläre Ausdrücke Zeichenkette Beschreibt x \"x\" . ein beliebiges Zeichen \\t Tabulator \\n Newline \\r Carriage-return \\\\ Backslash Beispiel abc =\u003e \"abc\" A.B =\u003e \"AAB\" oder \"A2B\" oder ... a\\\\bc =\u003e \"a\\bc\" Anmerkung In Java-Strings leitet der Backslash eine zu interpretierende Befehlssequenz ein. Deshalb muss der Backslash i.d.R. geschützt (\"escaped\") werden. =\u003e Statt \"\\n\" müssen Sie im Java-Code \"\\\\n\" schreiben!",
    "tags": [],
    "title": "Reguläre Ausdrücke",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/java-jvm/regexp.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Pattern",
    "content": "Motivation: Syntax-Highlighting im Tokenizer In einem Compiler ist meist der erste Arbeitsschritt, den Eingabestrom in einzelne Token aufzubrechen. Dies sind oft die verschiedenen Schlüsselwörter, Operationen, Namen von Variablen, Methoden, Klassen etc. ... Aus der Folge von Zeichen (also dem eingelesenen Programmcode) wird ein Strom von Token, mit dem die nächste Stufe im Compiler dann weiter arbeiten kann.\npublic class Lexer { private final List\u003cToken\u003e allToken; // alle verfügbaren Token-Klassen public List\u003cToken\u003e tokenize(String string) { List\u003cToken\u003e result = new ArrayList\u003c\u003e(); while (string.length() \u003e 0) { for (Token t : allToken) { Token token = t.match(string); if (token != null) { result.add(token); string = string.substring(token.getContent().length(), string.length()); } } } return result; } } Dazu prüft man jedes Token, ob es auf den aktuellen Anfang des Eingabestroms passt. Wenn ein Token passt, erzeugt man eine Instanz dieser Token-Klasse und speichert darin den gematchten Eingabeteil, den man dann vom Eingabestrom entfernt. Danach geht man in die Schleife und prüft wieder alle Token ... bis irgendwann der Eingabestrom leer ist und man den gesamten eingelesenen Programmcode in eine dazu passende Folge von Token umgewandelt hat.\nAnmerkung: Abgesehen von fehlenden Javadoc etc. hat das obige Code-Beispiel mehrere Probleme: Man würde im realen Leben nicht mit String, sondern mit einem Zeichenstrom arbeiten. Außerdem fehlt noch eine Fehlerbehandlung, wenn nämlich keines der Token in der Liste allToken auf den aktuellen Anfang des Eingabestroms passt.\nToken-Klassen mit formatiertem Inhalt Um den eigenen Tokenizer besser testen zu können, wurde beschlossen, dass jedes Token seinen Inhalt als formatiertes HTML-Schnipsel zurückliefern soll. Damit kann man dann alle erkannten Token formatiert ausgeben und erhält eine Art Syntax-Highlighting für den eingelesenen Programmcode.\npublic abstract class Token { protected String content; abstract protected String getHtml(); } public class KeyWord extends Token { @Override protected String getHtml() { return \"\u003cfont color=\\\"red\\\"\u003e\u003cb\u003e\" + this.content + \"\u003c/b\u003e\u003c/font\u003e\"; } } public class StringContent extends Token { @Override protected String getHtml() { return \"\u003cfont color=\\\"green\\\"\u003e\" + this.content + \"\u003c/font\u003e\"; } } Token t = new KeyWord(); LOG.info(t.getHtml()); In der ersten Umsetzung erhält die Basisklasse Token eine weitere abstrakte Methode, die jede Token-Klasse implementieren muss und in der die Token-Klassen einen String mit dem Token-Inhalt und einer Formatierung für HTML zurückgeben.\nDabei fällt auf, dass der Aufbau immer gleich ist: Es werden ein oder mehrere Tags zum Start der Format-Sequenz mit dem Token-Inhalt verbunden, gefolgt mit einem zum verwendeten startenden HTML-Format-Tag passenden End-Tag.\nAuch wenn die Inhalte unterschiedlich sind, sieht das stark nach einer Verletzung von DRY aus ...\nDon't call us, we'll call you public abstract class Token { protected String content; public final String getHtml() { return htmlStart() + this.content + htmlEnd(); } abstract protected String htmlStart(); abstract protected String htmlEnd(); } public class KeyWord extends Token { @Override protected String htmlStart() { return \"\u003cfont color=\\\"red\\\"\u003e\u003cb\u003e\"; } @Override protected String htmlEnd() { return \"\u003c/b\u003e\u003c/font\u003e\"; } } public class StringContent extends Token { @Override protected String htmlStart() { return \"\u003cfont color=\\\"green\\\"\u003e\"; } @Override protected String htmlEnd() { return \"\u003c/font\u003e\"; } } Token t = new KeyWord(); LOG.info(t.getHtml()); Wir können den Spaß einfach umdrehen (\"inversion of control\") und die Methode zum Zusammenbasteln des HTML-Strings bereits in der Basisklasse implementieren. Dazu \"rufen\" wir dort drei Hilfsmethoden auf, die die jeweiligen Bestandteile des Strings (Format-Start, Inhalt, Format-Ende) erzeugen und deren konkrete Implementierung wir in der Basisklasse nicht kennen. Dies ist dann Sache der ableitenden konkreten Token-Klassen.\nObjekte vom Typ KeyWord sind dank der Vererbungsbeziehung auch Token (Vererbung: is-a-Beziehung). Wenn man nun auf einem Token t die Methode getHtml() aufruft, wird zur Laufzeit geprüft, welchen Typ t tatsächlich hat (im Beispiel KeyWord). Methodenaufrufe werden dann mit den am tiefsten in der vorliegenden Vererbungshierarchie implementierten Methoden durchgeführt: Hier wird also die von Token geerbte Methode getHtml() in KeyWord aufgerufen, die ihrerseits die Methoden htmlStart() und htmlEnd() aufruft. Diese sind in KeyWord implementiert und liefern nun die passenden Ergebnisse.\nDie Methode getHtml() wird auch als \"Template-Methode\" bezeichnet. Die beiden darin aufgerufenen Methoden htmlStart() und htmlEnd() in Token werden auch als \"Hilfsmethoden\" (oder \"Helper Methods\") bezeichnet.\nDies ist ein Beispiel für das Template-Method-Pattern.\nTemplate-Method-Pattern Aufbau Template-Method-Pattern In der Basisklasse implementiert man eine Template-Methode (in der Skizze templateMethod), die sich auf anderen in der Basisklasse deklarierten (Hilfs-) Methoden \"abstützt\" (diese also aufruft; in der Skizze method1, method2, method3). Diese Hilfsmethoden können als abstract markiert werden und müssen dann von den ableitenden Klassen implementiert werden (in der Skizze method1 und method2). Man kann aber auch einige/alle dieser aufgerufenen Hilfsmethoden in der Basisklasse implementieren (beispielsweise mit einem leeren Body - sogenannte \"Hook\"-Methoden) und die ableitenden Klassen können dann diese Methoden überschreiben und das Verhalten so neu formulieren (in der Skizze method3).\nDamit werden Teile des Verhaltens an die ableitenden Klassen ausgelagert.\nVerwandtschaft zum Strategy-Pattern Das Template-Method-Pattern hat eine starke Verwandtschaft zum Strategy-Pattern.\nIm Strategy-Pattern haben wir Verhalten komplett an andere Objekte delegiert, indem wir in einer Methode einfach die passende Methode auf dem übergebenen Strategie-Objekt aufgerufen haben.\nIm Template-Method-Pattern nutzen wir statt Delegation die Mechanismen Vererbung und dynamische Polymorphie und definieren in der Basis-Klasse abstrakte oder Hook-Methoden, die wir bereits in der Template-Methode der Basis-Klasse aufrufen. Damit ist das grobe Verhalten in der Basis-Klasse festgelegt, wird aber in den ableitenden Klassen durch das dortige Definieren oder Überschreiben der Hilfsmethoden verfeinert. Zur Laufzeit werden dann durch die dynamische Polymorphie die tatsächlich implementierten Hilfsmethoden in den ableitenden Klassen aufgerufen. Damit lagert man im Template-Method-Pattern gewissermaßen nur Teile des Verhaltens an die ableitenden Klassen aus.\nWrap-Up Template-Method-Pattern: Verhaltensänderung durch Vererbungsbeziehungen\nBasis-Klasse: Template-Methode, die Verhalten definiert und Hilfsmethoden aufruft Hilfsmethoden: Abstrakte Methoden (oder \"Hook\": Basis-Implementierung) Ableitende Klassen: Verfeinern Verhalten durch Implementieren der Hilfsmethoden Zur Laufzeit: Dynamische Polymorphie: Aufruf der Template-Methode nutzt die im tatsächlichen Typ des Objekts implementierten Hilfsmethoden",
    "description": "Motivation: Syntax-Highlighting im Tokenizer In einem Compiler ist meist der erste Arbeitsschritt, den Eingabestrom in einzelne Token aufzubrechen. Dies sind oft die verschiedenen Schlüsselwörter, Operationen, Namen von Variablen, Methoden, Klassen etc. ... Aus der Folge von Zeichen (also dem eingelesenen Programmcode) wird ein Strom von Token, mit dem die nächste Stufe im Compiler dann weiter arbeiten kann.\npublic class Lexer { private final List\u003cToken\u003e allToken; // alle verfügbaren Token-Klassen public List\u003cToken\u003e tokenize(String string) { List\u003cToken\u003e result = new ArrayList\u003c\u003e(); while (string.length() \u003e 0) { for (Token t : allToken) { Token token = t.match(string); if (token != null) { result.add(token); string = string.substring(token.getContent().length(), string.length()); } } } return result; } } Dazu prüft man jedes Token, ob es auf den aktuellen Anfang des Eingabestroms passt. Wenn ein Token passt, erzeugt man eine Instanz dieser Token-Klasse und speichert darin den gematchten Eingabeteil, den man dann vom Eingabestrom entfernt. Danach geht man in die Schleife und prüft wieder alle Token ... bis irgendwann der Eingabestrom leer ist und man den gesamten eingelesenen Programmcode in eine dazu passende Folge von Token umgewandelt hat.",
    "tags": [],
    "title": "Template-Method-Pattern",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/pattern/template-method.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Pattern",
    "content": "Motivation Irgendwo im Dungeon wird es ein Objekt einer Klasse ähnlich wie InputHandler geben mit einer Methode ähnlich zu handleInput():\npublic class InputHandler { public void handleInput() { switch (keyPressed()) { case BUTTON_W -\u003e hero.jump(); case BUTTON_A -\u003e hero.moveX(); case ... default -\u003e { ... } } } } Diese Methode wird je Frame einmal aufgerufen, um auf eventuelle Benutzereingaben reagieren zu können. Je nach gedrücktem Button wird auf dem Hero eine bestimmte Aktion ausgeführt ...\nDas funktioniert, ist aber recht unflexibel. Die Aktionen sind den Buttons fest zugeordnet und erlauben keinerlei Konfiguration.\nAuflösen der starren Zuordnung über Zwischenobjekte public interface Command { void execute(); } public class Jump implements Command { private Entity e; public void execute() { e.jump(); } } public class InputHandler { private final Command wbutton = new Jump(hero); // Über Ctor/Methoden setzen! private final Command abutton = new Move(hero); // Über Ctor/Methoden setzen! public void handleInput() { switch (keyPressed()) { case BUTTON_W -\u003e wbutton.execute(); case BUTTON_A -\u003e abutton.execute(); case ... default -\u003e { ... } } } } Die starre Zuordnung \"Button : Aktion\" wird aufgelöst und über Zwischenobjekte konfigurierbar gemacht.\nFür die Zwischenobjekte wird ein Typ Command eingeführt, der nur eine execute()-Methode hat. Für jede gewünschte Aktion wird eine Klasse davon abgeleitet, diese Klassen können auch einen Zustand pflegen.\nDen Buttons wird nun an geeigneter Stelle (Konstruktor, Methoden, ...) je ein Objekt der jeweiligen Command-Unterklassen zugeordnet. Wenn ein Button betätigt wird, wird auf dem Objekt die Methode execute() aufgerufen.\nDamit die Kommandos nicht nur auf den Helden wirken können, kann man den Kommando-Objekten beispielsweise noch eine Entität mitgeben, auf der das Kommando ausgeführt werden soll. Im Beispiel oben wurde dafür der hero genutzt.\nCommand: Objektorientierte Antwort auf Callback-Funktionen Im Command-Pattern gibt es vier beteiligte Parteien: Client, Receiver, Command und Invoker.\nEin Command ist die objektorientierte Abstraktion eines Befehls. Es hat möglicherweise einen Zustand, und und kennt \"seinen\" Receiver und kann beim Aufruf der execute()-Methode eine vorher verabredete Methode auf diesem Receiver-Objekt ausführen.\nEin Receiver ist eine Klasse, die Aktionen durchführen kann. Sie kennt die anderen Akteure nicht.\nDer Invoker (manchmal auch \"Caller\" genannt) ist eine Klasse, die Commands aggregiert und die die Commandos \"ausführt\", indem hier die execute()-Methode aufgerufen wird. Diese Klasse kennt nur das Command-Interface und keine spezifischen Kommandos (also keine der Sub-Klassen). Es kann zusätzlich eine gewisse Buchführung übernehmen, etwa um eine Undo-Funktionalität zu realisieren.\nDer Client ist ein Programmteil, der ein Command-Objekt aufbaut und dabei einen passenden Receiver übergibt und der das Command-Objekt dann zum Aufruf an den Invoker weiterreicht.\nIn unserem Beispiel lassen sich die einzelnen Teile so sortieren:\nClient: Klasse InputHandler (erzeugt neue Command-Objekte im obigen Code) bzw. main(), wenn man die Command-Objekte dort erstellt und an den Konstruktor von InputHandler weiterreicht Receiver: Objekt hero der Klasse Hero (auf diesem wird eine Aktion ausgeführt) Command: Jump und Move Invoker: InputHandler (in der Methode handleInput()) Undo Wir könnten das Command-Interface um ein paar Methoden erweitern:\npublic interface Command { void execute(); void undo(); Command newCommand(Entity e); } Jetzt kann jedes Command-Objekt eine neue Instanz erzeugen mit der Entity, die dann dieses Kommando empfangen soll:\npublic class Move implements Command { private Entity e; private int x, y, oldX, oldY; public void execute() { oldX = e.getX(); oldY = e.getY(); x = oldX + 42; y = oldY; e.moveTo(x, y); } public void undo() { e.moveTo(oldX, oldY); } public Command newCommand(Entity e) { return new Move(e); } } public class InputHandler { private final Command wbutton; private final Command abutton; private final Stack\u003cCommand\u003e s = new Stack\u003c\u003e(); public void handleInput() { Entity e = getSelectedEntity(); switch (keyPressed()) { case BUTTON_W -\u003e { s.push(wbutton.newCommand(e)); s.peek().execute(); } case BUTTON_A -\u003e { s.push(abutton.newCommand(e)); s.peek().execute(); } case BUTTON_U -\u003e s.pop().undo(); case ... default -\u003e { ... } } } } Über den Konstruktor von InputHandler (im Beispiel nicht gezeigt) würde man wie vorher die Command-Objekte für die Buttons setzen. Es würde aber in jedem Aufruf von handleInput() abgefragt, was gerade die selektierte Entität ist und für diese eine neue Instanz des zur Tastatureingabe passenden Command-Objekts erzeugt. Dieses wird nun in einem Stack gespeichert und danach ausgeführt.\nWenn der Button \"U\" gedrückt wird, wird das letzte Command-Objekt aus dem Stack genommen (Achtung: Im echten Leben müsste man erst einmal schauen, ob hier noch was drin ist!) und auf diesem die Methode undo() aufgerufen. Für das Kommando Move ist hier skizziert, wie ein Undo aussehen könnte: Man muss einfach bei jedem execute() die alte Position der Entität speichern, dann kann man sie bei einem undo() wieder auf diese Position verschieben. Da für jeden Move ein neues Objekt angelegt wird und dieses nur einmal benutzt wird, braucht man keine weitere Buchhaltung ...\nWrap-Up Command-Pattern: Kapsele Befehle in ein Objekt\nCommand-Objekte haben eine Methode execute() und führen darin Aktion auf Receiver aus Receiver sind Objekte, auf denen Aktionen ausgeführt werden (Hero, Monster, ...) Invoker hat Command-Objekte und ruft darauf execute() auf Client kennt alle und baut alles zusammen Objektorientierte Antwort auf Callback-Funktionen",
    "description": "Motivation Irgendwo im Dungeon wird es ein Objekt einer Klasse ähnlich wie InputHandler geben mit einer Methode ähnlich zu handleInput():\npublic class InputHandler { public void handleInput() { switch (keyPressed()) { case BUTTON_W -\u003e hero.jump(); case BUTTON_A -\u003e hero.moveX(); case ... default -\u003e { ... } } } } Diese Methode wird je Frame einmal aufgerufen, um auf eventuelle Benutzereingaben reagieren zu können. Je nach gedrücktem Button wird auf dem Hero eine bestimmte Aktion ausgeführt ...",
    "tags": [],
    "title": "Command-Pattern",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/pattern/command.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Java / JVM",
    "content": "Motivation public class Studi { public static final int IFM = 0; public static final int ELM = 1; public static final int ARC = 2; public Studi(String name, int credits, int studiengang) { // Wert für studiengang muss zwischen 0 und 2 liegen // Erwünscht: Konstanten nutzen } public static void main(String[] args) { Studi rainer = new Studi(\"Rainer\", 10, Studi.IFM); Studi holger = new Studi(\"Holger\", 3, 4); // Laufzeit-Problem! } } Probleme:\nKeine Typsicherheit Konstanten gehören zur Klasse Studi, obwohl sie in anderem Kontext vermutlich auch interessant sind Beispiel enums.v1.Studi Verbesserung: Einfache Aufzählung public enum Fach { IFM, ELM, ARC } public class Studi { public Studi(String name, int credits, Fach studiengang) { // Typsicherheit für studiengang :-) } public static void main(String[] args) { Studi rainer = new Studi(\"Rainer\", 10, Fach.IFM); Studi holger = new Studi(\"Holger\", 3, 4); // Syntax-Fehler! } } Einfache Aufzählungen: Eigenschaften public enum Fach { IFM, ELM, ARC } Enum-Konstanten (IFM, ...) sind implizit static und final Enumerations (Fach) nicht instantiierbar Enumerations stellen einen neuen Typ dar: hier der Typ Fach Methoden: name(), ordinal(), values(), toString() Wiederholung static Attribute:\nstatic Attribute sind Eigenschaften/Zustände der Klasse Gelten in jedem von der Klasse erzeugten Objekt Unterschiedliche Lebensdauer: Objektattribute (Instanzvariablen): ab new bis zum Garbage Collector Statische Variablen: Laufzeitumgebung (JVM) lädt und initialisiert die Klasse (static Attribute existieren, bis die JVM die Klasse entfernt) Methoden:\nstatic deklarierte Methoden sind Klassenmethoden Können direkt auf der Klasse aufgerufen werden Beispiele: Math.max(), Math.sin(), Integer.parseInt() Achtung: In Klassenmethoden nur Klassenattribute nutzbar (keine Instanzattribute!), d.h. keine this-Referenz nutzbar Wiederholung final: Attribute/Methoden/Klassen nicht änderbar Attribute: final Attribute können nur einmal gesetzt werden\nvoid foo() { int i = 2; final int j = 3; final int k; i = 3; j = 4; // Compilerfehler k = 5; k = 6; // Compilerfehler } Beispiel enums.FinalDemo Methoden: final deklarierte Methoden können bei Vererbung nicht überschrieben werden\nKlassen: von final deklarierten Klassen können keine Unterklassen gebildet werden\nEinfache Aufzählungen: Eigenschaften (cnt.) // Referenzen auf Enum-Objekte können null sein Fach f = null; f = Fach.IFM; // Vergleich mit == möglich // equals() unnötig, da Vergleich mit Referenz auf statische Variable if (f == Fach.IFM) { System.out.println(\"Richtiges Fach :-)\"); } // switch/case switch (f) { case IFM: // Achtung: *NICHT* Fach.IFM System.out.println(\"Richtiges Fach :-)\"); break; default: throw new IllegalArgumentException(\"FALSCHES FACH: \" + f); } Außerdem können wir folgende Eigenschaften nutzen (u.a., s.u.):\nEnumerations haben Methode String toString() für die Konstanten Enumerations haben Methode final T[] values() für die Iteration über die Konstanten Demo: enums.v2.Studi Enum: Genauer betrachtet public enum Fach { IFM, ELM, ARC } Compiler sieht (in etwa):\npublic class Fach extends Enum { public static final Fach IFM = new Fach(\"IFM\", 0); public static final Fach ELM = new Fach(\"ELM\", 1); public static final Fach ARC = new Fach(\"ARC\", 2); private Fach( String s, int i ) { super( s, i ); } } =\u003e Singleton-Pattern für Konstanten\nEnum-Klassen: Eigenschaften public enum Fach { IFM, ELM(\"Elektrotechnik Praxisintegriert\", 1, 30), ARC(\"Architektur\", 4, 40), PHY(\"Physik\", 3, 10); private final String description; private final int number; private final int capacity; Fach() { this(\"Informatik Bachelor\", 0, 60); } Fach(String descr, int number, int capacity) { this.description = descr; this.number = number; this.capacity = capacity; } public String getDescription() { return \"Konstante: \" + name() + \" (Beschreibung: \" + description + \", Kapazitaet: \" + capacity + \", Nummer: \" + number + \", Ordinal: \" + ordinal() + \")\"; } } Konstruktoren und Methoden für Enum-Klassen definierbar Kein eigener Aufruf von super (!) Konstruktoren implizit private Compiler fügt automatisch folgende Methoden hinzu (Auswahl): Strings: public final String name() =\u003e Name der Konstanten (final!) public String toString() =\u003e Ruft name() auf, überschreibbar Konstanten: public final T[] values() =\u003e Alle Konstanten der Aufzählung public final int ordinal() =\u003e Interne Nummer der Konstanten (Reihenfolge des Anlegens der Konstanten!) public static T valueOf(String) =\u003e Zum String passende Konstante (via name()) Hinweis: Diese Methoden gibt es auch bei den \"einfachen\" Enumerationen (s.o.).\nDemo: enums.v3 Wrap-Up Aufzählungen mit Hilfe von enum (Compiler erzeugt intern Klassen)\nKomplexe Enumerations analog zu Klassendefinition: Konstruktoren, Felder und Methoden (keine Instanzen von Enum-Klassen erzeugbar)\nEnum-Konstanten sind implizit final und static\nCompiler stellt Methoden name(), ordinal() und values() zur Verfügung\nName der Konstanten Interne Nummer der Konstanten (Reihenfolge des Anlegens) Array mit allen Konstanten der Enum-Klasse",
    "description": "Motivation public class Studi { public static final int IFM = 0; public static final int ELM = 1; public static final int ARC = 2; public Studi(String name, int credits, int studiengang) { // Wert für studiengang muss zwischen 0 und 2 liegen // Erwünscht: Konstanten nutzen } public static void main(String[] args) { Studi rainer = new Studi(\"Rainer\", 10, Studi.IFM); Studi holger = new Studi(\"Holger\", 3, 4); // Laufzeit-Problem! } } Probleme:\nKeine Typsicherheit Konstanten gehören zur Klasse Studi, obwohl sie in anderem Kontext vermutlich auch interessant sind Beispiel enums.v1.Studi Verbesserung: Einfache Aufzählung public enum Fach { IFM, ELM, ARC } public class Studi { public Studi(String name, int credits, Fach studiengang) { // Typsicherheit für studiengang :-) } public static void main(String[] args) { Studi rainer = new Studi(\"Rainer\", 10, Fach.IFM); Studi holger = new Studi(\"Holger\", 3, 4); // Syntax-Fehler! } } Einfache Aufzählungen: Eigenschaften public enum Fach { IFM, ELM, ARC } Enum-Konstanten (IFM, ...) sind implizit static und final Enumerations (Fach) nicht instantiierbar Enumerations stellen einen neuen Typ dar: hier der Typ Fach Methoden: name(), ordinal(), values(), toString() Wiederholung static Attribute:",
    "tags": [],
    "title": "Aufzählungen (Enumerations)",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/java-jvm/enums.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Praktikum",
    "content": "DevDungeon: Illusion Riddle Klonen Sie das Projekt DevDungeon und laden Sie es in Ihrer IDE als Gradle-Projekt. Betrachten Sie das Sub-Projekt \"devDungeon\". Dies ist ein von einem Studierenden (@Flamtky) erstelltes Spiel mit mehreren Leveln, in denen Sie spielerisch verschiedene Aufgaben in-game und ex-game lösen müssen.\nA09.1: DevDungeon: Lösen des Illusion Riddle (20%) Starten Sie den DevDungeon mit ./gradlew devDungeon:runDevDungeon. Spielen Sie sich für diese Aufgabe durch das dritte Level (\"Illusion Riddle\")1.\nIn diesem Level gibt es mehrere Räume, die durch Teleporter (statt Türen) miteinander verbunden sind. Beim Betreten dieser nur schwer erkennbaren dunkleren Bodenkacheln werden Sie in den nächsten Raum transportiert. Während dieser Mechanismus deterministisch ist, gibt es zusätzlich eine neue Monster-Art, die Sie mit fischähnlich aussehenden Geschossen angreift und bei einem Treffer in einen zufälligen Raum transportiert.\nIm Level sind insgesamt drei Schalter verborgen, von denen Sie mindestens zwei finden und betätigen müssen, damit die weiteren Übergänge freigeschaltet werden. Die Reihenfolge spielt dabei keine Rolle.\nLeider ist durch den starken Fog of War kaum etwas zu sehen. Auch die vielen Fackeln verbessern die Sicht nicht wirklich. Können Sie mit diesen Fackeln irgendwie interagieren?\nZiel ist es, den Weg zum letzten Raum des Levels zu finden und den dort wartenden Boss-Gegner zu besiegen.\nTipp: Es könnte hilfreich sein, sich eine Skizze der Räume anzufertigen. Diese sind in diesem Level bei jedem Start identisch.\nTipp: Es könnte in einem bestimmten Raum hilfreich sein, mehrfach im Kreis zu laufen ...\nTipp: Eine Code-Analyse könnte helfen. Vielleicht können Sie durch Anpassungen im Code die Sicht verbessern oder die Gesundheit Ihres Helden verbessern oder die Teleportationsgeschosse unschädlich machen? Streng genommen ist das natürlich cheaten, aber da Sie ja Code lesen und anpassen üben, können wir im Rahmen dieser Lehrveranstaltung darüber hinwegsehen. Erklären Sie im Praktikum, welche Änderungen Sie wo und warum vorgenommen haben und was das bewirkt.\nHinweis: Aktuell ist das Projekt DevDungeon an einigen Stellen noch Work-in-Progress, beispielsweise fehlt häufig noch die Javadoc. Alle Gradle-Tasks, die von Checkstyle-Tasks abhängen (checkstyleMain, check, build, ...) werden deshalb fehlschlagen. Sie können den DevDungeon aber wie oben beschrieben mit ./gradlew devDungeon:runDevDungeon (bzw. über den Task devDungeon:runDevDungeon aus der IDE heraus) starten.\nWICHTIG: Achten Sie bitte darauf, dass im Projektpfad keine Leerzeichen und keine Sonderzeichen (Umlaute o.ä.) vorkommen! Dies kann zu seltsamen Fehler führen. Bitte auch darauf achten, dass Sie als JDK ein Java SE 21 (LTS) verwenden.\nA09.2: DevDungeon: Refactoring der Klasse IllusionRiddleLevel (20%) Analysieren Sie die Klasse IllusionRiddleLevel im Package level.devlevel, insbesondere die beiden Methoden IllusionRiddleLevel#onTick und IllusionRiddleLevel#lightTorch:\nWelche Bad Smells können Sie hier identifizieren?\nBeheben Sie die Smells durch die schrittweise Anwendung von den aus der Vorlesung bekannten Refactoring-Methoden. Ergänzend zu der Übersicht aus der Vorlesung finden sie unter Refactoring Guru eine erweiterte Darstellung gängiger Refactoring-Techniken.\nMachen Sie pro Refactoring-Schritt einen Commit, und halten Sie alle Commits in einem Pull-Request fest. An diesem können Sie im Praktikum Ihr Vorgehen vorstellen.\nTipp: Schauen Sie schlechter Namensgebung, nach redundantem Code, nach übermäßig komplexer Logik, nach Code/Logik in der falschen Klasse (am falschen Ort), nach übermäßig vielen Parametern, nach fehlendem Javadoc, .…\nHinweis: Normalerweise erstellen Sie eine Testsuite, bevor Sie mit dem Refactoring beginnen. Leider ist durch die Abhängigkeit zu libGDX und der Game-Loop das Testen im (Dev-) Dungeon nicht trivial, so dass Sie hier ausnahmsweise direkt mit dem Refactoring loslegen dürfen und auf das Erstellen einer Testsuite verzichten können.\nA09.3: Protector-Skill für Ihren Hero (20%) Erstellen Sie einen neuen Protector-Skill für den Hero und weisen Sie diesen einer Taste zu. Bei Nutzung des Skills soll ein neues Protector-Monster an einer zufälligen Position in einem bestimmten Radius um den Helden erzeugt werden. Das Protector-Monster sucht das räumlich nächste Monster, nähert sich diesem automatisch bis auf Angriffsdistanz und greift dieses dann so lange mit Feuerbällen an, bis eines der beiden Monster keine Lebenspunkte mehr hat. Der Skill soll einen Cool-Down haben, d.h. er soll erst nach einer gewissen Zeit erneut benutzbar sein.\nNutzen Sie diesen neuen Skill im dritten Level (\"Illusion Riddle\") und schauen Sie, ob Sie dadurch leichter zum Ausgang des Levels kommen.\nHinweis: Erinnern Sie sich an die ECS-Architektur. Schauen Sie sich u.a. die Factory HeroFactory und den FireballSkill an.\nA09.4: Refactoring im Bike-Shop (40%) Forken Sie das Refactoring-Repo und erzeugen Sie sich eine lokale Arbeitskopie von Ihrem Fork. Analysieren Sie die Klassen im Package refactoring. Sie finden unübersichtlichen und schlecht strukturierten und schlecht benannten Code.\nWelche Bad Smells können Sie hier identifizieren?\nErstellen Sie eine Testsuite, um potentielle Verhaltensänderungen beim Refactoring identifizieren zu können.\nBeheben Sie die Smells durch die schrittweise Anwendung von den aus der Vorlesung bekannten Refactoring-Methoden. Wenden Sie dabei mindestens die unten genannten Methoden an:\nExtract Method/Class Move Method/Field Encapsulate Method/Field Pull Up oder Push Down Ergänzend zu der Übersicht aus der Vorlesung finden sie unter Refactoring Guru eine erweiterte Darstellung gängiger Refactoring-Techniken.\nMachen Sie pro Refactoring-Schritt einen Commit, und halten Sie alle Commits in einem Pull-Request fest. An diesem können Sie im Praktikum Ihr Vorgehen vorstellen.\nNach dem Refactoring sollte ein ./gradlew check keine Probleme bzgl. Formatierung und Dokumentation mehr finden.\nTipp: Schauen Sie schlechter Namensgebung, nach redundantem Code, nach übermäßig komplexer Logik, nach Code/Logik in der falschen Klasse (am falschen Ort), nach übermäßig vielen Parametern, nach fehlendem Javadoc, .…\nDas dritte richtige Level, also das dritte Level nach dem Demo-Level. Oder eben das vierte Level, wenn man das Demo-Level mitzählt :-) ↩︎",
    "description": "DevDungeon: Illusion Riddle Klonen Sie das Projekt DevDungeon und laden Sie es in Ihrer IDE als Gradle-Projekt. Betrachten Sie das Sub-Projekt \"devDungeon\". Dies ist ein von einem Studierenden (@Flamtky) erstelltes Spiel mit mehreren Leveln, in denen Sie spielerisch verschiedene Aufgaben in-game und ex-game lösen müssen.\nA09.1: DevDungeon: Lösen des Illusion Riddle (20%) Starten Sie den DevDungeon mit ./gradlew devDungeon:runDevDungeon. Spielen Sie sich für diese Aufgabe durch das dritte Level (\"Illusion Riddle\")1.",
    "tags": [],
    "title": "Blatt 09: DevDungeon (Refactoring)",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/homework/b09.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024)",
    "content": "Einführung in die nebenläufige Programmierung mit Threads Synchronisation: Verteilter Zugriff auf gemeinsame Ressourcen High-Level Concurrency",
    "description": "Einführung in die nebenläufige Programmierung mit Threads Synchronisation: Verteilter Zugriff auf gemeinsame Ressourcen High-Level Concurrency",
    "tags": [],
    "title": "Multi-Threading: Parallelisierung von Programmen",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/threads.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Threads",
    "content": "42 Demo: misc.SwingWorkerDemo (GUI ausprobieren) Einführung in nebenläufige Programmierung Traditionelle Programmierung Aufruf einer Methode verlagert Kontrollfluss in diese Methode Code hinter Methodenaufruf wird erst nach Beendigung der Methode ausgeführt public class Traditional { public static void main(String... args) { Traditional x = new Traditional(); System.out.println(\"main(): vor run()\"); x.run(); System.out.println(\"main(): nach run()\"); } public void run() { IntStream.range(0, 10).mapToObj(i -\u003e \"in run()\").forEach(System.out::println); } } Demo: intro.Traditional Nebenläufige Programmierung Erzeugung eines neuen Kontrollflussfadens (Thread) Läuft (quasi-) parallel zu bisherigem Kontrollfluss Threads können unabhängig von einander arbeiten Zustandsverwaltung durch Java-VM (oder Unterstützung durch Betriebssystem) Aufruf einer bestimmten Methode erzeugt neuen Kontrollflussfaden Der neue Thread arbeitet \"parallel\" zum bisherigen Thread Kontrolle kehrt sofort wieder zurück: Code hinter dem Methodenaufruf wird ausgeführt ohne auf die Beendigung der aufgerufenen Methode zu warten Verteilung der Threads auf die vorhandenen Prozessorkerne abhängig von der Java-VM public class Threaded extends Thread { public static void main(String... args) { Threaded x = new Threaded(); System.out.println(\"main(): vor run()\"); x.start(); System.out.println(\"main(): nach run()\"); } @Override public void run() { IntStream.range(0, 10).mapToObj(i -\u003e \"in run()\").forEach(System.out::println); } } Demo: intro.Threaded Erzeugen von Threads Ableiten von Thread oder Implementierung von Runnable\nMethode run() implementieren, aber nicht aufrufen\nMethode start() aufrufen, aber (i.d.R.) nicht implementieren\nDemo: creation.* Ableiten von Thread start() startet den Thread und sorgt für Ausführung von run() start() nur einmal aufrufen Implementierung von Runnable Ebenfalls run() implementieren Neues Thread-Objekt erzeugen, Konstruktor das eigene Runnable übergeben Für Thread-Objekt die Methode start() aufrufen Startet den Thread (das Runnable) und sorgt für Ausführung von run() Vorteil von Runnable: Ist ein Interface, d.h. man kann noch von einer anderen Klasse erben\nZustandsmodell von Threads (vereinfacht) Threads haben einen Lebenszyklus: Nach dem Erzeugen der Objekte mit new wird der Thread noch nicht ausgeführt. Er ist sozusagen in einem Zustand \"erzeugt\". Man kann bereits mit dem Objekt interagieren, also auf Attribute zugreifen und Methoden aufrufen.\nDurch den Aufruf der Methode start() gelangt der Thread in einen Zustand \"ausführungsbereit\", er läuft also aus Nutzersicht. Allerdings hat er noch keine Ressourcen zugeteilt (CPU, ...), so dass er tatsächlich noch nicht rechnet. Sobald er vom Scheduler eine Zeitscheibe zugeteilt bekommt, wechselt er in den Zustand \"rechnend\" und führt den Inhalt der run()-Methode aus. Von hier kann er nach Ablauf der Zeitscheibe durch den Scheduler wieder nach \"ausführungsbereit\" zurück überführt werden. Dieses Wechselspiel passiert automatisch und i.d.R. schnell, so dass selbst auf Maschinen mit nur einem Prozessor/Kern der Eindruck einer parallelen Verarbeitung entsteht.\nNach der Abarbeitung der run()-Methode oder bei einer nicht gefangenen Exception wird der Thread beendet und kann nicht wieder neu gestartet werden. Auch wenn der Thread abgelaufen ist, kann man mit dem Objekt wie üblich interagieren (nur eben nicht mehr parallel).\nBei Zugriff auf gesperrte Ressourcen oder durch Aufrufe von Methoden wie sleep() oder join() kann ein Thread blockiert werden. Hier führt der Thread nichts aus, bekommt durch den Scheduler aber auch keine neue Zeitscheibe zugewiesen. Aus diesem Zustand gelangt der Thread wieder heraus, etwa durch Interrupts (Aufruf der Methode interrupt() auf dem Thread-Objekt) oder nach Ablauf der Schlafzeit (in sleep()) oder durch ein notify, und wird wieder zurück nach \"ausführungsbereit\" versetzt und wartet auf die Zuteilung einer Zeitscheibe durch den Scheduler.\nSie finden in [Boles2008, Kapitel 5.2 \"Thread-Zustände\"] eine schöne ausführliche Darstellung.\nThreads können wie normale Objekte kommunizieren Zugriff auf (public) Attribute (oder eben über Methoden) Aufruf von Methoden Threads können noch mehr Eine Zeitlang schlafen: Thread.sleep(\u003cduration_ms\u003e)\nStatische Methode der Klasse Thread (Klassenmethode) Aufrufender Thread wird bis zum Ablauf der Zeit oder bis zum Aufruf der interrupt()-Methode des Threads blockiert \"Moderne\" Alternative: TimeUnit, beispielsweise TimeUnit.SECONDS.sleep( 2 ); Prozessor abgeben und hinten in Warteschlange einreihen: yield()\nAndere Threads stören: otherThreadObj.interrupt()\nDie Methoden sleep(), wait() und join() im empfangenden Thread otherThreadObj lösen eine InterruptedException aus, wenn sie durch die Methode interrupt() unterbrochen werden. Das heißt, interrupt() beendet diese Methoden mit der Ausnahme. Empfangender Thread verlässt ggf. den Zustand \"blockiert\" und wechselt in den Zustand \"ausführungsbereit\" Warten auf das Ende anderer Threads: otherThreadObj.join()\nAusführender Thread wird blockiert (also nicht otherThreadObj!) Blockade des Aufrufers wird beendet, wenn der andere Thread (otherThreadObj) beendet wird. Hinweis: Ein Thread wird beendet, wenn\ndie run()-Methode normal endet, oder die run()-Methode durch eine nicht gefangene Exception beendet wird, oder von außen die Methode stop() aufgerufen wird (Achtung: Deprecated! Einen richtigen Ersatz gibt es aber auch nicht.). Hinweis: Die Methoden wait(), notify()/notifyAll() und die \"synchronized-Sperre\" werden in der Sitzung [\"Threads: Synchronisation\"](threads-intro. besprochen.\nDemo: intro.Join Wrap-Up Threads sind weitere Kontrollflussfäden, von Java-VM (oder (selten) von OS) verwaltet\nAbleiten von Thread oder implementieren von Runnable Methode run enthält den auszuführenden Code Starten des Threads mit start (nie mit run!)",
    "description": "42 Demo: misc.SwingWorkerDemo (GUI ausprobieren) Einführung in nebenläufige Programmierung Traditionelle Programmierung Aufruf einer Methode verlagert Kontrollfluss in diese Methode Code hinter Methodenaufruf wird erst nach Beendigung der Methode ausgeführt public class Traditional { public static void main(String... args) { Traditional x = new Traditional(); System.out.println(\"main(): vor run()\"); x.run(); System.out.println(\"main(): nach run()\"); } public void run() { IntStream.range(0, 10).mapToObj(i -\u003e \"in run()\").forEach(System.out::println); } } Demo: intro.Traditional Nebenläufige Programmierung Erzeugung eines neuen Kontrollflussfadens (Thread) Läuft (quasi-) parallel zu bisherigem Kontrollfluss Threads können unabhängig von einander arbeiten Zustandsverwaltung durch Java-VM (oder Unterstützung durch Betriebssystem) Aufruf einer bestimmten Methode erzeugt neuen Kontrollflussfaden Der neue Thread arbeitet \"parallel\" zum bisherigen Thread Kontrolle kehrt sofort wieder zurück: Code hinter dem Methodenaufruf wird ausgeführt ohne auf die Beendigung der aufgerufenen Methode zu warten Verteilung der Threads auf die vorhandenen Prozessorkerne abhängig von der Java-VM public class Threaded extends Thread { public static void main(String... args) { Threaded x = new Threaded(); System.out.println(\"main(): vor run()\"); x.start(); System.out.println(\"main(): nach run()\"); } @Override public void run() { IntStream.range(0, 10).mapToObj(i -\u003e \"in run()\").forEach(System.out::println); } } Demo: intro.Threaded Erzeugen von Threads Ableiten von Thread oder Implementierung von Runnable",
    "tags": [],
    "title": "Einführung in die nebenläufige Programmierung mit Threads",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/threads/threads-intro.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Threads",
    "content": "Motivation: Verteilter Zugriff auf gemeinsame Ressourcen public class Teaser implements Runnable { private int val = 0; public static void main(String... args) { Teaser x = new Teaser(); new Thread(x).start(); new Thread(x).start(); } private void incrVal() { ++val; System.out.println(Thread.currentThread().getId() + \": \" + val); } public void run() { IntStream.range(0, 5).forEach(i -\u003e incrVal()); } } Demo: synchronised.Teaser Zugriff auf gemeinsame Ressourcen: Mehrseitige Synchronisierung synchronized (\u003cObject reference\u003e) { \u003cstatements (synchronized)\u003e } =\u003e \"Mehrseitige Synchronisierung\"\nFallunterscheidung: Thread T1 führt synchronized-Anweisung aus:\nSperre im Sperr-Objekt nicht gesetzt: T1 setzt Sperre beim Eintritt, führt den Block aus, und löst Sperre beim Verlassen Sperre durch T1 gesetzt: T1 führt den Block aus, und löst Sperre beim Verlassen nicht Sperre durch T2 gesetzt: =\u003e T1 wird blockiert, bis T2 die Sperre löst Anmerkung: Das für die Synchronisierung genutzte Objekt nennt man \"Wächter-Objekt\" oder auch \"Sperr-Objekt\" oder auch \"Synchronisations-Objekt\".\nDamit könnte man den relevanten Teil der Methode incrVal() beispielsweise in einen geschützten Bereich einschließen und als Sperr-Objekt das eigene Objekt (this) einsetzen:\nprivate void incrVal() { synchronized (this) { ++val; } } Demo: synchronised.ObjSync Synchronisierte Methoden void f() { synchronized (this) { ... } } ... ist äquivalent zu ...\nsynchronized void f() { ... } Kurzschreibweise: Man spart das separate Wächter-Objekt und synchronisiert auf sich selbst ...\nDie Methode incrVal() könnte entsprechend so umgeschrieben werden:\nprivate synchronized void incrVal() { ++val; } Demo: synchronised.MethodSync Probleme bei der (mehrseitigen) Synchronisierung: Deadlocks public class Deadlock { private final String name; public synchronized String getName() { return name; } public synchronized void foo(Deadlock other) { System.out.format(\"%s: %s.foo() \\n\", Thread.currentThread().getName(), name); System.out.format(\"%s: %s.name()\\n\", Thread.currentThread().getName(), other.getName()); } public static void main(String... args) { final Deadlock a = new Deadlock(\"a\"); final Deadlock b = new Deadlock(\"b\"); new Thread(() -\u003e a.foo(b)).start(); new Thread(() -\u003e b.foo(a)).start(); } } Viel hilft hier nicht viel! Durch zu großzügige mehrseitige Synchronisierung kann es passieren, dass Threads gegenseitig aufeinander warten: Thread A belegt eine Ressource, die ein anderer Thread B haben möchte und Thread B belegt eine Ressource, die A gerne bekommen würde. Da es dann nicht weitergeht, nennt man diese Situation auch \"Deadlock\" (\"Verklemmung\").\nIm Beispiel ruft der erste Thread für das Objekt a die foo()-Methode auf und holt sich damit den Lock auf a. Um die Methode beenden zu können, muss noch die getName()-Methode vom Objekt b durch diesen ersten Thread aufgerufen werden. Dafür muss der erste Thread den Lock auf b bekommen.\nDummerweise hat parallel der zweite Thread auf dem Objekt b die foo()-Methode aufgerufen und sich damit den Lock auf b geholt. Damit muss der erste Thread so lange warten, bis der zweite Thread den Lock auf b freigibt.\nDas wird allerdings nicht passieren, da der zweite Thread zur Beendigung der foo()-Methode noch getName() auf a ausführen muss und dazu den Lock auf b holen, den aber aktuell der erste Thread hält.\nUnd schon geht's nicht mehr weiter :-)\nDemo: synchronised.Deadlock Warten auf andere Threads: Einseitige Synchronisierung Problem Thread T1 wartet auf Arbeitsergebnis von T2 T2 ist noch nicht fertig Mögliche Lösungen Aktives Warten (Polling): Permanente Abfrage Kostet unnötig Rechenzeit Schlafen mit Thread.sleep() Etwas besser; aber wie lange soll man idealerweise schlafen? Warten mit T2.join() Macht nur Sinn, wenn T1 auf das Ende von T2 wartet Einseitige Synchronisierung mit wait() und notify() Das ist DIE Lösung für das Problem :) Einseitige Synchronisierung mit wait und notify wait: Warten auf Erfüllung einer Bedingung (Thread blockiert):\nsynchronized (obj) { // Geschützten Bereich betreten while (!condition) { try { obj.wait(); // Thread wird blockiert } catch (InterruptedException e) {} } ... // Condition erfüllt: Tue Deine Arbeit } =\u003e Bedingung nach Rückkehr von wait erneut prüfen!\nEigenschaften von wait Thread ruft auf Synchronisations-Objekt die Methode wait auf Prozessor wird entzogen, Thread blockiert Thread wird in interne Warteschlange des Synchronisations-Objekts eingetragen Sperre auf Synchronisations-Objekt wird freigegeben =\u003e Geht nur innerhalb der synchronized-Anweisung für das Synchronisations-Objekt!\nEinseitige Synchronisierung mit wait und notify (cnt.) notify: Aufwecken von wartenden (blockierten) Threads:\nsynchronized (obj) { obj.notify(); // einen Thread \"in\" obj aufwecken obj.notifyAll(); // alle Threads \"in\" obj wecken } Eigenschaften von notify bzw. notifyAll Thread ruft auf einem Synchronisations-Objekt die Methode notify oder notifyAll auf Falls Thread(s) in Warteschlange des Objekts vorhanden, dann notify: Ein zufälliger Thread wird aus Warteschlange entfernt und in den Zustand \"ausführungsbereit\" versetzt notifyAll: Alle Threads werden aus Warteschlange entfernt und in den Zustand \"ausführungsbereit\" versetzt =\u003e Geht nur innerhalb der synchronized-Anweisung für das Synchronisations-Objekt!\nDemo: synchronised.Staffel Wrap-Up Synchronisierungsbedarf bei verteiltem Zugriff auf gemeinsame Ressourcen:\nVorsicht mit konkurrierendem Ressourcenzugriff: Synchronisieren mit synchronized =\u003e Mehrseitige Synchronisierung\nWarten auf Ereignisse mit wait und notify/notifyAll =\u003e Einseitige Synchronisierung",
    "description": "Motivation: Verteilter Zugriff auf gemeinsame Ressourcen public class Teaser implements Runnable { private int val = 0; public static void main(String... args) { Teaser x = new Teaser(); new Thread(x).start(); new Thread(x).start(); } private void incrVal() { ++val; System.out.println(Thread.currentThread().getId() + \": \" + val); } public void run() { IntStream.range(0, 5).forEach(i -\u003e incrVal()); } } Demo: synchronised.Teaser Zugriff auf gemeinsame Ressourcen: Mehrseitige Synchronisierung synchronized (\u003cObject reference\u003e) { \u003cstatements (synchronized)\u003e } =\u003e \"Mehrseitige Synchronisierung\"\nFallunterscheidung: Thread T1 führt synchronized-Anweisung aus:",
    "tags": [],
    "title": "Synchronisation: Verteilter Zugriff auf gemeinsame Ressourcen",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/threads/threads-synchronisation.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Threads",
    "content": "Explizite Lock-Objekte Sie kennen bereits die Synchronisierung mit dem Schlüsselwort synchronized.\n// Synchronisierung der gesamten Methode public synchronized int incrVal() { ... } // Synchronisierung eines Blocks (eines Teils einer Methode) public int incrVal() { ... synchronized (someObj) { ... } ... } Dabei wird implizit ein Lock über ein Objekt (das eigene Objekt im ersten Fall, das Sperrobjekt im zweiten Fall) benutzt.\nSeit Java5 kann man alternativ auch explizite Lock-Objekte nutzen:\n// Synchronisierung eines Teils einer Methode über ein // Lock-Objekt (seit Java 5) // Package `java.util.concurrent.locks` public int incrVal() { Lock waechter = new ReentrantLock(); ... waechter.lock(); ... // Geschützter Bereich waechter.unlock(); ... } Locks aus dem Paket java.util.concurrent.locks arbeiten analog zum impliziten Locken über synchronized. Sie haben darüber hinaus aber einige Vorteile:\nMethoden zum Abfragen, ob ein Lock möglich ist: Lock#tryLock Methoden zum Abfragen der aktuellen Warteschlangengröße: Lock#getQueueLength Verfeinerung ReentrantReadWriteLock mit Methoden readLock und writeLock Locks nur zum Lesen bzw. nur zum Schreiben Lock#newCondition liefert ein Condition-Objekt zur Benachrichtigung ala wait/notify: await/signal =\u003e zusätzliches Timeout beim Warten möglich Nachteile:\nBei Exceptions werden implizite Locks durch synchronized automatisch durch das Verlassen der Methode freigegeben. Explizite Locks müssen durch den Programmierer freigegeben werden! =\u003e Nutzung des finally-Block! Demo: lock.* Thread-Management: Executor-Interface und Thread-Pools Wiederverwendung von Threads Normale Threads sind immer Einmal-Threads: Man kann sie nur einmal in ihrem Leben starten (auch wenn das Objekt anschließend noch auf Nachrichten bzw. Methodenaufrufe reagiert)\nZusätzliches Problem: Threads sind Objekte:\nThreads brauchen relativ viel Arbeitsspeicher Erzeugen und Entsorgen von Threads kostet Ressourcen Zu viele Threads: Gesamte Anwendung hält an Idee: Threads wiederverwenden und Thread-Management auslagern =\u003e Executor-Interface und Thread-Pool\nExecutor-Interface public interface Executor { void execute(Runnable command); } Neue Aufgaben als Runnable an einen Executor via execute übergeben Executor könnte damit sofort neuen Thread starten (oder alten wiederverwenden): e.execute(r); =\u003e entspricht in der Wirkung (new Thread(r)).start(); Thread-Pool hält Menge von \"Worker-Threads\" Statische Methoden von java.util.concurrent.Executors erzeugen Thread-Pools mit verschiedenen Eigenschaften:\nExecutors#newFixedThreadPool erzeugt ExecutorService mit spezifizierter Anzahl von Worker-Threads Executors#newCachedThreadPool erzeugt Pool mit Threads, die nach 60 Sekunden Idle wieder entsorgt werden Rückgabe: ExecutorService (Thread-Pool)\npublic interface ExecutorService extends Executor { ... } Executor#execute übergibt Runnable dem nächsten freien Worker-Thread (oder erzeugt ggf. neuen Worker-Thread bzw. hängt Runnable in Warteschlange, je nach erzeugtem Pool)\nMethoden zum Beenden eines Thread-Pools (Freigabe): shutdown(), isShutdown(), ...\nMyThread x = new MyThread(); // Runnable oder Thread ExecutorService pool = Executors.newCachedThreadPool(); pool.execute(x); // x.start() pool.execute(x); // x.start() pool.execute(x); // x.start() pool.shutdown(); // Feierabend :) Demo: executor.ExecutorDemo Hintergrund (vereinfacht) Der Thread-Pool reserviert sich \"nackten\" Speicher, der der Größe von $n$ Threads entspricht, und \"prägt\" die Objektstruktur durch einen Cast direkt auf (ohne wirkliche neue Objekte zu erzeugen). Dieses Vorgehen ist in der C-Welt wohlbekannt und schnell (vgl. Thema Speicherverwaltung in der LV \"Systemprogrammierung\"). In Java wird dies durch eine wohldefinierte Schnittstelle vor dem Nutzer verborgen.\nAusblick Hier haben wir nur die absoluten Grundlagen angerissen. Wir können auch Callables anstatt von Runnables übergeben, auf Ergebnisse aus der Zukunft warten (Futures), Dinge zeitgesteuert (immer wieder) starten, ...\nSchauen Sie sich bei Interesse die weiterführende Literatur an, beispielsweise die Oracle-Dokumentation oder auch [Ullenboom2021] (insbesondere den Abschnitt 16.4 \"Der Ausführer (Executor) kommt\").\nFork/Join-Framework: Teile und Herrsche Spezieller Thread-Pool zur rekursiven Bearbeitung parallelisierbarer Tasks\njava.util.concurrent.ForkJoinPool#invoke startet Task\nTask muss von RecursiveTask\u003cV\u003e erben:\npublic abstract class RecursiveTask\u003cV\u003e extends ForkJoinTask\u003cV\u003e { protected abstract V compute(); } Prinzipieller Ablauf:\npublic class RecursiveTask extends ForkJoinTask\u003cV\u003e { protected V compute() { if (task klein genug) { berechne task sequentiell } else { teile task in zwei subtasks: left, right = new RecursiveTask(task) rufe compute() auf beiden subtasks auf: left.fork(); // starte neuen Thread r = right.compute(); // nutze aktuellen Thread warte auf ende der beiden subtasks: l = left.join() kombiniere die ergebnisse der beiden subtasks: l+r } } } Demo: forkjoin.ForkJoin Swing und Threads Lange Berechnungen in Listenern blockieren Swing-GUI Problem: Events werden durch einen Event Dispatch Thread (EDT) sequentiell bearbeitet Lösung: Berechnungen in neuen Thread auslagern Achtung: Swing ist nicht Thread-safe! Komponenten nicht durch verschiedene Threads manipulieren! Lösung =\u003e javax.swing.SwingWorker ist eine spezielle Thread-Klasse, eng mit Swing/Event-Modell verzahnt.\nImplementieren:\nSwingWorker#doInBackground: Für die langwierige Berechnung (muss man selbst implementieren) SwingWorker#done: Wird vom EDT aufgerufen, wenn doInBackground fertig ist Aufrufen:\nSwingWorker#execute: Started neuen Thread nach Anlegen einer Instanz und führt dann automatisch doInBackground aus SwingWorker#get: Return-Wert von doInBackground abfragen Anmerkungen SwingWorker#done ist optional: kann überschrieben werden Beispielweise, wenn nach Beendigung der langwierigen Berechnung GUI-Bestandteile mit dem Ergebnis aktualisiert werden sollen SwingWorker\u003cT, V\u003e ist eine generische Klasse: T Typ für das Ergebnis der Berechnung, d.h. Rückgabetyp für doInBackground und get V Typ für Zwischenergebnisse Demo: misc.SwingWorkerDemo Letzte Worte :-) Viele weitere Konzepte\nSemaphoren, Monitore, ... Leser-Schreiber-Probleme, Verklemmungen, ... =\u003e Verweis auf LV \"Betriebssysteme\" und \"Verteilte Systeme\"\nAchtung: Viele Klassen sind nicht Thread-safe!\nEs gibt aber meist ein \"Gegenstück\", welches Thread-safe ist.\nBeispiel Listen:\njava.util.ArrayList ist nicht Thread-safe java.util.Vector ist Thread-sicher =\u003e Siehe Javadoc in den JDK-Klassen!\nThread-safe bedeutet Overhead (Synchronisierung)!\nWrap-Up Multi-Threading auf höherem Level: Thread-Pools und Fork/Join-Framework\nFeingranulareres und flexibleres Locking mit Lock-Objekten und Conditions Wiederverwendung von Threads: Thread-Management mit Executor-Interface und Thread-Pools Fork/Join-Framework zum rekursiven Zerteilen von Aufgaben und zur parallelen Bearbeitung der Teilaufgaben SwingWorker für die parallele Bearbeitung von Aufgaben in Swing",
    "description": "Explizite Lock-Objekte Sie kennen bereits die Synchronisierung mit dem Schlüsselwort synchronized.\n// Synchronisierung der gesamten Methode public synchronized int incrVal() { ... } // Synchronisierung eines Blocks (eines Teils einer Methode) public int incrVal() { ... synchronized (someObj) { ... } ... } Dabei wird implizit ein Lock über ein Objekt (das eigene Objekt im ersten Fall, das Sperrobjekt im zweiten Fall) benutzt.\nSeit Java5 kann man alternativ auch explizite Lock-Objekte nutzen:",
    "tags": [],
    "title": "High-Level Concurrency",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/threads/threads-highlevel.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Java / JVM",
    "content": "Wie kann man Programme konfigurieren? Parameter beim Start mitgeben: Kommandozeilenparameter (CLI)\nKonfigurationsdatei einlesen und auswerten\nVarianten von Kommandozeilenparameter Fixe Reihenfolge\njava MyApp 10 20 hello debug\nBenannte Parameter I\njava MyApp -x 10 -y 20 -answer hello -d\nBenannte Parameter II\njava MyApp --breite=10 --hoehe=20 --answer=hello --debug\nHäufig Mischung von Kurz- und Langformen\nHäufig hat man eine Kurzform der Optionen, also etwa \"-x\". Dabei ist der Name der Option in der Regel ein Zeichen lang. Es gibt aber auch Abweichungen von dieser Konvention, denken Sie beispielsweise an java -version.\nIn der Langform nutzt man dann einen aussagekräftigen Namen und stellt zwei Bindestriche voran, also beispielsweise \"--breite\" (als Alternative für \"-x\").\nWenn Optionen Parameter haben, schreibt man in der Kurzform üblicherweise \"-x 10\" (trennt also den Parameter mit einem Leerzeichen von der Option) und in der Langform \"--breite=10\" (also mit einem \"=\" zwischen Option und Parameter). Das sind ebenfalls Konventionen, d.h. man kann prinzipiell auch in der Kurzform das \"=\" nutzen, also \"-x=10\", oder in der Langform mit einem Leerzeichen trennen, also \"--breite 10\".\nDemo IDE und CLI Hinweis IntelliJ: \"Edit Configurations\" =\u003e Kommandozeilenparameter unter \"Build and run\" im entsprechenden Feld eintragen\nAuswertung Kommandozeilenparameter Kommandozeilenparameter werden als String-Array an main()-Methode übergeben:\npublic static void main(String[] args) { } public static void main(String... argv) { } =\u003e Müssen \"händisch\" ausgewertet werden\nAnmerkung: Nur Parameter! Nicht Programmname als erster Eintrag wie in C ...\nBeispiel Auswertung Kommandozeilenparameter public static void main(String[] args) { int x = 100; String answer = \"\"; boolean debug = false; // Parameter: -x=10 -answer=hello -debug // =\u003e args = [\"-x=10\", \"-answer=hello\", \"-debug\"] for (String param : args) { if (param.startsWith(\"-x\")) { x = Integer.parseInt(param.substring(3)); } if (param.startsWith(\"-a\")) { answer = param.substring(8); } if (param.startsWith(\"-d\")) { debug = true; } } } Kritik an manueller Auswertung Kommandozeilenparameter Umständlich und unübersichtlich Große if-else-Gebilde in main() Kurz- und Langform müssen getrennt realisiert werden Optionale Parameter müssen anders geprüft werden als Pflichtparameter Überlappende Parameternamen schwer aufzufinden Prüfung auf korrekten Typ nötig bei Parametern mit Werten Hilfe bei Fehlern muss separat realisiert und gepflegt werden Apache Commons: CLI Rad nicht neu erfinden!\nApache Commons bietet die CLI-Bibliothek zum Umgang mit Kommandozeilenparametern an: commons.apache.org/cli Annäherung an fremde API:\nLesen der verfügbaren Doku (PDF, HTML) Lesen der verfügbaren Javadoc Herunterladen der Bibliothek Einbinden ins Projekt Exkurs: Einbinden fremder Bibliotheken/APIs Eclipse Lib von commons.apache.org herunterladen und auspacken Neuen Unterordner im Projekt anlegen: libs/ Bibliothek (.jar-Files) hinein kopieren Projektexplorer, Kontextmenü auf .jar-File: \"Add as Library\" Alternativ Menü-Leiste: \"Project \u003e Properties \u003e Java Build Path \u003e Libraries \u003e Add JARs\" IntelliJ Variante 1: Lib von commons.apache.org herunterladen und auspacken Neuen Unterordner im Projekt anlegen: libs/ Bibliothek (.jar-Files) hinein kopieren Variante 1 (a):Projektexplorer, Kontextmenü auf .jar-File: \"Build Path \u003e Add to Build Path\" Variante 1 (b): Projekteigenschaften, Eintrag \"Libraries\", \"+\", \"New Project Library\", \"Java\" und Jar-File auswählen Variante 2: Projekteigenschaften, Eintrag \"Libraries\", \"+\", \"New Project Library\", \"From Maven\" und \"commons-cli:commons-cli:1.5.0\" als Suchstring eingeben und die Suche abschließen Gradle oder Ant oder Maven Lib auf Maven Central suchen: \"commons-cli:commons-cli\" als Suchstring eingeben Passenden Dependency-Eintrag in das Build-Skript kopieren Kommandozeilenaufruf Class-Path bei Aufruf setzen:\nUnix: java -cp .:\u003cjarfile\u003e:\u003cjarfile\u003e \u003cmainclass\u003e Windows: java -cp .;\u003cjarfile\u003e;\u003cjarfile\u003e \u003cmainclass\u003e Achtung: Unter Unix (Linux, MacOS) wird ein Doppelpunkt zum Trennen der Jar-Files eingesetzt, unter Windows ein Semikolon!\nBeispiel: java -classpath .:/home/user/wuppy.jar MyApp\nVorgriff auf Build-Skripte (spätere VL): Im hier gezeigten Vorgehen werden die Abhängigkeiten manuell aufgelöst, d.h. die Jar-Files werden manuell heruntergeladen (oder selbst kompiliert) und dem Projekt hinzugefügt.\nAlle später besprochenen Build-Skripte (Ant, Gradle) beherrschen die automatische Auflösung von Abhängigkeiten. Dazu muss im Skript die Abhängigkeit auf geeignete Weise beschrieben werden und wird dann beim Kompilieren des Programms automatisch von spezialisierten Servern in der im Skript definierten Version heruntergeladen. Dies funktioniert auch bei rekursiven Abhängigkeiten ...\nÜberblick Umgang mit Apache Commons CLI Paket: org.apache.commons.cli\nDefinition der Optionen Je Option eine Instanz der Klasse Option Alle Optionen in Container Options sammeln Parsen der Eingaben mit DefaultParser Abfragen der Ergebnisse: CommandLine Formatierte Hilfe ausgeben: HelpFormatter Die Funktionsweise der einzelnen Klassen wird in der Demo kurz angerissen. Schauen Sie bitte zusätzlich in die Dokumentation.\nDemo: Einbinden von Libs, cli.Args Laden und Speichern von Konfigurationsdaten #ola - ein Kommentar hoehe=2 breite=9 gewicht=12 Konfigurationsdaten sind i.d.R. Schlüssel-Wert-Paare (String/String)\n=\u003e java.util.Properties\nTatsächlich verbirgt sich ein Hashtable dahinter:\npublic class Properties extends Hashtable\u003cObject,Object\u003e; Laden und Speichern von Konfigurationsdaten (cnt.) Properties anlegen und modifizieren\nProperties props = new Properties(); props.setProperty(\"breite\", \"9\"); props.setProperty(\"breite\", \"99\"); String value = props.getProperty(\"breite\"); Properties speichern: Properties#store und Properties#storeToXML\npublic void store(Writer writer, String comments) public void store(OutputStream out, String comments) public void storeToXML(OutputStream os, String comment, String encoding) Properties laden: Properties#load und Properties#loadFromXML\npublic void load(Reader reader) public void load(InputStream inStream) public void loadFromXML(InputStream in) Demo: cli.Props, Hinweis auf \"Apache Commons Configuration\" java.util.Properties sind eine einfache und im JDK bereits eingebaute Möglichkeit, mit Konfigurationsdateien zu hantieren. Deutlich umfangreichere Möglichkeiten bieten aber externe Bibliotheken, beispielsweise \"Apache Commons Configuration\" (commons.apache.org/configuration).\nWrap-Up Kommandozeilenparameter als String[] in main()-Methode Manuelle Auswertung komplex =\u003e Apache Commons CLI Schlüssel-Wert-Paare mit java.util.Properties aus/in Dateien laden/speichern",
    "description": "Wie kann man Programme konfigurieren? Parameter beim Start mitgeben: Kommandozeilenparameter (CLI)\nKonfigurationsdatei einlesen und auswerten\nVarianten von Kommandozeilenparameter Fixe Reihenfolge\njava MyApp 10 20 hello debug\nBenannte Parameter I\njava MyApp -x 10 -y 20 -answer hello -d\nBenannte Parameter II\njava MyApp --breite=10 --hoehe=20 --answer=hello --debug\nHäufig Mischung von Kurz- und Langformen\nHäufig hat man eine Kurzform der Optionen, also etwa \"-x\". Dabei ist der Name der Option in der Regel ein Zeichen lang. Es gibt aber auch Abweichungen von dieser Konvention, denken Sie beispielsweise an java -version.",
    "tags": [],
    "title": "Konfiguration eines Programms",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/java-jvm/configuration.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024) \u003e Praktikum",
    "content": "DevDungeon: Brücken-Troll Klonen Sie das Projekt DevDungeon und laden Sie es in Ihrer IDE als Gradle-Projekt. Betrachten Sie das Sub-Projekt \"devDungeon\". Dies ist ein von einem Studierenden (@Flamtky) erstelltes Spiel mit mehreren Leveln, in denen Sie spielerisch verschiedene Aufgaben in-game und ex-game lösen müssen.\nStarten Sie den DevDungeon mit ./gradlew devDungeon:runDevDungeon. Spielen Sie sich für diese Aufgabe durch das vierte Level (\"Bridge Guard Riddle\")1.\nIn diesem Level gibt es im oberen Teil eine Art Brücke, die von einem Brücken-Troll bewacht wird.\nDiesen müssen Sie besiegen, um die Brücke passieren und die Belohnung (einen magischen Schild) zu bekommen. Den Schild können Sie im nächsten Level gut gebrauchen: Der Schild schützt Ihren Hero vor Schäden, auch wenn er nur einen Treffer verträgt und sich dann über eine gewisse Zeit regenerieren muss, bevor er wieder funktionstüchtig ist.\nHinweis: Sie können natürlich wie immer auch \"außen herum\" gehen und die Brücke vermeiden, um ins nächste Level zu kommen. Das ist aber ziemlich gefährlich, und Sie bekommen den magischen Schild nicht, den Sie für das letzte Level ziemlich dringend brauchen.\nHinweis: Aktuell ist das Projekt DevDungeon an einigen Stellen noch Work-in-Progress, beispielsweise fehlt häufig noch die Javadoc. Alle Gradle-Tasks, die von Checkstyle-Tasks abhängen (checkstyleMain, check, build, ...) werden deshalb fehlschlagen. Sie können den DevDungeon aber wie oben beschrieben mit ./gradlew devDungeon:runDevDungeon (bzw. über den Task devDungeon:runDevDungeon aus der IDE heraus) starten.\nWICHTIG: Achten Sie bitte darauf, dass im Projektpfad keine Leerzeichen und keine Sonderzeichen (Umlaute o.ä.) vorkommen! Dies kann zu seltsamen Fehler führen. Bitte auch darauf achten, dass Sie als JDK ein Java SE 21 (LTS) verwenden.\nA10.1: RegExp mit dem Brücken-Troll (20%) Suchen Sie den Brücken-Troll auf und sprechen Sie ihn an. Er wird Ihnen eine Reihe von Fragen zum Thema reguläre Ausdrücke stellen, die Sie korrekt beantworten müssen.\nMachen Sie Screenshots von den Fragen und Ihren Antworten, die Sie im Praktikum vorstellen und diskutieren.\nA10.2: Command-Pattern mit der Klasse BridgeControlCommand (30%) Leider lässt sich der Brücken-Troll offenbar weder durch Diskussion noch durch Kampf besiegen. Aber vielleicht können Sie die Brücke \"aufmachen\", so dass er in die Tiefe stürzt? Die Tiles der Brücke bestehen aus sogenannten PitTiles: Wenn diese offen sind, fällt man hindurch; wenn sie geschlossen sind, kann man gefahrlos darauf treten (außer, es ist eine Verzögerung aktiviert :-) ... Allerdings müssten Sie danach die Brücke auch wieder schließen, um selbst darüber hinweg laufen zu können ...\nSchauen Sie sich die Info-Box am Eingang zur Brücke an. Der Hebel bedient mit Hilfe des Command-Patterns die Brücke. Für die Commands gibt es die Klasse BridgeControlCommand im Package entities.levercommands, wobei die Methode BridgeControlCommand#execute das Command ausführt und die Methode BridgeControlCommand#undo das Command wieder rückgängig macht.\nImplementieren Sie die beiden Methoden und starten Sie das Spiel erneut.\nHinweis: Mit der Methode Game.currentLevel().tileAt() können Sie auf ein Tile an einer bestimmte Koordinate zugreifen.\nA10.3: Syntaxhighlighting mit RegExp (50%) Klonen Sie die Vorgaben \"Syntax Highlighting\" und laden Sie das Projekt als Gradle-Projekt in Ihre IDE.\nIm Package highlighting finden Sie einige Klassen, mit denen man ein einfaches Syntax Highlighting durchführen kann. Dazu arbeitet der Lexer mit sogenannten \"Token\" (Instanzen der Klasse Token). Diese haben einen regulären Ausdruck, um bestimmte Teile im Code zu erkennen, beispielsweise Keywords oder Kommentare und anderes. Der Lexer wendet alle Token auf den aktuellen Eingabezeichenstrom an (Methode Token#test()), und die Token prüfen mit \"ihrem\" regulären Ausdruck, ob die jeweils passende Eingabesequenz vorliegt. Die regulären Ausdrücke übergeben Sie dem Token-Konstruktor als entsprechendes Pattern-Objekt.\nDie Klasse Token speichert dazu ein Pattern (einen vorkompilierten regulären Ausdruck) sowie eine Farbe, die später beim Syntax Highlighting für dieses Token genutzt werden soll. Bei der Anwendung eines Tokens auf einen String (Methode Token#test) wird das gespeicherte Pattern auf den String angewendet und eine Liste aller passenden Stellen im String zurückgegeben (List\u003cLexem\u003e).\nNeben dem jeweiligen Pattern kennt jedes Token noch eine matchingGroup: Dies ist ein Integer, der die relevante Matching-Group im regulären Ausdruck bezeichnet. Wenn Sie keine eigenen Gruppen in einem regulären Ausdruck eingebaut haben, nutzen Sie hier einfach den Wert 0.\nZusätzlich kennt jedes Token noch die Farbe für das Syntax-Highlighting in der von uns als Vorgabe realisierten Swing-GUI (Instanz von Color).\nDer Lexer sammelt eine Liste von Token und wendet sie in der übergebenen Reihenfolge auf den Eingabestring an (Methode Lexer#tokenize).\nDie Klasse LexerUI dient zum Anzeigen des ursprünglichen Textes und des Ergebnisses. Hier sieht man recht schnell, ob die Pattern bereits passen ... Man kann auf der linken Seite auch den Text editieren, und auf der rechten Seite des Fensters wird dann automatisch das Syntax Highlighting erneut durchgeführt.\nDie Klasse Main dient zum Definieren der konkreten Token (=\u003e Aufgabe) und auch zum Starten der Demo.\nAufgabe: Definieren Sie alle in Main#setupTokens genannten Token, indem Sie jeweils einen passenden regulären Ausdruck formulieren und als Pattern in den Konstruktor geben zusammen mit einer Farbe, mit der dieses Token hervorgehoben werden soll:\nStrings: alles zwischen \" und dem nächsten \" Character: genau ein Zeichen zwischen ' und ' Keywords: package, import, class, public, private, final, return, null, new (jeweils freistehend, also nicht \"newx\" o.ä.) Annotation: beginnt mit @, enthält Buchstaben oder Minuszeichen Einzeiliger Kommentar: beginnend mit // bis zum Zeilenende Mehrzeiliger Kommentar: alles zwischen /* und dem nächsten */ Javadoc-Kommentar: alles zwischen /** und dem nächsten */ Sie können auch mit Matching Groups arbeiten und im Token eine bestimmte Gruppe hervorheben lassen. Dazu geben Sie einfach die Nummer der Matching-Group mit in den Token-Konstruktor. (Wenn Sie nichts übergeben, wird der gesamte Match genommen - das entspricht dem Wert 0).\nSollten Token ineinander geschachtelt sein, erkennt der Lexer dies automatisch. Sie brauchen sich keine Gedanken dazu machen, in welcher Reihenfolge die Token eingefügt und abgearbeitet werden. Beispiel: Im regulären Ausdruck für den einzeiligen Kommentar brauchen Sie keine Keywords, Annotationen, Strings usw. erkennen.\nDas vierte richtige Level, also das vierte Level nach dem Demo-Level. Oder eben das fünfte Level, wenn man das Demo-Level mitzählt :-) ↩︎",
    "description": "DevDungeon: Brücken-Troll Klonen Sie das Projekt DevDungeon und laden Sie es in Ihrer IDE als Gradle-Projekt. Betrachten Sie das Sub-Projekt \"devDungeon\". Dies ist ein von einem Studierenden (@Flamtky) erstelltes Spiel mit mehreren Leveln, in denen Sie spielerisch verschiedene Aufgaben in-game und ex-game lösen müssen.\nStarten Sie den DevDungeon mit ./gradlew devDungeon:runDevDungeon. Spielen Sie sich für diese Aufgabe durch das vierte Level (\"Bridge Guard Riddle\")1.\nIn diesem Level gibt es im oberen Teil eine Art Brücke, die von einem Brücken-Troll bewacht wird.",
    "tags": [],
    "title": "Blatt 10: DevDungeon \u0026 Syntax Highlighting (Reguläre Ausdrücke)",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/homework/b10.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024)",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/categories.html"
  },
  {
    "breadcrumb": "IFM 2.1: Programmieren 2 (PO23, Sommer 2024)",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/elearning/data/FH-Bielefeld/lm_data/lm_1661234/tags.html"
  }
]
