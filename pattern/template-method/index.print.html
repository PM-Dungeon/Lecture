<!DOCTYPE html>
<html lang="de-DE" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.135.0">
    <meta name="generator" content="Relearn 6.4.1">
    <meta name="description" content="Motivation: Syntax-Highlighting im Tokenizer In einem Compiler ist meist der erste Arbeitsschritt, den Eingabestrom in einzelne Token aufzubrechen. Dies sind oft die verschiedenen Schlüsselwörter, Operationen, Namen von Variablen, Methoden, Klassen etc. ... Aus der Folge von Zeichen (also dem eingelesenen Programmcode) wird ein Strom von Token, mit dem die nächste Stufe im Compiler dann weiter arbeiten kann.
public class Lexer { private final List&lt;Token&gt; allToken; // alle verfügbaren Token-Klassen public List&lt;Token&gt; tokenize(String string) { List&lt;Token&gt; result = new ArrayList&lt;&gt;(); while (string.length() &gt; 0) { for (Token t : allToken) { Token token = t.match(string); if (token != null) { result.add(token); string = string.substring(token.getContent().length(), string.length()); } } } return result; } } Dazu prüft man jedes Token, ob es auf den aktuellen Anfang des Eingabestroms passt. Wenn ein Token passt, erzeugt man eine Instanz dieser Token-Klasse und speichert darin den gematchten Eingabeteil, den man dann vom Eingabestrom entfernt. Danach geht man in die Schleife und prüft wieder alle Token ... bis irgendwann der Eingabestrom leer ist und man den gesamten eingelesenen Programmcode in eine dazu passende Folge von Token umgewandelt hat.">
    <meta name="author" content="">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Template-Method-Pattern">
    <meta name="twitter:description" content="Motivation: Syntax-Highlighting im Tokenizer In einem Compiler ist meist der erste Arbeitsschritt, den Eingabestrom in einzelne Token aufzubrechen. Dies sind oft die verschiedenen Schlüsselwörter, Operationen, Namen von Variablen, Methoden, Klassen etc. ... Aus der Folge von Zeichen (also dem eingelesenen Programmcode) wird ein Strom von Token, mit dem die nächste Stufe im Compiler dann weiter arbeiten kann.
public class Lexer { private final List&lt;Token&gt; allToken; // alle verfügbaren Token-Klassen public List&lt;Token&gt; tokenize(String string) { List&lt;Token&gt; result = new ArrayList&lt;&gt;(); while (string.length() &gt; 0) { for (Token t : allToken) { Token token = t.match(string); if (token != null) { result.add(token); string = string.substring(token.getContent().length(), string.length()); } } } return result; } } Dazu prüft man jedes Token, ob es auf den aktuellen Anfang des Eingabestroms passt. Wenn ein Token passt, erzeugt man eine Instanz dieser Token-Klasse und speichert darin den gematchten Eingabeteil, den man dann vom Eingabestrom entfernt. Danach geht man in die Schleife und prüft wieder alle Token ... bis irgendwann der Eingabestrom leer ist und man den gesamten eingelesenen Programmcode in eine dazu passende Folge von Token umgewandelt hat.">
    <meta property="og:url" content="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1661234/pattern/template-method.html">
    <meta property="og:title" content="Template-Method-Pattern">
    <meta property="og:description" content="Motivation: Syntax-Highlighting im Tokenizer In einem Compiler ist meist der erste Arbeitsschritt, den Eingabestrom in einzelne Token aufzubrechen. Dies sind oft die verschiedenen Schlüsselwörter, Operationen, Namen von Variablen, Methoden, Klassen etc. ... Aus der Folge von Zeichen (also dem eingelesenen Programmcode) wird ein Strom von Token, mit dem die nächste Stufe im Compiler dann weiter arbeiten kann.
public class Lexer { private final List&lt;Token&gt; allToken; // alle verfügbaren Token-Klassen public List&lt;Token&gt; tokenize(String string) { List&lt;Token&gt; result = new ArrayList&lt;&gt;(); while (string.length() &gt; 0) { for (Token t : allToken) { Token token = t.match(string); if (token != null) { result.add(token); string = string.substring(token.getContent().length(), string.length()); } } } return result; } } Dazu prüft man jedes Token, ob es auf den aktuellen Anfang des Eingabestroms passt. Wenn ein Token passt, erzeugt man eine Instanz dieser Token-Klasse und speichert darin den gematchten Eingabeteil, den man dann vom Eingabestrom entfernt. Danach geht man in die Schleife und prüft wieder alle Token ... bis irgendwann der Eingabestrom leer ist und man den gesamten eingelesenen Programmcode in eine dazu passende Folge von Token umgewandelt hat.">
    <meta property="og:locale" content="de_DE">
    <meta property="og:type" content="website">
    <meta itemprop="name" content="Template-Method-Pattern">
    <meta itemprop="description" content="Motivation: Syntax-Highlighting im Tokenizer In einem Compiler ist meist der erste Arbeitsschritt, den Eingabestrom in einzelne Token aufzubrechen. Dies sind oft die verschiedenen Schlüsselwörter, Operationen, Namen von Variablen, Methoden, Klassen etc. ... Aus der Folge von Zeichen (also dem eingelesenen Programmcode) wird ein Strom von Token, mit dem die nächste Stufe im Compiler dann weiter arbeiten kann.
public class Lexer { private final List&lt;Token&gt; allToken; // alle verfügbaren Token-Klassen public List&lt;Token&gt; tokenize(String string) { List&lt;Token&gt; result = new ArrayList&lt;&gt;(); while (string.length() &gt; 0) { for (Token t : allToken) { Token token = t.match(string); if (token != null) { result.add(token); string = string.substring(token.getContent().length(), string.length()); } } } return result; } } Dazu prüft man jedes Token, ob es auf den aktuellen Anfang des Eingabestroms passt. Wenn ein Token passt, erzeugt man eine Instanz dieser Token-Klasse und speichert darin den gematchten Eingabeteil, den man dann vom Eingabestrom entfernt. Danach geht man in die Schleife und prüft wieder alle Token ... bis irgendwann der Eingabestrom leer ist und man den gesamten eingelesenen Programmcode in eine dazu passende Folge von Token umgewandelt hat.">
    <meta itemprop="wordCount" content="935">
    <title>Template-Method-Pattern</title>
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1661234/pattern/template-method.html" rel="canonical" type="text/html" title="Template-Method-Pattern">

    

    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1661234/images/logo.png?1729954976" rel="icon" type="image/png">

    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1661234/css/fontawesome-all.min.css?1729954976" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/elearning/data/FH-Bielefeld/lm_data/lm_1661234/css/fontawesome-all.min.css?1729954976" rel="stylesheet"></noscript>
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1661234/css/nucleus.css?1729954976" rel="stylesheet">
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1661234/css/auto-complete.css?1729954976" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/elearning/data/FH-Bielefeld/lm_data/lm_1661234/css/auto-complete.css?1729954976" rel="stylesheet"></noscript>
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1661234/css/perfect-scrollbar.min.css?1729954976" rel="stylesheet">
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1661234/css/fonts.css?1729954976" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/elearning/data/FH-Bielefeld/lm_data/lm_1661234/css/fonts.css?1729954976" rel="stylesheet"></noscript>
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1661234/css/theme.css?1729954976" rel="stylesheet">
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1661234/css/theme-auto.css?1729954976" rel="stylesheet" id="R-variant-style">
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1661234/css/chroma-auto.css?1729954976" rel="stylesheet" id="R-variant-chroma-style">
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1661234/css/variant.css?1729954976" rel="stylesheet">
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1661234/css/print.css?1729954976" rel="stylesheet" media="print">
    <link href="/elearning/data/FH-Bielefeld/lm_data/lm_1661234/css/format-print.css?1729954976" rel="stylesheet">
    <script src="/elearning/data/FH-Bielefeld/lm_data/lm_1661234/js/variant.js?1729954976"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='..';
      window.relearn.relBaseUri='..\/..\/..\/..\/..\/..';
      window.relearn.absBaseUri='https:\/\/www.hsbi.de\/elearning\/data\/FH-Bielefeld\/lm_data\/lm_1661234';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.index_js_url="/elearning/data/FH-Bielefeld/lm_data/lm_1661234/index.search.js?1729954976";
      // variant stuff
      window.variants && variants.init( [ 'auto', 'zen-light', 'zen-dark', 'relearn-bright', 'relearn-light', 'relearn-dark' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script><style type="text/css">

 
.center {
    align-content: center;
    text-align: center;
    margin: auto;
}
.alert {
    color: #ff3333;
}
.bsp {
    padding: 0.05cm;
    border-width: 0.05cm;
    border-style: solid;
    border-color: #ddd;
    background-color: #ddd;
    border-radius: 25px;
    float: right;
}
.cbox {
    padding: 0.2cm;
    border-width: 0.1cm;
    border-style: solid;
    border-color: #4070a0;
    background-color: #f2f2f2;
    margin: auto;
    width: 60%;
    text-align: center;
    overflow: auto;
}
.blueArrow {
    color: #4070a0;
    font-family: "Courier New", "Courier", monospace;
    font-weight: bold;
}
.origin {
    background-color: #ededed;
    font-size: 0.8em;
}
.showme {
    background-color: #ededed;
    font-size: 0.8em;
}


 
.tldr {
    background: #dbe4ed;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.recap {
    
    
   margin: 4px 0px 26px 0px;
}
.bib {
    background: #dbe4ed;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.outcomes {
    background: #d9e9d5;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.quizzes {
    background: #d9e9d5;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.challenges {
    background: #ebe4d6;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.assignments {
    background: #ebe4d6;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
h1.tldr, h1.recap, h1.bib, h1.outcomes, h1.quizzes, h1.challenges, h1.assignments {
    padding: 0px;
}


 
.noJsAlert {
    padding: 20px;
    background-color: #f44336;  
    color: white;
    margin-bottom: 15px;
}


 
.embed-video-player {
    position: relative;
    padding-bottom: 56%;
    height: 0;
    overflow: hidden;
}
.youtube-player {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border:0;
}


 
#header-wrapper {
    padding:0.6rem;
}


 
#shortcuts {
    padding-top: 2.0rem;
}


 
#chapter p {
    text-align: left;
}


 
figcaption h4 {
    margin-top:-2.5rem;
}
.border1 {
    border:1px solid black;
}

 
td ul, td ol {
    margin: 0 0 1rem 0.5rem;
    padding: 0 0 0 0.5rem;
}

 
h1 { font-size:2.8rem !important;}
h2 { font-size:2.2rem; margin:1.2rem 0}
h3 { font-size:1.9rem; text-align:left !important; font-weight:400 !important;}
h4 { font-size:1.6rem}
h5 { font-size:1.3rem}
h6 { font-size:1rem}

h2 {
    width:100% !important;
    border-bottom:1px solid #5e5e5e !important;
    padding-bottom: 2px;
}
.tldr h2, .recap h2, .bib h2, .outcomes h2, .quizzes h2, .challenges h2, .assignments h2 {
    margin:0.5rem 0
}

.btn-crossreference, .btn-crossreference:hover {
    cursor: initial;
}

</style>

  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="/elearning/data/FH-Bielefeld/lm_data/lm_1661234/pattern/template-method.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
          </div>
          <span class="topbar-breadcrumbs highlightable">
            Template-Method-Pattern
          </span>
          <div class="topbar-area topbar-area-end" data-area="end">
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable " tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
<h1>Template-Method-Pattern</h1>



    



    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-graduation-cap"></i> TL;DR
  </div>
  <div class="box-content">
<p>Das Template-Method-Pattern ist ein Entwurfsmuster, bei dem ein gewisses Verhalten
in einer Methode implementiert wird, die wie eine Schablone agiert, der sogenannten
&quot;Template-Methode&quot;. Darin werden dann u.a. Hilfsmethoden aufgerufen, die in der
Basisklasse entweder als <code>abstract</code> markiert sind oder mit einem leeren Body
implementiert sind (&quot;Hook-Methoden&quot;). Über diese Template-Methode legt also die
Basisklasse ein gewisses Verhaltensschema fest (&quot;Template&quot;) - daher auch der Name.</p>
<p>In den ableitenden Klassen werden dann die abstrakten Methoden und/oder die Hook-Methoden
implementiert bzw. überschrieben und damit das Verhalten verfeinert.</p>
<p>Zur Laufzeit ruft man auf den Objekten die Template-Methode auf. Dabei wird von der
Laufzeitumgebung der konkrete Typ der Objekte bestimmt (auch wenn man sie unter dem
Typ der Oberklasse führt) und die am tiefsten in der Vererbungshierarchie implementierten
Methoden aufgerufen. D.h. die Aufrufe der Hilfsmethoden in der Template-Methode führen
zu den in der jeweiligen ableitenden Klasse implementierten Varianten.</p>
  </div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-podcast"></i> Videos (YouTube)
  </div>
  <div class="box-content">
<ul> <li><a href='https://youtu.be/EE-n2T6AO-g' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Template-Method-Pattern</a></li></ul>
  </div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)
  </div>
  <div class="box-content">
<ul> <li><a href='https://www.hsbi.de/medienportal/m/a368cbd0990f4f58e5ee776bb4d6a1443c0a7cd443177eaa35ba35558e5c01307f689be5c9c239c6ffb41c74d2726397f2ba6be086df30737eec1df17ac4827a' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Template-Method-Pattern</a></li></ul>
  </div>
</div>




    
    
    
    






    
    





    

    

    
    
        
        
        
        
    
    

    <div class="box notices cstyle tip">
  <div class="box-label">
    <i class="fas fa-lightbulb"></i> Lernziele
  </div>
  <div class="box-content">
<ul> <li>(K3) Template-Method-Entwurfsmuster praktisch anwenden</li></ul>
  </div>
</div>




    <h2 id="motivation-syntax-highlighting-im-tokenizer">Motivation: Syntax-Highlighting im Tokenizer</h2>
<p>In einem Compiler ist meist der erste Arbeitsschritt, den Eingabestrom in einzelne
Token aufzubrechen. Dies sind oft die verschiedenen Schlüsselwörter, Operationen,
Namen von Variablen, Methoden, Klassen etc. ... Aus der Folge von Zeichen (also dem
eingelesenen Programmcode) wird ein Strom von Token, mit dem die nächste Stufe im
Compiler dann weiter arbeiten kann.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Lexer</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> List<span style="color:#f92672">&lt;</span>Token<span style="color:#f92672">&gt;</span> allToken;  <span style="color:#75715e">// alle verfügbaren Token-Klassen</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> List<span style="color:#f92672">&lt;</span>Token<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">tokenize</span>(String string) {
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Token<span style="color:#f92672">&gt;</span> result <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (string.<span style="color:#a6e22e">length</span>() <span style="color:#f92672">&gt;</span> 0) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (Token t : allToken) {
</span></span><span style="display:flex;"><span>                Token token <span style="color:#f92672">=</span> t.<span style="color:#a6e22e">match</span>(string);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (token <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>                    result.<span style="color:#a6e22e">add</span>(token);
</span></span><span style="display:flex;"><span>                    string <span style="color:#f92672">=</span> string.<span style="color:#a6e22e">substring</span>(token.<span style="color:#a6e22e">getContent</span>().<span style="color:#a6e22e">length</span>(), string.<span style="color:#a6e22e">length</span>());
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Dazu prüft man jedes Token, ob es auf den aktuellen Anfang des Eingabestroms passt.
Wenn ein Token passt, erzeugt man eine Instanz dieser Token-Klasse und speichert darin
den gematchten Eingabeteil, den man dann vom Eingabestrom entfernt. Danach geht man
in die Schleife und prüft wieder alle Token ... bis irgendwann der Eingabestrom leer
ist und man den gesamten eingelesenen Programmcode in eine dazu passende Folge von
Token umgewandelt hat.</p>
<p><em>Anmerkung</em>: Abgesehen von fehlenden Javadoc etc. hat das obige Code-Beispiel mehrere
Probleme: Man würde im realen Leben nicht mit <code>String</code>, sondern mit einem Zeichenstrom
arbeiten. Außerdem fehlt noch eine Fehlerbehandlung, wenn nämlich keines der Token in
der Liste <code>allToken</code> auf den aktuellen Anfang des Eingabestroms passt.</p>
<h2 id="token-klassen-mit-formatiertem-inhalt">Token-Klassen mit formatiertem Inhalt</h2>
<p>Um den eigenen Tokenizer besser testen zu können, wurde beschlossen, dass jedes Token
seinen Inhalt als formatiertes HTML-Schnipsel zurückliefern soll. Damit kann man dann
alle erkannten Token formatiert ausgeben und erhält eine Art Syntax-Highlighting für
den eingelesenen Programmcode.</p>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Token</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> String content;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">protected</span> String <span style="color:#a6e22e">getHtml</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">KeyWord</span> <span style="color:#66d9ef">extends</span> Token {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> String <span style="color:#a6e22e">getHtml</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&lt;font color=\&#34;red\&#34;&gt;&lt;b&gt;&#34;</span> <span style="color:#f92672">+</span>  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">content</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&lt;/b&gt;&lt;/font&gt;&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StringContent</span> <span style="color:#66d9ef">extends</span> Token {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> String <span style="color:#a6e22e">getHtml</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&lt;font color=\&#34;green\&#34;&gt;&#34;</span> <span style="color:#f92672">+</span>  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">content</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&lt;/font&gt;&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Token t <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> KeyWord();
</span></span><span style="display:flex;"><span>LOG.<span style="color:#a6e22e">info</span>(t.<span style="color:#a6e22e">getHtml</span>());</span></span></code></pre></div>
<p>In der ersten Umsetzung erhält die Basisklasse <code>Token</code> eine weitere abstrakte
Methode, die jede Token-Klasse implementieren muss und in der die Token-Klassen
einen String mit dem Token-Inhalt und einer Formatierung für HTML zurückgeben.</p>
<p>Dabei fällt auf, dass der Aufbau immer gleich ist: Es werden ein oder mehrere
Tags zum Start der Format-Sequenz mit dem Token-Inhalt verbunden, gefolgt mit
einem zum verwendeten startenden HTML-Format-Tag passenden End-Tag.</p>
<p>Auch wenn die Inhalte unterschiedlich sind, sieht das stark nach einer Verletzung
von DRY aus ...</p>
<h2 id="dont-call-us-well-call-you">Don't call us, we'll call you</h2>
<div class="highlight wrap-code"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Token</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> String content;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> String <span style="color:#a6e22e">getHtml</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> htmlStart() <span style="color:#f92672">+</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">content</span> <span style="color:#f92672">+</span> htmlEnd();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">protected</span> String <span style="color:#a6e22e">htmlStart</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">protected</span> String <span style="color:#a6e22e">htmlEnd</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">KeyWord</span> <span style="color:#66d9ef">extends</span> Token {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span> <span style="color:#66d9ef">protected</span> String <span style="color:#a6e22e">htmlStart</span>() { <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&lt;font color=\&#34;red\&#34;&gt;&lt;b&gt;&#34;</span>; }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span> <span style="color:#66d9ef">protected</span> String <span style="color:#a6e22e">htmlEnd</span>() { <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&lt;/b&gt;&lt;/font&gt;&#34;</span>; }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StringContent</span> <span style="color:#66d9ef">extends</span> Token {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span> <span style="color:#66d9ef">protected</span> String <span style="color:#a6e22e">htmlStart</span>() { <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&lt;font color=\&#34;green\&#34;&gt;&#34;</span>; }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span> <span style="color:#66d9ef">protected</span> String <span style="color:#a6e22e">htmlEnd</span>() { <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&lt;/font&gt;&#34;</span>; }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Token t <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> KeyWord();
</span></span><span style="display:flex;"><span>LOG.<span style="color:#a6e22e">info</span>(t.<span style="color:#a6e22e">getHtml</span>());</span></span></code></pre></div>
<p>Wir können den Spaß einfach umdrehen (<a href="https://en.wikipedia.org/wiki/Inversion_of_control" rel="external" target="_blank">&quot;inversion of control&quot;</a>)
und die Methode zum Zusammenbasteln des HTML-Strings bereits in der Basisklasse
implementieren. Dazu &quot;rufen&quot; wir dort drei Hilfsmethoden auf, die die jeweiligen
Bestandteile des Strings (Format-Start, Inhalt, Format-Ende) erzeugen und deren
konkrete Implementierung wir in der Basisklasse nicht kennen. Dies ist dann Sache
der ableitenden konkreten Token-Klassen.</p>
<p>Objekte vom Typ <code>KeyWord</code> sind dank der Vererbungsbeziehung auch <code>Token</code> (Vererbung:
<em>is-a-Beziehung</em>). Wenn man nun auf einem <code>Token t</code> die Methode <code>getHtml()</code> aufruft,
wird zur Laufzeit geprüft, welchen Typ <code>t</code> tatsächlich hat (im Beispiel <code>KeyWord</code>).
Methodenaufrufe werden dann mit den am tiefsten in der vorliegenden Vererbungshierarchie
implementierten Methoden durchgeführt: Hier wird also die von <code>Token</code> geerbte Methode
<code>getHtml()</code> in <code>KeyWord</code> aufgerufen, die ihrerseits die Methoden <code>htmlStart()</code> und
<code>htmlEnd()</code> aufruft. Diese sind in <code>KeyWord</code> implementiert und liefern nun die passenden
Ergebnisse.</p>
<p>Die Methode <code>getHtml()</code> wird auch als &quot;<em>Template-Methode</em>&quot; bezeichnet. Die beiden darin
aufgerufenen Methoden <code>htmlStart()</code> und <code>htmlEnd()</code> in <code>Token</code> werden auch als &quot;Hilfsmethoden&quot;
(oder &quot;<em>Helper Methods</em>&quot;) bezeichnet.</p>
<p>Dies ist ein Beispiel für das <strong><a href="https://en.wikipedia.org/wiki/Template_method_pattern" rel="external" target="_blank">Template-Method-Pattern</a></strong>.</p>
<h2 id="template-method-pattern">Template-Method-Pattern</h2>
<p><a href="#R-image-4ed5b36e05c41a6198a740bf7728aba3" class="lightbox-link"><img class="noborder lazy lightbox noshadow figure-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1661234/pattern/template-method/template-method.png?width=50%25&height=auto" style=" height: auto; width: 50%;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4ed5b36e05c41a6198a740bf7728aba3"><img class="noborder lazy lightbox noshadow lightbox-image" loading="lazy" src="/elearning/data/FH-Bielefeld/lm_data/lm_1661234/pattern/template-method/template-method.png?width=50%25&height=auto"></a></p>
<h3 id="aufbau-template-method-pattern">Aufbau Template-Method-Pattern</h3>
<p>In der Basisklasse implementiert man eine Template-Methode (in der Skizze <code>templateMethod</code>),
die sich auf anderen in der Basisklasse deklarierten (Hilfs-) Methoden &quot;abstützt&quot; (diese also
aufruft; in der Skizze <code>method1</code>, <code>method2</code>, <code>method3</code>). Diese Hilfsmethoden können als
<code>abstract</code> markiert werden und müssen dann von den ableitenden Klassen implementiert werden
(in der Skizze <code>method1</code> und <code>method2</code>). Man kann aber auch einige/alle dieser aufgerufenen
Hilfsmethoden in der Basisklasse implementieren (beispielsweise mit einem leeren Body - sogenannte
&quot;Hook&quot;-Methoden) und die ableitenden Klassen <em>können</em> dann diese Methoden überschreiben und das
Verhalten so neu formulieren (in der Skizze <code>method3</code>).</p>
<p>Damit werden Teile des Verhaltens an die ableitenden Klassen ausgelagert.</p>
<h3 id="verwandtschaft-zum-strategy-pattern">Verwandtschaft zum Strategy-Pattern</h3>
<p>Das Template-Method-Pattern hat eine starke Verwandtschaft zum Strategy-Pattern.</p>
<p>Im Strategy-Pattern haben wir Verhalten komplett an andere Objekte <em>delegiert</em>, indem wir in
einer Methode einfach die passende Methode auf dem übergebenen Strategie-Objekt aufgerufen haben.</p>
<p>Im Template-Method-Pattern nutzen wir statt Delegation die Mechanismen Vererbung und dynamische
Polymorphie und definieren in der Basis-Klasse abstrakte oder Hook-Methoden, die wir bereits in
der Template-Methode der Basis-Klasse aufrufen. Damit ist das grobe Verhalten in der Basis-Klasse
festgelegt, wird aber in den ableitenden Klassen durch das dortige Definieren oder Überschreiben
der Hilfsmethoden verfeinert. Zur Laufzeit werden dann durch die dynamische Polymorphie die
tatsächlich implementierten Hilfsmethoden in den ableitenden Klassen aufgerufen. Damit lagert man
im Template-Method-Pattern gewissermaßen nur Teile des Verhaltens an die ableitenden Klassen aus.</p>
<h2 id="wrap-up">Wrap-Up</h2>
<p>Template-Method-Pattern: Verhaltensänderung durch Vererbungsbeziehungen</p>
<ul>
<li>Basis-Klasse:
<ul>
<li>Template-Methode, die Verhalten definiert und Hilfsmethoden aufruft</li>
<li>Hilfsmethoden: Abstrakte Methoden (oder &quot;Hook&quot;: Basis-Implementierung)</li>
</ul>
</li>
<li>Ableitende Klassen: Verfeinern Verhalten durch Implementieren der Hilfsmethoden</li>
<li>Zur Laufzeit: Dynamische Polymorphie: Aufruf der Template-Methode nutzt
die im tatsächlichen Typ des Objekts implementierten Hilfsmethoden</li>
</ul>


    



    
    
        
        
        
            
        
    
    

    <div class="box notices cstyle tip">
  <div class="box-label">
    <i class="fas fa-user-check"></i> Quizzes
  </div>
  <div class="box-content">
<ul> <li><a href='https://www.hsbi.de/elearning/goto.php?target=tst_1106538&client_id=FH-Bielefeld' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Quiz Template-Method-Pattern (ILIAS)</a></li></ul>
  </div>
</div>



    



    

    <div class="box notices cstyle note">
  <div class="box-label">
    <i class="fas fa-puzzle-piece"></i> Challenges
  </div>
  <div class="box-content">
<p>Schreiben Sie eine abstrakte Klasse Drucker. Implementieren Sie die Funktion
<code>kopieren</code>, bei der zuerst die Funktion <code>scannen</code> und dann die Funktion <code>drucken</code>
aufgerufen wird. Der Kopiervorgang ist für alle Druckertypen identisch,
das Scannen und Drucken ist abhängig vom Druckertyp.</p>
<p>Implementieren Sie zusätzlich zwei unterschiedliche Druckertypen:</p>
<ul>
<li><code>Tintendrucker extends Drucker</code>
<ul>
<li><code>Tintendrucker#drucken</code> loggt den Text &quot;Drucke das Dokument auf dem Tintendrucker.&quot;</li>
<li><code>Tintendrucker#scannen</code> loggt den Text &quot;Scanne das Dokument mit dem Tintendrucker.&quot;</li>
</ul>
</li>
<li><code>Laserdrucker extends Drucker</code>
<ul>
<li><code>Laserdrucker#drucken</code> loggt den Text &quot;Drucke das Dokument auf dem Laserdrucker.&quot;</li>
<li><code>Laserdrucker#scannen</code> loggt den Text &quot;Scanne das Dokument mit dem Laserdrucker.&quot;</li>
</ul>
</li>
</ul>
<p>Nutzen Sie das Template-Method-Pattern.</p>
  </div>
</div>



    




    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    <div class="box notices cstyle info">
  <div class="box-label">
    <i class="fas fa-book-reader"></i> Quellen
  </div>
  <div class="box-content">
<ul> <li id='id_Eilebrecht2013'>[Eilebrecht2013] <strong>Patterns kompakt</strong><br>Eilebrecht, K. und Starke, G., Springer, 2013. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-6423-4718-4' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-6423-4718-4</a>.</li> <li id='id_Gamma2011'>[Gamma2011] <strong>Design Patterns</strong><br>Gamma, E. und Helm, R. und Johnson, R. E. und Vlissides, J., Addison-Wesley, 2011. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-0-2016-3361-0' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-0-2016-3361-0</a>.</li></ul>
  </div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin-left: 4rem; margin-right: 4rem; margin-top: 6rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Programmiermethoden-CampusMinden/Prog2-Lecture">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a> and <a href="https://github.com/Programmiermethoden-CampusMinden/Prog2-Lecture/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Programmiermethoden-CampusMinden/Prog2-Lecture/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Programmiermethoden-CampusMinden/Prog2-Lecture/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

        </div>
      </main>
    </div>
    <script src="/elearning/data/FH-Bielefeld/lm_data/lm_1661234/js/clipboard.min.js?1729954976" defer></script>
    <script src="/elearning/data/FH-Bielefeld/lm_data/lm_1661234/js/perfect-scrollbar.min.js?1729954976" defer></script>
    <script>
      function useMathJax( config ){
        window.MathJax = Object.assign( window.MathJax || {}, {
          tex: {
            inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
            displayMath: [['\\[', '\\]'], ['$$', '$$']], 
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="/elearning/data/FH-Bielefeld/lm_data/lm_1661234/js/mathjax/tex-mml-chtml.js?1729954976"></script>
    <script src="/elearning/data/FH-Bielefeld/lm_data/lm_1661234/js/theme.js?1729954976" defer></script>
  </body>
</html>
